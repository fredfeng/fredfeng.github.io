{"id":28482,"className":"javax.crypto.Cipher","methodName":"init","signature":"\u003cjavax.crypto.Cipher: void init(int,java.security.cert.Certificate,java.security.SecureRandom)\u003e","javadoc":"/** \n * Initializes this cipher with the public key from the given certificate and a source of randomness. \u003cp\u003eThe cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of \u003ccode\u003eopmode\u003c/code\u003e. \u003cp\u003eIf the certificate is of type X.509 and has a \u003ci\u003ekey usage\u003c/i\u003e extension field marked as critical, and the value of the \u003ci\u003ekey usage\u003c/i\u003e extension field implies that the public key in the certificate and its corresponding private key are not supposed to be used for the operation represented by the value of \u003ccode\u003eopmode\u003c/code\u003e, an \u003ccode\u003eInvalidKeyException\u003c/code\u003e is thrown. \u003cp\u003eIf this cipher requires any algorithm parameters that cannot be derived from the public key in the given \u003ccode\u003ecertificate\u003c/code\u003e, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an \u003ccode\u003eInvalidKeyException\u003c/code\u003e if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using {@link #getParameters() getParameters} or{@link #getIV() getIV} (if the parameter is an IV).\u003cp\u003eIf this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. \u003cp\u003eIf this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them from \u003ccode\u003erandom\u003c/code\u003e. \u003cp\u003eNote that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it.\n * @param opmode the operation mode of this cipher (this is one of thefollowing: \u003ccode\u003eENCRYPT_MODE\u003c/code\u003e, \u003ccode\u003eDECRYPT_MODE\u003c/code\u003e, \u003ccode\u003eWRAP_MODE\u003c/code\u003e or \u003ccode\u003eUNWRAP_MODE\u003c/code\u003e)\n * @param certificate the certificate\n * @param random the source of randomness\n * @exception InvalidKeyException if the public key in the givencertificate is inappropriate for initializing this cipher, or this cipher requires algorithm parameters that cannot be determined from the public key in the given certificate, or the keysize of the public key in the given certificate has a keysize that exceeds the maximum allowable keysize (as determined by the configured jurisdiction policy files).\n */\n","tf":{"freq":{"acquir":1,"unwrap":2,"deriv":2,"reason":1,"keysiz":3,"type":1,"feedback":1,"requir":5,"scheme":1,"given":4,"invalid":3,"fail":1,"equival":1,"oper":3,"file":1,"encrypt":2,"impli":1,"key":16,"follow":1,"wrap":2,"except":4,"thrown":1,"creat":1,"random":6,"init":1,"mark":1,"polici":1,"provid":2,"instanc":1,"configur":1,"input":1,"maximum":1,"determin":2,"will":2,"word":1,"sourc":2,"critic":1,"allow":1,"inappropri":1,"correspond":1,"one":2,"link":2,"state":1,"use":3,"thefollow":1,"object":1,"givencertif":1,"mode":1,"algorithm":3,"jurisdict":1,"decrypt":2,"rais":1,"extens":2,"valu":5,"initi":9,"four":1,"note":1,"pad":1,"certif":8,"includ":1,"previous":1,"repres":1,"depend":1,"exceed":1,"paramet":10,"suppos":2,"opmod":3,"field":2,"lose":1,"specif":2,"retriev":1,"generat":3,"cipher":12,"usag":2,"necessarili":1},"maxFreq":16,"totalTerms":174},"loc":47}