{"id":28492,"className":"javax.crypto.Cipher","methodName":"doFinal","signature":"\u003cjavax.crypto.Cipher: int doFinal(byte[],int,int,byte[])\u003e","javadoc":"/** \n * Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized. \u003cp\u003eThe first \u003ccode\u003einputLen\u003c/code\u003e bytes in the \u003ccode\u003einput\u003c/code\u003e buffer, starting at \u003ccode\u003einputOffset\u003c/code\u003e inclusive, and any input bytes that may have been buffered during a previous \u003ccode\u003eupdate\u003c/code\u003e operation, are processed, with padding (if requested) being applied. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in the \u003ccode\u003eoutput\u003c/code\u003e buffer. \u003cp\u003eIf the \u003ccode\u003eoutput\u003c/code\u003e buffer is too small to hold the result, a \u003ccode\u003eShortBufferException\u003c/code\u003e is thrown. In this case, repeat this call with a larger output buffer. Use {@link #getOutputSize(int) getOutputSize} to determine how bigthe output buffer should be. \u003cp\u003eUpon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to \u003ccode\u003einit\u003c/code\u003e. That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to \u003ccode\u003einit\u003c/code\u003e) more data. \u003cp\u003eNote: if any exception is thrown, this cipher object may need to be reset before it can be used again. \u003cp\u003eNote: this method should be copy-safe, which means the \u003ccode\u003einput\u003c/code\u003e and \u003ccode\u003eoutput\u003c/code\u003e buffers can reference the same byte array and no unprocessed input data is overwritten when the result is copied into the output buffer.\n * @param input the input buffer\n * @param inputOffset the offset in \u003ccode\u003einput\u003c/code\u003e where the inputstarts\n * @param inputLen the input length\n * @param output the buffer for the result\n * @return the number of bytes stored in \u003ccode\u003eoutput\u003c/code\u003e\n * @exception IllegalStateException if this cipher is in a wrong state(e.g., has not been initialized)\n * @exception IllegalBlockSizeException if this cipher is a block cipher,no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided.\n * @exception ShortBufferException if the given output buffer is too smallto hold the result\n * @exception BadPaddingException if this cipher is in decryption mode,and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes\n * @exception AEADBadTagException if this cipher is decrypting in anAEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value\n */\n","tf":{"freq":{"total":1,"need":1,"via":1,"store":2,"singl":1,"tag":3,"copi":2,"specifi":1,"buffer":13,"given":1,"refer":1,"oper":4,"encrypt":6,"smallto":1,"request":3,"verifi":1,"reset":3,"append":1,"except":12,"thrown":2,"multipl":2,"calcul":1,"hold":2,"init":2,"number":1,"avail":1,"bad":2,"provid":1,"size":4,"finish":2,"input":14,"appli":1,"updat":1,"start":1,"determin":1,"match":1,"unprocess":1,"output":11,"small":1,"array":1,"upon":1,"result":5,"call":3,"link":1,"state":3,"data":7,"block":3,"use":3,"bigth":1,"object":3,"repeat":1,"algorithm":1,"mode":5,"authent":2,"inclus":1,"decrypt":7,"inputstart":1,"length":2,"mean":1,"valu":1,"initi":3,"offset":3,"note":2,"safe":1,"pad":5,"may":2,"previous":2,"depend":2,"larger":1,"receiv":1,"len":2,"illeg":2,"overwritten":1,"unabl":1,"process":3,"appropri":1,"wrong":1,"cipher":9,"method":2,"part":2,"first":1,"bound":1},"maxFreq":14,"totalTerms":211},"loc":13}