{"id":28489,"className":"javax.crypto.Cipher","methodName":"doFinal","signature":"\u003cjavax.crypto.Cipher: int doFinal(byte[],int)\u003e","javadoc":"/** \n * Finishes a multiple-part encryption or decryption operation, depending on how this cipher was initialized. \u003cp\u003eInput data that may have been buffered during a previous \u003ccode\u003eupdate\u003c/code\u003e operation is processed, with padding (if requested) being applied. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in the \u003ccode\u003eoutput\u003c/code\u003e buffer, starting at \u003ccode\u003eoutputOffset\u003c/code\u003e inclusive. \u003cp\u003eIf the \u003ccode\u003eoutput\u003c/code\u003e buffer is too small to hold the result, a \u003ccode\u003eShortBufferException\u003c/code\u003e is thrown. In this case, repeat this call with a larger output buffer. Use {@link #getOutputSize(int) getOutputSize} to determine how bigthe output buffer should be. \u003cp\u003eUpon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to \u003ccode\u003einit\u003c/code\u003e. That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to \u003ccode\u003einit\u003c/code\u003e) more data. \u003cp\u003eNote: if any exception is thrown, this cipher object may need to be reset before it can be used again.\n * @param output the buffer for the result\n * @param outputOffset the offset in \u003ccode\u003eoutput\u003c/code\u003e where the resultis stored\n * @return the number of bytes stored in \u003ccode\u003eoutput\u003c/code\u003e\n * @exception IllegalStateException if this cipher is in a wrong state(e.g., has not been initialized)\n * @exception IllegalBlockSizeException if this cipher is a block cipher,no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided.\n * @exception ShortBufferException if the given output buffer is too smallto hold the result\n * @exception BadPaddingException if this cipher is in decryption mode,and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes\n * @exception AEADBadTagException if this cipher is decrypting in anAEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value\n */\n","tf":{"freq":{"total":1,"need":1,"via":1,"store":3,"tag":3,"resulti":1,"specifi":1,"buffer":9,"given":1,"oper":3,"encrypt":5,"smallto":1,"request":3,"verifi":1,"reset":3,"append":1,"except":12,"thrown":2,"multipl":2,"calcul":1,"hold":2,"init":2,"number":1,"avail":1,"bad":2,"provid":1,"size":4,"finish":2,"appli":1,"input":3,"updat":1,"start":1,"determin":1,"match":1,"output":12,"small":1,"upon":1,"result":4,"call":3,"link":1,"data":5,"state":3,"block":3,"use":3,"bigth":1,"repeat":1,"object":3,"algorithm":1,"mode":5,"authent":2,"inclus":1,"decrypt":6,"length":1,"valu":1,"initi":3,"offset":3,"note":1,"pad":5,"may":2,"previous":2,"depend":2,"larger":1,"receiv":1,"illeg":2,"unabl":1,"process":3,"appropri":1,"wrong":1,"cipher":9,"method":1,"part":1,"bound":1},"maxFreq":12,"totalTerms":176},"loc":11}