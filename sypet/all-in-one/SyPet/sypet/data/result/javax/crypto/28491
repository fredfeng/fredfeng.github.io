{"id":28491,"className":"javax.crypto.Cipher","methodName":"doFinal","signature":"\u003cjavax.crypto.Cipher: byte[] doFinal(byte[],int,int)\u003e","javadoc":"/** \n * Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized. \u003cp\u003eThe first \u003ccode\u003einputLen\u003c/code\u003e bytes in the \u003ccode\u003einput\u003c/code\u003e buffer, starting at \u003ccode\u003einputOffset\u003c/code\u003e inclusive, and any input bytes that may have been buffered during a previous \u003ccode\u003eupdate\u003c/code\u003e operation, are processed, with padding (if requested) being applied. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in a new buffer. \u003cp\u003eUpon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to \u003ccode\u003einit\u003c/code\u003e. That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to \u003ccode\u003einit\u003c/code\u003e) more data. \u003cp\u003eNote: if any exception is thrown, this cipher object may need to be reset before it can be used again.\n * @param input the input buffer\n * @param inputOffset the offset in \u003ccode\u003einput\u003c/code\u003e where the inputstarts\n * @param inputLen the input length\n * @return the new buffer with the result\n * @exception IllegalStateException if this cipher is in a wrong state(e.g., has not been initialized)\n * @exception IllegalBlockSizeException if this cipher is a block cipher,no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided.\n * @exception BadPaddingException if this cipher is in decryption mode,and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes\n * @exception AEADBadTagException if this cipher is decrypting in anAEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value\n */\n","tf":{"freq":{"total":1,"need":1,"via":1,"store":1,"singl":1,"tag":3,"specifi":1,"buffer":5,"oper":4,"encrypt":6,"request":3,"verifi":1,"reset":3,"append":1,"except":9,"thrown":1,"multipl":2,"calcul":1,"init":2,"avail":1,"bad":2,"provid":1,"size":2,"finish":2,"input":12,"appli":1,"updat":1,"start":1,"match":1,"upon":1,"result":2,"call":2,"data":6,"state":3,"block":3,"use":2,"object":3,"algorithm":1,"mode":5,"authent":2,"inclus":1,"decrypt":7,"inputstart":1,"length":2,"valu":1,"initi":3,"offset":3,"note":1,"pad":5,"may":2,"previous":2,"depend":2,"receiv":1,"len":2,"illeg":2,"unabl":1,"process":3,"appropri":1,"wrong":1,"cipher":9,"method":1,"part":2,"first":1,"bound":1},"maxFreq":12,"totalTerms":156},"loc":12}