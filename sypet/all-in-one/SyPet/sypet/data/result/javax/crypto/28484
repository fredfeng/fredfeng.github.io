{"id":28484,"className":"javax.crypto.Cipher","methodName":"update","signature":"\u003cjavax.crypto.Cipher: byte[] update(byte[],int,int)\u003e","javadoc":"/** \n * Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part. \u003cp\u003eThe first \u003ccode\u003einputLen\u003c/code\u003e bytes in the \u003ccode\u003einput\u003c/code\u003e buffer, starting at \u003ccode\u003einputOffset\u003c/code\u003e inclusive, are processed, and the result is stored in a new buffer. \u003cp\u003eIf \u003ccode\u003einputLen\u003c/code\u003e is zero, this method returns \u003ccode\u003enull\u003c/code\u003e.\n * @param input the input buffer\n * @param inputOffset the offset in \u003ccode\u003einput\u003c/code\u003e where the inputstarts\n * @param inputLen the input length\n * @return the new buffer with the result, or null if the underlyingcipher is a block cipher and the input data is too short to result in a new block.\n * @exception IllegalStateException if this cipher is in a wrong state(e.g., has not been initialized)\n */\n","tf":{"freq":{"result":3,"store":1,"state":2,"data":2,"block":2,"anoth":1,"zero":1,"buffer":4,"inclus":1,"decrypt":1,"oper":1,"inputstart":1,"encrypt":1,"length":1,"initi":2,"offset":3,"except":2,"underlyingciph":1,"multipl":1,"depend":1,"len":3,"illeg":1,"continu":1,"process":2,"input":11,"updat":1,"start":1,"wrong":1,"cipher":3,"method":1,"part":2,"first":1},"maxFreq":11,"totalTerms":60},"loc":15}