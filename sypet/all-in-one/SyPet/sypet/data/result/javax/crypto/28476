{"id":28476,"className":"javax.crypto.Cipher","methodName":"init","signature":"\u003cjavax.crypto.Cipher: void init(int,java.security.Key,java.security.SecureRandom)\u003e","javadoc":"/** \n * Initializes this cipher with a key and a source of randomness. \u003cp\u003eThe cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or  key unwrapping, depending on the value of \u003ccode\u003eopmode\u003c/code\u003e. \u003cp\u003eIf this cipher requires any algorithm parameters that cannot be derived from the given \u003ccode\u003ekey\u003c/code\u003e, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an \u003ccode\u003eInvalidKeyException\u003c/code\u003e if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using {@link #getParameters() getParameters} or{@link #getIV() getIV} (if the parameter is an IV).\u003cp\u003eIf this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. \u003cp\u003eIf this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them from \u003ccode\u003erandom\u003c/code\u003e. \u003cp\u003eNote that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it.\n * @param opmode the operation mode of this cipher (this is one of thefollowing: \u003ccode\u003eENCRYPT_MODE\u003c/code\u003e, \u003ccode\u003eDECRYPT_MODE\u003c/code\u003e, \u003ccode\u003eWRAP_MODE\u003c/code\u003e or \u003ccode\u003eUNWRAP_MODE\u003c/code\u003e)\n * @param key the encryption key\n * @param random the source of randomness\n * @exception InvalidKeyException if the given key is inappropriate forinitializing this cipher, or requires algorithm parameters that cannot be determined from the given key, or if the given key has a keysize that exceeds the maximum allowable keysize (as determined from the configured jurisdiction policy files).\n */\n","tf":{"freq":{"acquir":1,"unwrap":2,"deriv":2,"reason":1,"keysiz":2,"feedback":1,"requir":5,"given":4,"invalid":2,"fail":1,"scheme":1,"equival":1,"oper":2,"file":1,"encrypt":3,"key":13,"follow":1,"wrap":2,"except":3,"creat":1,"random":6,"init":1,"polici":1,"provid":2,"instanc":1,"configur":1,"input":1,"maximum":1,"determin":2,"will":2,"sourc":2,"word":1,"allow":1,"inappropri":1,"one":2,"link":2,"state":1,"use":2,"thefollow":1,"object":1,"mode":1,"algorithm":3,"jurisdict":1,"decrypt":2,"rais":1,"valu":3,"initi":8,"four":1,"note":1,"pad":1,"includ":1,"previous":1,"depend":1,"exceed":1,"paramet":10,"suppos":1,"opmod":2,"lose":1,"specif":2,"retriev":1,"generat":3,"foriniti":1,"cipher":11,"necessarili":1},"maxFreq":13,"totalTerms":140},"loc":19}