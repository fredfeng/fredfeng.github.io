{"id":28418,"className":"javax.crypto.KeyAgreement","methodName":"generateSecret","signature":"\u003cjavax.crypto.KeyAgreement: int generateSecret(byte[],int)\u003e","javadoc":"/** \n * Generates the shared secret, and places it into the buffer \u003ccode\u003esharedSecret\u003c/code\u003e, beginning at \u003ccode\u003eoffset\u003c/code\u003e inclusive. \u003cp\u003eIf the \u003ccode\u003esharedSecret\u003c/code\u003e buffer is too small to hold the result, a \u003ccode\u003eShortBufferException\u003c/code\u003e is thrown. In this case, this call should be repeated with a larger output buffer. \u003cp\u003eThis method resets this \u003ccode\u003eKeyAgreement\u003c/code\u003e object, so that it can be reused for further key agreements. Unless this key agreement is reinitialized with one of the \u003ccode\u003einit\u003c/code\u003e methods, the same private information and algorithm parameters will be used for subsequent key agreements.\n * @param sharedSecret the buffer for the shared secret\n * @param offset the offset in \u003ccode\u003esharedSecret\u003c/code\u003e where theshared secret will be stored\n * @return the number of bytes placed into \u003ccode\u003esharedSecret\u003c/code\u003e\n * @exception IllegalStateException if this key agreement has not beencompleted yet\n * @exception ShortBufferException if the given output buffer is too smallto hold the secret\n */\n","tf":{"freq":{"result":1,"call":1,"store":1,"one":1,"state":1,"use":1,"repeat":1,"object":1,"reus":1,"algorithm":1,"buffer":7,"inclus":1,"share":7,"given":1,"unless":1,"theshar":1,"smallto":1,"reset":1,"subsequ":1,"offset":3,"place":2,"key":5,"except":5,"thrown":1,"beencomplet":1,"hold":2,"larger":1,"paramet":1,"agreement":5,"init":1,"number":1,"reiniti":1,"illeg":1,"begin":1,"inform":1,"generat":2,"will":2,"secret":10,"method":2,"output":2,"small":1,"yet":1},"maxFreq":10,"totalTerms":83},"loc":4}