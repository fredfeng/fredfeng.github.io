{"id":25329,"className":"javax.imageio.stream.ImageInputStream","methodName":"setByteOrder","signature":"\u003cjavax.imageio.stream.ImageInputStream: void setByteOrder(java.nio.ByteOrder)\u003e","javadoc":"/** \n * Sets the desired byte order for future reads of data values from this stream.  For example, the sequence of bytes \u00270x01 0x02 0x03 0x04\u0027 if read as a 4-byte integer would have the value \u00270x01020304\u0027 using network byte order and the value \u00270x04030201\u0027 under the reverse byte order. \u003cp\u003e The enumeration class \u003ccode\u003ejava.nio.ByteOrder\u003c/code\u003e is used to specify the byte order.  A value of \u003ccode\u003eByteOrder.BIG_ENDIAN\u003c/code\u003e specifies so-called big-endian or network byte order, in which the high-order byte comes first.  Motorola and Sparc processors store data in this format, while Intel processors store data in the reverse \u003ccode\u003eByteOrder.LITTLE_ENDIAN\u003c/code\u003e order. \u003cp\u003e The byte order has no effect on the results returned from the \u003ccode\u003ereadBits\u003c/code\u003e method (or the value written by \u003ccode\u003eImageOutputStream.writeBits\u003c/code\u003e).\n * @param byteOrder one of \u003ccode\u003eByteOrder.BIG_ENDIAN\u003c/code\u003e or\u003ccode\u003ejava.nio.ByteOrder.LITTLE_ENDIAN\u003c/code\u003e, indicating whether network byte order or its reverse will be used for future reads.\n * @see java.nio.ByteOrder\n * @see #getByteOrder\n * @see #readBits(int)\n */\n","tf":{"freq":{"result":1,"call":1,"stream":2,"store":2,"one":1,"data":3,"motorola":1,"use":3,"desir":1,"whether":1,"network":3,"specifi":2,"revers":3,"indic":1,"order":18,"sequenc":1,"written":1,"write":1,"read":5,"valu":5,"processor":2,"futur":2,"sparc":1,"come":1,"format":1,"imag":1,"bit":3,"effect":1,"endian":1,"will":1,"exampl":1,"method":1,"intel":1,"java":3,"nio":3,"high":1,"output":1,"big":1,"integ":1,"first":1},"maxFreq":18,"totalTerms":84},"loc":0}