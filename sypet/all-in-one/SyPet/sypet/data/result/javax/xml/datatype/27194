{"id":27194,"className":"javax.xml.datatype.XMLGregorianCalendar","methodName":"toGregorianCalendar","signature":"\u003cjavax.xml.datatype.XMLGregorianCalendar: java.util.GregorianCalendar toGregorianCalendar()\u003e","javadoc":"/** \n * \u003cp\u003eConvert this \u003ccode\u003eXMLGregorianCalendar\u003c/code\u003e to a  {@link GregorianCalendar}.\u003c/p\u003e \u003cp\u003eWhen \u003ccode\u003ethis\u003c/code\u003e instance has an undefined field, this conversion relies on the \u003ccode\u003ejava.util.GregorianCalendar\u003c/code\u003e default for its corresponding field. A notable difference between XML Schema 1.0 date/time datatypes and \u003ccode\u003ejava.util.GregorianCalendar\u003c/code\u003e is that Timezone value is optional for date/time datatypes and it is a required field for \u003ccode\u003ejava.util.GregorianCalendar\u003c/code\u003e. See javadoc for \u003ccode\u003ejava.util.TimeZone.getDefault()\u003c/code\u003e on how the default is determined. To explicitly specify the \u003ccode\u003eTimeZone\u003c/code\u003e instance, see {@link #toGregorianCalendar(TimeZone,Locale,XMLGregorianCalendar)}.\u003c/p\u003e \u003ctable border\u003d\"2\" rules\u003d\"all\" cellpadding\u003d\"2\"\u003e \u003cthead\u003e \u003ctr\u003e \u003cth align\u003d\"center\" colspan\u003d\"2\"\u003e Field by Field Conversion from this class to \u003ccode\u003ejava.util.GregorianCalendar\u003c/code\u003e \u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003e\u003ccode\u003ejava.util.GregorianCalendar\u003c/code\u003e field\u003c/td\u003e \u003ctd\u003e\u003ccode\u003ejavax.xml.datatype.XMLGregorianCalendar\u003c/code\u003e field\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e\u003ccode\u003eERA\u003c/code\u003e\u003c/td\u003e \u003ctd\u003e {@link #getEonAndYear()}\u003ccode\u003e.signum() \u003c 0 ? GregorianCalendar.BC : GregorianCalendar.AD\u003c/code\u003e\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e\u003ccode\u003eYEAR\u003c/code\u003e\u003c/td\u003e \u003ctd\u003e {@link #getEonAndYear()}\u003ccode\u003e.abs().intValue()\u003c/code\u003e\u003ci\u003e*\u003c/i\u003e\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e\u003ccode\u003eMONTH\u003c/code\u003e\u003c/td\u003e \u003ctd\u003e {@link #getMonth()} - {@link DatatypeConstants#JANUARY} + {@link GregorianCalendar#JANUARY}\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e\u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e\u003c/td\u003e \u003ctd\u003e {@link #getDay()}\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e\u003ccode\u003eHOUR_OF_DAY\u003c/code\u003e\u003c/td\u003e \u003ctd\u003e {@link #getHour()}\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e\u003ccode\u003eMINUTE\u003c/code\u003e\u003c/td\u003e \u003ctd\u003e {@link #getMinute()}\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e\u003ccode\u003eSECOND\u003c/code\u003e\u003c/td\u003e \u003ctd\u003e {@link #getSecond()}\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e\u003ccode\u003eMILLISECOND\u003c/code\u003e\u003c/td\u003e \u003ctd\u003eget millisecond order from  {@link #getFractionalSecond()}\u003ci\u003e*\u003c/i\u003e \u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e\u003ccode\u003eGregorianCalendar.setTimeZone(TimeZone)\u003c/code\u003e\u003c/td\u003e \u003ctd\u003e {@link #getTimezone()} formatted into Custom timezone id\u003c/td\u003e\u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e \u003ci\u003e*\u003c/i\u003e designates possible loss of precision during the conversion due to source datatype having higher precision than target datatype. \u003cp\u003eTo ensure consistency in conversion implementations, the new \u003ccode\u003eGregorianCalendar\u003c/code\u003e should be instantiated in following manner. \u003cul\u003e \u003cli\u003eUsing \u003ccode\u003etimeZone\u003c/code\u003e value as defined above, create a new \u003ccode\u003ejava.util.GregorianCalendar(timeZone,Locale.getDefault())\u003c/code\u003e. \u003c/li\u003e \u003cli\u003eInitialize all GregorianCalendar fields by calling  {@link java.util.GregorianCalendar#clear()}.\u003c/li\u003e \u003cli\u003eObtain a pure Gregorian Calendar by invoking \u003ccode\u003eGregorianCalendar.setGregorianChange( new Date(Long.MIN_VALUE))\u003c/code\u003e.\u003c/li\u003e \u003cli\u003eIts fields ERA, YEAR, MONTH, DAY_OF_MONTH, HOUR_OF_DAY, MINUTE, SECOND and MILLISECOND are set using the method \u003ccode\u003eCalendar.set(int,int)\u003c/code\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/p\u003e\n * @see #toGregorianCalendar(java.util.TimeZone,java.util.Locale,XMLGregorianCalendar)\n */\n","tf":{"freq":{"second":2,"instanti":1,"higher":1,"notabl":1,"possibl":1,"timezon":3,"javadoc":1,"reli":1,"specifi":1,"schema":1,"center":1,"time":10,"requir":1,"javax":1,"precis":2,"year":2,"undefin":1,"border":1,"option":1,"follow":1,"custom":1,"eon":2,"minut":1,"colspan":1,"creat":1,"consist":1,"invok":1,"align":1,"xml":1,"format":1,"instanc":2,"pure":1,"obtain":1,"signum":1,"cellpad":1,"explicit":1,"determin":1,"month":1,"due":1,"sourc":1,"day":1,"util":10,"call":1,"defin":1,"loss":1,"correspond":1,"link":14,"convers":4,"use":2,"convert":1,"date":3,"ensur":1,"clear":1,"order":1,"millisecond":1,"rule":1,"valu":3,"initi":1,"datatyp":6,"calendar":24,"thead":2,"fraction":1,"constant":1,"tbodi":2,"hour":1,"field":9,"differ":1,"tabl":2,"target":1,"lgregorian":4,"method":1,"manner":1,"java":10,"chang":1,"local":3,"ab":1,"gregorian":20,"design":1,"zone":8},"maxFreq":24,"totalTerms":204},"loc":0}