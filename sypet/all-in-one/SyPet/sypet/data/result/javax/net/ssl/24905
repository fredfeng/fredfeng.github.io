{"id":24905,"className":"javax.net.ssl.SSLEngine","methodName":"wrap","signature":"\u003cjavax.net.ssl.SSLEngine: javax.net.ssl.SSLEngineResult wrap(java.nio.ByteBuffer[],int,int,java.nio.ByteBuffer)\u003e","javadoc":"/** \n * Attempts to encode plaintext bytes from a subsequence of data buffers into SSL/TLS network data.  This \u003ci\u003e\"gathering\"\u003c/i\u003e operation encodes, in a single invocation, a sequence of bytes from one or more of a given sequence of buffers.  Gathering wraps are often useful when implementing network protocols or file formats that, for example, group data into segments consisting of one or more fixed-length headers followed by a variable-length body.  See {@link java.nio.channels.GatheringByteChannel} for moreinformation on gathering, and  {@link java.nio.channels.GatheringByteChannel#write(ByteBuffer[],int,int)} for more information on the subsequencebehavior. \u003cP\u003e Depending on the state of the SSLEngine, this method may produce network data without consuming any application data (for example, it may generate handshake data.) \u003cP\u003e The application is responsible for reliably transporting the network data to the peer, and for ensuring that data created by multiple calls to wrap() is transported in the same order in which it was generated.  The application must properly synchronize multiple calls to this method. \u003cP\u003e If this \u003ccode\u003eSSLEngine\u003c/code\u003e has not yet started its initial handshake, this method will automatically start the handshake. \u003cP\u003e This method will attempt to produce one SSL/TLS packet, and will consume as much source data as possible, but will never consume more than the sum of the bytes remaining in each buffer.  Each \u003ccode\u003eByteBuffer\u003c/code\u003e\u0027s position is updated to reflect the amount of data consumed or produced.  The limits remain the same. \u003cP\u003e The underlying memory used by the \u003ccode\u003esrcs\u003c/code\u003e and \u003ccode\u003edst ByteBuffer\u003c/code\u003es must not be the same. \u003cP\u003e See the class description for more information on engine closure.\n * @param srcs an array of \u003ccode\u003eByteBuffers\u003c/code\u003e containing the outbound application data\n * @param offset The offset within the buffer array of the first buffer from which bytes are to be retrieved; it must be non-negative and no larger than \u003ccode\u003esrcs.length\u003c/code\u003e\n * @param length The maximum number of buffers to be accessed; it must be non-negative and no larger than \u003ccode\u003esrcs.length\u003c/code\u003e\u0026nbsp;-\u0026nbsp;\u003ccode\u003eoffset\u003c/code\u003e\n * @param dst a \u003ccode\u003eByteBuffer\u003c/code\u003e to hold outbound network data\n * @return  an \u003ccode\u003eSSLEngineResult\u003c/code\u003e describing the resultof this operation.\n * @throws SSLException A problem was encountered while processing the data that caused the \u003ccode\u003eSSLEngine\u003c/code\u003e to abort. See the class description for more information on engine closure.\n * @throws IndexOutOfBoundsException if the preconditions on the \u003ccode\u003eoffset\u003c/code\u003e and \u003ccode\u003elength\u003c/code\u003e parameters do not hold.\n * @throws ReadOnlyBufferException if the \u003ccode\u003edst\u003c/code\u003e buffer is read-only.\n * @throws IllegalArgumentException if either \u003ccode\u003esrcs\u003c/code\u003e or \u003ccode\u003edst\u003c/code\u003e is null, or if any element in the \u003ccode\u003esrcs\u003c/code\u003e subsequence specified is null.\n * @throws IllegalStateException if the client/server modehas not yet been set.\n * @see java.nio.channels.GatheringByteChannel\n * @see java.nio.channels.GatheringByteChannel#write(ByteBuffer[],int,int)\n */\n","tf":{"freq":{"memori":1,"singl":1,"variabl":1,"precondit":1,"lexcept":1,"specifi":1,"handshak":3,"resultof":1,"given":1,"oper":2,"sequenc":2,"file":1,"lengin":4,"nbsp":2,"limit":1,"element":1,"respons":1,"multipl":2,"hold":2,"describ":1,"number":1,"without":1,"header":1,"invoc":1,"non":2,"encod":2,"start":2,"will":4,"sourc":1,"packet":1,"posit":1,"array":2,"link":2,"data":13,"engin":2,"use":2,"applic":4,"ensur":1,"transport":2,"write":2,"length":6,"initi":1,"may":2,"larger":2,"moreinform":1,"access":1,"srcs":6,"process":1,"either":1,"remain":2,"encount":1,"retriev":1,"exampl":2,"closur":2,"method":4,"within":1,"bound":1,"reflect":1,"abort":1,"yet":2,"client":1,"segment":1,"possibl":1,"dst":4,"must":4,"buffer":14,"amount":1,"subsequencebehavior":1,"gather":7,"proper":1,"follow":1,"argument":1,"wrap":3,"except":4,"index":1,"consist":1,"creat":1,"descript":2,"format":1,"much":1,"inform":3,"bodi":1,"updat":1,"often":1,"reliabl":1,"maximum":1,"contain":1,"modeha":1,"negat":2,"attempt":2,"result":1,"call":2,"one":3,"state":2,"sum":1,"automat":1,"network":5,"consum":4,"order":1,"fix":1,"read":2,"outbound":2,"subsequ":2,"offset":4,"peer":1,"protocol":1,"plaintext":1,"depend":1,"paramet":1,"problem":1,"produc":3,"illeg":2,"never":1,"caus":1,"generat":2,"server":1,"nio":4,"java":4,"group":1,"channel":8,"first":1},"maxFreq":14,"totalTerms":246},"loc":0}