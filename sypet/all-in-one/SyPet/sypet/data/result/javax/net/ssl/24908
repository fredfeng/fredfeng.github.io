{"id":24908,"className":"javax.net.ssl.SSLEngine","methodName":"unwrap","signature":"\u003cjavax.net.ssl.SSLEngine: javax.net.ssl.SSLEngineResult unwrap(java.nio.ByteBuffer,java.nio.ByteBuffer[],int,int)\u003e","javadoc":"/** \n * Attempts to decode SSL/TLS network data into a subsequence of plaintext application data buffers.  This \u003ci\u003e\"scattering\"\u003c/i\u003e operation decodes, in a single invocation, a sequence of bytes into one or more of a given sequence of buffers.  Scattering unwraps are often useful when implementing network protocols or file formats that, for example, group data into segments consisting of one or more fixed-length headers followed by a variable-length body.  See {@link java.nio.channels.ScatteringByteChannel} for moreinformation on scattering, and  {@link java.nio.channels.ScatteringByteChannel#read(ByteBuffer[],int,int)} for more information on the subsequencebehavior. \u003cP\u003e Depending on the state of the SSLEngine, this method may consume network data without producing any application data (for example, it may consume handshake data.) \u003cP\u003e The application is responsible for reliably obtaining the network data from the peer, and for invoking unwrap() on the data in the order it was received.  The application must properly synchronize multiple calls to this method. \u003cP\u003e If this \u003ccode\u003eSSLEngine\u003c/code\u003e has not yet started its initial handshake, this method will automatically start the handshake. \u003cP\u003e This method will attempt to consume one complete SSL/TLS network packet, but will never consume more than the sum of the bytes remaining in the buffers.  Each \u003ccode\u003eByteBuffer\u003c/code\u003e\u0027s position is updated to reflect the amount of data consumed or produced.  The limits remain the same. \u003cP\u003e The underlying memory used by the \u003ccode\u003esrc\u003c/code\u003e and \u003ccode\u003edsts ByteBuffer\u003c/code\u003es must not be the same. \u003cP\u003e The inbound network buffer may be modified as a result of this call:  therefore if the network data packet is required for some secondary purpose, the data should be duplicated before calling this method.  Note:  the network data will not be useful to a second SSLEngine, as each SSLEngine contains unique random state which influences the SSL/TLS messages. \u003cP\u003e See the class description for more information on engine closure.\n * @param src a \u003ccode\u003eByteBuffer\u003c/code\u003e containing inbound network data.\n * @param dsts an array of \u003ccode\u003eByteBuffer\u003c/code\u003es to hold inbound application data.\n * @param offset The offset within the buffer array of the first buffer from which bytes are to be transferred; it must be non-negative and no larger than \u003ccode\u003edsts.length\u003c/code\u003e.\n * @param length The maximum number of buffers to be accessed; it must be non-negative and no larger than \u003ccode\u003edsts.length\u003c/code\u003e\u0026nbsp;-\u0026nbsp;\u003ccode\u003eoffset\u003c/code\u003e.\n * @return  an \u003ccode\u003eSSLEngineResult\u003c/code\u003e describing the resultof this operation.\n * @throws SSLException A problem was encountered while processing the data that caused the \u003ccode\u003eSSLEngine\u003c/code\u003e to abort. See the class description for more information on engine closure.\n * @throws IndexOutOfBoundsException If the preconditions on the \u003ccode\u003eoffset\u003c/code\u003e and \u003ccode\u003elength\u003c/code\u003e parameters do not hold.\n * @throws ReadOnlyBufferException if any of the \u003ccode\u003edst\u003c/code\u003e buffers are read-only.\n * @throws IllegalArgumentException if either \u003ccode\u003esrc\u003c/code\u003e or \u003ccode\u003edsts\u003c/code\u003e is null, or if any element in the \u003ccode\u003edsts\u003c/code\u003e subsequence specified is null.\n * @throws IllegalStateException if the client/server modehas not yet been set.\n * @see java.nio.channels.ScatteringByteChannel\n * @see java.nio.channels.ScatteringByteChannel#read(ByteBuffer[],int,int)\n */\n","tf":{"freq":{"memori":1,"singl":1,"variabl":1,"precondit":1,"lexcept":1,"specifi":1,"handshak":3,"resultof":1,"given":1,"oper":2,"sequenc":2,"file":1,"lengin":6,"purpos":1,"nbsp":2,"limit":1,"element":1,"transfer":1,"respons":1,"multipl":1,"invok":1,"hold":2,"random":1,"describ":1,"number":1,"without":1,"header":1,"invoc":1,"non":2,"obtain":1,"start":2,"will":4,"duplic":1,"packet":2,"posit":1,"array":2,"link":2,"data":15,"engin":2,"use":3,"therefor":1,"applic":5,"length":6,"secondari":1,"initi":1,"src":3,"note":1,"complet":1,"may":3,"messag":1,"larger":2,"receiv":1,"moreinform":1,"access":1,"process":1,"scatter":7,"either":1,"remain":2,"encount":1,"exampl":2,"closur":2,"influenc":1,"method":5,"within":1,"bound":1,"reflect":1,"abort":1,"yet":2,"client":1,"unwrap":3,"second":1,"segment":1,"dst":1,"must":4,"buffer":15,"amount":1,"uniqu":1,"requir":1,"subsequencebehavior":1,"proper":1,"follow":1,"argument":1,"decod":2,"except":4,"index":1,"consist":1,"descript":2,"format":1,"inform":3,"bodi":1,"updat":1,"maximum":1,"often":1,"reliabl":1,"contain":2,"modeha":1,"negat":2,"inbound":3,"attempt":2,"call":3,"result":2,"one":3,"dsts":6,"state":3,"sum":1,"automat":1,"network":9,"consum":5,"order":1,"fix":1,"read":4,"offset":4,"subsequ":2,"peer":1,"protocol":1,"plaintext":1,"depend":1,"paramet":1,"problem":1,"produc":2,"illeg":2,"never":1,"caus":1,"modifi":1,"server":1,"nio":4,"java":4,"group":1,"first":1,"channel":8},"maxFreq":15,"totalTerms":271},"loc":0}