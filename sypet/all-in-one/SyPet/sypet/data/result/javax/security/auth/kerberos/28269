{"id":28269,"className":"javax.security.auth.kerberos.KeyTab","methodName":"getKeys","signature":"\u003cjavax.security.auth.kerberos.KeyTab: javax.security.auth.kerberos.KerberosKey[] getKeys(javax.security.auth.kerberos.KerberosPrincipal)\u003e","javadoc":"/** \n * Returns fresh keys for the given Kerberos principal. \u003cp\u003e Implementation of this method should make sure the returned keys match the latest content of the keytab file. The result is a newly created copy that can be modified by the caller without modifying the keytab object. The caller should  {@link KerberosKey#destroy() destroy} theresult keys after they are used. \u003cp\u003e Please note that the keytab file can be created after the {@code KeyTab} object is instantiated and its content may change overtime. Therefore, an application should call this method only when it needs to use the keys. Any previous result from an earlier invocation could potentially be expired. \u003cp\u003e If there is any error (say, I/O error or format error) during the reading process of the KeyTab file, a saved result should be returned. If there is no saved result (say, this is the first time this method is called, or, all previous read attempts failed), an empty array should be returned. This can make sure the result is not drastically changed during the (probably slow) update of the keytab file. \u003cp\u003e Each time this method is called and the reading of the file succeeds with no exception (say, I/O error or file format error), the result should be saved for  {@code principal}. The implementation can also save keys for other principals having keys in the same keytab object if convenient. \u003cp\u003e Any unsupported key read from the keytab is ignored and not included in the result.\n * @param principal the Kerberos principal, must not be null.\n * @return the keys (never null, may be empty)\n * @throws NullPointerException if the {@code principal}argument is null\n * @throws SecurityException if a security manager exists and the readaccess to the keytab file is not permitted\n */\n","tf":{"freq":{"need":1,"unsupport":1,"save":4,"instanti":1,"permit":1,"readaccess":1,"tab":2,"must":1,"copi":1,"expir":1,"time":2,"probabl":1,"fail":1,"given":1,"file":7,"slow":1,"overtim":1,"key":12,"sure":2,"argument":1,"ignor":1,"except":3,"succeed":1,"creat":2,"keytab":7,"theresult":1,"format":2,"without":1,"invoc":1,"content":2,"newli":1,"earlier":1,"updat":1,"say":3,"pointer":1,"match":1,"drastic":1,"make":2,"array":1,"princip":6,"attempt":1,"caller":2,"result":7,"call":3,"link":1,"use":2,"kerbero":3,"object":3,"therefor":1,"applic":1,"destroy":2,"pleas":1,"fresh":1,"read":4,"exist":1,"conveni":1,"note":1,"may":2,"includ":1,"previous":2,"error":5,"manag":1,"potenti":1,"empti":2,"process":1,"never":1,"secur":2,"modifi":2,"method":4,"chang":2,"latest":1,"also":1,"first":1},"maxFreq":12,"totalTerms":146},"loc":19}