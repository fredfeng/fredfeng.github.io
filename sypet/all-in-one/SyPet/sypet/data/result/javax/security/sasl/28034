{"id":28034,"className":"javax.security.sasl.SaslServer","methodName":"wrap","signature":"\u003cjavax.security.sasl.SaslServer: byte[] wrap(byte[],int,int)\u003e","javadoc":"/** \n * Wraps a byte array to be sent to the client. This method can be called only after the authentication exchange has completed (i.e., when \u003ctt\u003eisComplete()\u003c/tt\u003e returns true) and only if the authentication exchange has negotiated integrity and/or privacy as the quality of protection; otherwise, a \u003ctt\u003eSaslException\u003c/tt\u003e is thrown. \u003cp\u003e The result of this method will make up the contents of the SASL buffer as defined in RFC 2222 without the leading four octet field that represents the length. \u003ctt\u003eoffset\u003c/tt\u003e and \u003ctt\u003elen\u003c/tt\u003e specify the portion of \u003ctt\u003eoutgoing\u003c/tt\u003e to use.\n * @param outgoing A non-null byte array containing the bytes to encode.\n * @param offset The starting position at \u003ctt\u003eoutgoing\u003c/tt\u003e of the bytes to use.\n * @param len The number of bytes from \u003ctt\u003eoutgoing\u003c/tt\u003e to use.\n * @return A non-null byte array containing the encoded bytes.\n * @exception SaslException if \u003ctt\u003eoutgoing\u003c/tt\u003e cannot be successfullywrapped.\n * @exception IllegalStateException if the authentication exchange hasnot completed, or if the negotiated quality of protection has neither integrity nor privacy.\n */\n","tf":{"freq":{"otherwis":1,"call":1,"result":1,"defin":1,"integr":2,"negoti":2,"client":1,"state":1,"use":3,"lead":1,"specifi":1,"authent":3,"buffer":1,"sent":1,"privaci":2,"length":1,"four":1,"sasl":2,"offset":2,"portion":1,"complet":3,"successfullywrap":1,"wrap":2,"except":5,"thrown":1,"repres":1,"true":1,"qualiti":2,"number":1,"len":2,"hasnot":1,"illeg":1,"without":1,"exchang":3,"non":2,"neither":1,"field":1,"content":1,"encod":2,"outgo":5,"start":1,"contain":2,"will":1,"method":2,"posit":1,"make":1,"octet":1,"array":3},"maxFreq":5,"totalTerms":78},"loc":0}