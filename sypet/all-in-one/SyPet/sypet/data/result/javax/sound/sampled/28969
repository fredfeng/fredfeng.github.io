{"id":28969,"className":"javax.sound.sampled.SourceDataLine","methodName":"write","signature":"\u003cjavax.sound.sampled.SourceDataLine: int write(byte[],int,int)\u003e","javadoc":"/** \n * Writes audio data to the mixer via this source data line.  The requested number of bytes of data are read from the specified array, starting at the given offset into the array, and written to the data line\u0027s buffer.  If the caller attempts to write more data than can currently be written (see \u003ccode\u003e {@link DataLine#available available}\u003c/code\u003e), this method blocks until the requested amount of data has been written. This applies even if the requested amount of data to write is greater than the data line\u0027s buffer size.  However, if the data line is closed, stopped, or flushed before the requested amount has been written, the method no longer blocks, but returns the number of bytes written thus far. \u003cp\u003e The number of bytes that can be written without blocking can be ascertained using the \u003ccode\u003e {@link DataLine#available available}\u003c/code\u003e method of the \u003ccode\u003eDataLine\u003c/code\u003e interface.  (While it is guaranteed that this number of bytes can be written without blocking, there is no guarantee that attempts to write additional data will block.) \u003cp\u003e The number of bytes to write must represent an integral number of sample frames, such that: \u003cbr\u003e \u003ccenter\u003e\u003ccode\u003e[ bytes written ] % [frame size in bytes ] \u003d\u003d 0\u003c/code\u003e\u003c/center\u003e \u003cbr\u003e The return value will always meet this requirement.  A request to write a number of bytes representing a non-integral number of sample frames cannot be fulfilled and may result in an \u003ccode\u003eIllegalArgumentException\u003c/code\u003e.\n * @param b a byte array containing data to be written to the data line\n * @param len the length, in bytes, of the valid data in the array(in other words, the requested amount of data to write, in bytes)\n * @param off the offset from the beginning of the array, in bytes\n * @return the number of bytes actually written\n * @throws IllegalArgumentException if the requested number of bytes doesnot represent an integral number of sample frames, or if \u003ccode\u003elen\u003c/code\u003e is negative\n * @throws ArrayIndexOutOfBoundsException if \u003ccode\u003eoff\u003c/code\u003e is negative,or \u003ccode\u003eoff+len\u003c/code\u003e is greater than the length of the array \u003ccode\u003eb\u003c/code\u003e.\n * @see TargetDataLine#read\n * @see DataLine#available\n */\n","tf":{"freq":{"via":1,"greater":2,"integr":3,"must":1,"specifi":1,"close":1,"buffer":2,"amount":4,"center":2,"requir":1,"given":1,"request":7,"longer":1,"howev":1,"argument":2,"index":1,"except":3,"alway":1,"far":1,"avail":5,"number":11,"ascertain":1,"meet":1,"without":2,"non":1,"size":2,"appli":1,"frame":4,"start":1,"contain":1,"will":2,"negat":2,"word":1,"sourc":1,"even":1,"array":7,"attempt":2,"caller":1,"valid":1,"result":1,"stop":1,"link":2,"data":19,"block":5,"line":10,"use":1,"fulfil":1,"written":10,"length":2,"current":1,"write":8,"read":2,"doesnot":1,"valu":1,"mixer":1,"offset":2,"addit":1,"may":1,"audio":1,"thus":1,"repres":3,"guarante":2,"len":3,"illeg":2,"begin":1,"flush":1,"target":1,"actual":1,"method":3,"bound":1,"sampl":3},"maxFreq":19,"totalTerms":177},"loc":0}