{"id":14562,"className":"javax.swing.SwingWorker","methodName":"get","signature":"\u003cjavax.swing.SwingWorker: T get()\u003e","javadoc":"/** \n * {@inheritDoc}\u003cp\u003e Note: calling  {@code get} on the \u003ci\u003eEvent Dispatch Thread\u003c/i\u003e blocks\u003ci\u003eall\u003c/i\u003e events, including repaints, from being processed until this {@code SwingWorker} is complete.\u003cp\u003e When you want the  {@code SwingWorker} to block on the \u003ci\u003eEventDispatch Thread\u003c/i\u003e we recommend that you use a \u003ci\u003emodal dialog\u003c/i\u003e. \u003cp\u003e For example: \u003cpre\u003e class SwingWorkerCompletionWaiter extends PropertyChangeListener { private JDialog dialog; public SwingWorkerCompletionWaiter(JDialog dialog) { this.dialog \u003d dialog; } public void propertyChange(PropertyChangeEvent event) { if (\u0026quot;state\u0026quot;.equals(event.getPropertyName()) \u0026amp;\u0026amp; SwingWorker.StateValue.DONE \u003d\u003d event.getNewValue()) { dialog.setVisible(false); dialog.dispose(); } } } JDialog dialog \u003d new JDialog(owner, true); swingWorker.addPropertyChangeListener( new SwingWorkerCompletionWaiter(dialog)); swingWorker.execute(); //the dialog will be visible until the SwingWorker is done dialog.setVisible(true); \u003c/pre\u003e\n */\n","tf":{"freq":{"fals":1,"call":1,"visibl":3,"state":2,"block":2,"use":1,"add":1,"recommend":1,"event":7,"name":1,"thread":2,"worker":9,"valu":2,"dispatch":2,"swing":9,"dialog":11,"quot":2,"modal":1,"waiter":3,"listen":2,"jdialog":4,"note":1,"want":1,"complet":4,"includ":1,"done":1,"true":2,"equal":1,"process":1,"pre":2,"will":1,"owner":1,"exampl":1,"dispos":1,"repaint":1,"properti":5,"chang":4,"execut":1,"amp":2},"maxFreq":11,"totalTerms":98},"loc":3}