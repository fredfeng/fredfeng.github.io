{"id":21052,"className":"javax.swing.event.TreeModelEvent","methodName":"TreeModelEvent","signature":"\u003cjavax.swing.event.TreeModelEvent: void TreeModelEvent(java.lang.Object,java.lang.Object[],int[],java.lang.Object[])\u003e","javadoc":"/** \n * Used to create an event when nodes have been changed, inserted, or removed, identifying the path to the parent of the modified items as an array of Objects. All of the modified objects are siblings which are direct descendents (not grandchildren) of the specified parent. The positions at which the inserts, deletes, or changes occurred are specified by an array of \u003ccode\u003eint\u003c/code\u003e. The indexes in that array must be in order, from lowest to highest. \u003cp\u003e For changes, the indexes in the model correspond exactly to the indexes of items currently displayed in the UI. As a result, it is not really critical if the indexes are not in their exact order. But after multiple inserts or deletes, the items currently in the UI no longer correspond to the items in the model. It is therefore critical to specify the indexes properly for inserts and deletes. \u003cp\u003e For inserts, the indexes represent the \u003ci\u003efinal\u003c/i\u003e state of the tree, after the inserts have occurred. Since the indexes must be specified in order, the most natural processing methodology is to do the inserts starting at the lowest index and working towards the highest. Accumulate a Vector of \u003ccode\u003eInteger\u003c/code\u003e objects that specify the insert-locations as you go, then convert the Vector to an array of \u003ccode\u003eint\u003c/code\u003e to create the event. When the postition-index equals zero, the node is inserted at the beginning of the list. When the position index equals the size of the list, the node is \"inserted\" at (appended to) the end of the list. \u003cp\u003e For deletes, the indexes represent the \u003ci\u003einitial\u003c/i\u003e state of the tree, before the deletes have occurred. Since the indexes must be specified in order, the most natural processing methodology is to use a delete-counter. Start by initializing the counter to zero and start work through the list from lowest to higest. Every time you do a delete, add the current value of the delete-counter to the index-position where the delete occurred, and append the result to a Vector of delete-locations, using \u003ccode\u003eaddElement()\u003c/code\u003e. Then increment the delete-counter. The index positions stored in the Vector therefore reflect the effects of all previous deletes, so they represent each object\u0027s position in the initial tree. (You could also start at the highest index and working back towards the lowest, accumulating a Vector of delete-locations as you go using the \u003ccode\u003einsertElementAt(Integer, 0)\u003c/code\u003e.) However you produce the Vector of initial-positions, you then need to convert the Vector of \u003ccode\u003eInteger\u003c/code\u003e objects to an array of \u003ccode\u003eint\u003c/code\u003e to create the event. \u003cp\u003e \u003cb\u003eNotes:\u003c/b\u003e\u003cul\u003e \u003cli\u003eLike the \u003ccode\u003einsertNodeInto\u003c/code\u003e method in the \u003ccode\u003eDefaultTreeModel\u003c/code\u003e class, \u003ccode\u003einsertElementAt\u003c/code\u003e appends to the \u003ccode\u003eVector\u003c/code\u003e when the index matches the size of the vector. So you can use \u003ccode\u003einsertElementAt(Integer, 0)\u003c/code\u003e even when the vector is empty. \u003cul\u003eTo create a node changed event for the root node, specify the parent and the child indices as \u003ccode\u003enull\u003c/code\u003e. \u003c/ul\u003e\n * @param source the Object responsible for generating the event (typicallythe creator of the event object passes \u003ccode\u003ethis\u003c/code\u003e for its value)\n * @param path   an array of Object identifying the path to theparent of the modified item(s), where the first element of the array is the Object stored at the root node and the last element is the Object stored at the parent node\n * @param childIndices an array of \u003ccode\u003eint\u003c/code\u003e that specifies theindex values of the removed items. The indices must be in sorted order, from lowest to highest\n * @param children an array of Object containing the inserted, removed, orchanged objects\n * @see TreePath\n */\n","tf":{"freq":{"need":1,"store":3,"zero":2,"higest":1,"specifi":8,"time":1,"tree":6,"event":7,"element":6,"increment":1,"multipl":1,"respons":1,"sibl":1,"remov":3,"parent":4,"like":1,"start":4,"sourc":1,"posit":6,"critic":2,"array":9,"realli":1,"sort":1,"delet":13,"correspond":2,"use":5,"therefor":2,"indic":3,"methodolog":2,"current":3,"initi":4,"end":1,"note":1,"direct":1,"previous":1,"typicallyth":1,"repres":3,"back":1,"empti":1,"process":2,"item":6,"orchang":1,"method":1,"insert":15,"lowest":5,"reflect":1,"last":1,"root":2,"natur":2,"must":4,"toward":2,"exact":2,"longer":1,"grandchildren":1,"proper":1,"howev":1,"everi":1,"thepar":1,"work":3,"theindex":1,"append":3,"index":16,"creat":4,"display":1,"size":2,"accumul":2,"node":8,"contain":1,"postit":1,"even":1,"match":1,"result":2,"model":4,"highest":4,"state":2,"children":1,"convert":2,"identifi":2,"object":12,"add":2,"creator":1,"child":2,"order":5,"vector":10,"path":4,"valu":3,"locat":3,"counter":4,"equal":2,"list":4,"produc":1,"begin":1,"pass":1,"effect":1,"generat":1,"modifi":3,"chang":4,"descend":1,"integ":4,"also":1,"first":1,"occur":4},"maxFreq":16,"totalTerms":301},"loc":3}