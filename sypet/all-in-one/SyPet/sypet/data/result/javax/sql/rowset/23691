{"id":23691,"className":"javax.sql.rowset.CachedRowSet","methodName":"acceptChanges","signature":"\u003cjavax.sql.rowset.CachedRowSet: void acceptChanges(java.sql.Connection)\u003e","javadoc":"/** \n * Propagates all row update, insert and delete changes to the data source backing this \u003ccode\u003eCachedRowSet\u003c/code\u003e object using the specified \u003ccode\u003eConnection\u003c/code\u003e object to establish a connection to the data source. \u003cP\u003e The other version of the \u003ccode\u003eacceptChanges\u003c/code\u003e method is not passed a connection because it uses the \u003ccode\u003eConnection\u003c/code\u003e object already defined within the \u003ccode\u003eRowSet\u003c/code\u003e object, which is the connection used for populating it initially. \u003cP\u003e This form of the method \u003ccode\u003eacceptChanges\u003c/code\u003e is similar to the form that takes no arguments; however, unlike the other form, this form can be used only when the underlying data source is a JDBC data source. The updated \u003ccode\u003eConnection\u003c/code\u003e properties must be used by the \u003ccode\u003eSyncProvider\u003c/code\u003e to reset the \u003ccode\u003eRowSetWriter\u003c/code\u003e configuration to ensure that the contents of the \u003ccode\u003eCachedRowSet\u003c/code\u003e object are synchronized correctly. \u003cP\u003e When the method \u003ccode\u003eacceptChanges\u003c/code\u003e executes successfully, in addition to writing changes to the data source, it makes the values in the current row be the values in the original row. \u003cP\u003e Depending on the synchronization level of the \u003ccode\u003eSyncProvider\u003c/code\u003e implementation being used, the writer will compare the original values with those in the data source to check for conflicts. When there is a conflict, the \u003ccode\u003eRIOptimisticProvider\u003c/code\u003e implementation, for example, throws a \u003ccode\u003eSyncProviderException\u003c/code\u003e and does not write anything to the data source. \u003cP\u003e An application may choose to catch the \u003ccode\u003eSyncProviderException\u003c/code\u003e object and retrieve the \u003ccode\u003eSyncResolver\u003c/code\u003e object it contains. The \u003ccode\u003eSyncResolver\u003c/code\u003e object lists the conflicts row by row and sets a lock on the data source to avoid further conflicts while the current conflicts are being resolved. Further, for each conflict, it provides methods for examining the conflict and setting the value that should be persisted in the data source. After all conflicts have been resolved, an application must call the \u003ccode\u003eacceptChanges\u003c/code\u003e method again to write resolved values to the data source.  If all of the values in the data source are already the values to be persisted, the method \u003ccode\u003eacceptChanges\u003c/code\u003e does nothing. \u003cP\u003e Some provider implementations may use locks to ensure that there are no conflicts.  In such cases, it is guaranteed that the writer will succeed in writing changes to the data source when the method \u003ccode\u003eacceptChanges\u003c/code\u003e is called.  This method may be called immediately after the methods \u003ccode\u003eupdateRow\u003c/code\u003e, \u003ccode\u003einsertRow\u003c/code\u003e, or \u003ccode\u003edeleteRow\u003c/code\u003e have been called, but it is more efficient to call it only once after all changes have been made so that only one connection needs to be established. \u003cP\u003e Note: The \u003ccode\u003eacceptChanges()\u003c/code\u003e method will determine if the \u003ccode\u003eCOMMIT_ON_ACCEPT_CHANGES\u003c/code\u003e is set to true or not. If it is set to true, all updates in the synchronization are committed to the data source. Otherwise, the application \u003cb\u003emust\u003c/b\u003e explicity call the \u003ccode\u003ecommit\u003c/code\u003e or \u003ccode\u003erollback\u003c/code\u003e methods as appropriate.\n * @param con a standard JDBC \u003ccode\u003eConnection\u003c/code\u003e object\n * @throws SQLException if the cursor is on the insert row\n * @throws SyncProviderException if the underlyingsynchronization provider\u0027s writer fails to write the updates back to the data source\n * @see #acceptChanges()\n * @see javax.sql.RowSetWriter\n * @see javax.sql.rowset.spi.SyncFactory\n * @see javax.sql.rowset.spi.SyncProvider\n * @see javax.sql.rowset.spi.SyncProviderException\n * @see javax.sql.rowset.spi.SyncResolver\n */\n","tf":{"freq":{"con":1,"need":1,"anyth":1,"cursor":1,"accept":9,"lexcept":1,"persist":2,"must":3,"specifi":1,"avoid":1,"level":1,"fail":1,"correct":1,"commit":2,"javax":5,"spi":4,"propag":1,"reset":1,"effici":1,"howev":1,"writer":5,"examin":1,"argument":1,"except":4,"succeed":1,"form":4,"rowset":4,"resolv":6,"provid":11,"row":14,"content":1,"configur":1,"updat":5,"determin":1,"contain":1,"will":3,"conflict":9,"sourc":14,"properti":1,"underlyingsynchron":1,"execut":1,"compar":1,"make":1,"otherwis":1,"call":6,"defin":1,"connect":8,"delet":2,"one":1,"made":1,"data":14,"use":7,"rollback":1,"object":9,"applic":3,"version":1,"ensur":2,"popul":1,"sync":11,"factori":1,"unlik":1,"write":5,"current":2,"noth":1,"choos":1,"immedi":1,"valu":7,"initi":1,"note":1,"similar":1,"addit":1,"may":3,"standard":1,"check":1,"guarante":1,"depend":1,"lock":2,"establish":2,"origin":2,"true":2,"back":2,"list":1,"cach":2,"pass":1,"sql":5,"optimist":1,"appropri":1,"retriev":1,"take":1,"explic":1,"exampl":1,"alreadi":2,"method":11,"within":1,"chang":13,"insert":3,"success":1},"maxFreq":14,"totalTerms":285},"loc":0}