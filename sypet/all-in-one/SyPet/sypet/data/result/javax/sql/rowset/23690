{"id":23690,"className":"javax.sql.rowset.CachedRowSet","methodName":"acceptChanges","signature":"\u003cjavax.sql.rowset.CachedRowSet: void acceptChanges()\u003e","javadoc":"/** \n * Propagates row update, insert and delete changes made to this \u003ccode\u003eCachedRowSet\u003c/code\u003e object to the underlying data source. \u003cP\u003e This method calls on this \u003ccode\u003eCachedRowSet\u003c/code\u003e object\u0027s writer to do the work behind the scenes. Standard \u003ccode\u003eCachedRowSet\u003c/code\u003e implementations should use the \u003ccode\u003eSyncFactory\u003c/code\u003e singleton to obtain a \u003ccode\u003eSyncProvider\u003c/code\u003e instance providing a \u003ccode\u003eRowSetWriter\u003c/code\u003e object (writer).  The writer will attempt to propagate changes made in this \u003ccode\u003eCachedRowSet\u003c/code\u003e object back to the data source. \u003cP\u003e When the method \u003ccode\u003eacceptChanges\u003c/code\u003e executes successfully, in addition to writing changes to the data source, it makes the values in the current row be the values in the original row. \u003cP\u003e Depending on the synchronization level of the \u003ccode\u003eSyncProvider\u003c/code\u003e implementation being used, the writer will compare the original values with those in the data source to check for conflicts. When there is a conflict, the \u003ccode\u003eRIOptimisticProvider\u003c/code\u003e implementation, for example, throws a \u003ccode\u003eSyncProviderException\u003c/code\u003e and does not write anything to the data source. \u003cP\u003e An application may choose to catch the \u003ccode\u003eSyncProviderException\u003c/code\u003e object and retrieve the \u003ccode\u003eSyncResolver\u003c/code\u003e object it contains. The \u003ccode\u003eSyncResolver\u003c/code\u003e object lists the conflicts row by row and sets a lock on the data source to avoid further conflicts while the current conflicts are being resolved. Further, for each conflict, it provides methods for examining the conflict and setting the value that should be persisted in the data source. After all conflicts have been resolved, an application must call the \u003ccode\u003eacceptChanges\u003c/code\u003e method again to write resolved values to the data source.  If all of the values in the data source are already the values to be persisted, the method \u003ccode\u003eacceptChanges\u003c/code\u003e does nothing. \u003cP\u003e Some provider implementations may use locks to ensure that there are no conflicts.  In such cases, it is guaranteed that the writer will succeed in writing changes to the data source when the method \u003ccode\u003eacceptChanges\u003c/code\u003e is called.  This method may be called immediately after the methods \u003ccode\u003eupdateRow\u003c/code\u003e, \u003ccode\u003einsertRow\u003c/code\u003e, or \u003ccode\u003edeleteRow\u003c/code\u003e have been called, but it is more efficient to call it only once after all changes have been made so that only one connection needs to be established. \u003cP\u003e Note: The \u003ccode\u003eacceptChanges()\u003c/code\u003e method will determine if the \u003ccode\u003eCOMMIT_ON_ACCEPT_CHANGES\u003c/code\u003e is set to true or not. If it is set to true, all updates in the synchronization are committed to the data source. Otherwise, the application \u003cb\u003emust\u003c/b\u003e explicity call the \u003ccode\u003ecommit()\u003c/code\u003e or \u003ccode\u003erollback()\u003c/code\u003e methods as appropriate.\n * @throws SQLException if the cursor is on the insert row\n * @throws SyncProviderException if the underlyingsynchronization provider\u0027s writer fails to write the updates back to the data source\n * @see #acceptChanges(java.sql.Connection)\n * @see javax.sql.RowSetWriter\n * @see javax.sql.rowset.spi.SyncFactory\n * @see javax.sql.rowset.spi.SyncProvider\n * @see javax.sql.rowset.spi.SyncProviderException\n * @see javax.sql.rowset.spi.SyncResolver\n */\n","tf":{"freq":{"need":1,"anyth":1,"cursor":1,"accept":7,"lexcept":1,"persist":2,"must":2,"avoid":1,"level":1,"fail":1,"commit":2,"javax":5,"spi":4,"propag":2,"effici":1,"writer":8,"examin":1,"work":1,"except":4,"succeed":1,"singleton":1,"rowset":4,"behind":1,"resolv":6,"provid":12,"row":15,"instanc":1,"obtain":1,"updat":4,"determin":1,"contain":1,"will":4,"scene":1,"sourc":12,"conflict":9,"underlyingsynchron":1,"execut":1,"make":1,"compar":1,"otherwis":1,"attempt":1,"call":7,"connect":2,"delet":2,"one":1,"made":3,"data":12,"use":3,"rollback":1,"object":7,"applic":3,"ensur":1,"sync":12,"factori":2,"write":5,"current":2,"noth":1,"choos":1,"immedi":1,"valu":7,"note":1,"addit":1,"may":3,"standard":1,"check":1,"guarante":1,"depend":1,"establish":1,"lock":2,"origin":2,"true":2,"back":2,"list":1,"cach":4,"sql":6,"optimist":1,"appropri":1,"retriev":1,"explic":1,"exampl":1,"java":1,"alreadi":1,"method":10,"chang":12,"insert":3,"success":1},"maxFreq":15,"totalTerms":261},"loc":0}