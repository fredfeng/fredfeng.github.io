{"id":10499,"className":"com.opengamma.analytics.math.interpolation.PenaltyMatrixGenerator","methodName":"getPenaltyMatrix","signature":"\u003ccom.opengamma.analytics.math.interpolation.PenaltyMatrixGenerator: com.opengamma.analytics.math.matrix.DoubleMatrix2D getPenaltyMatrix(int[],int,int)\u003e","javadoc":"/** \n * Assume a tensor has been flattened to a vector as {A_{0,0}, A_{0,1},...._A_{0,m}, A_{1,0}, A_{1,1},...._A_{1,m},...,A_{n,0}, A_{n,1},...._A_{n,m}} (see  {@link flattenMatrix}) that is, the \u003cb\u003elast\u003c/b\u003e index changes most rapidly.  This produces a penalty matrix that acts on a given set of indexes only\u003cP\u003e To produce a penalty matrix that acts on multiple indexes, produce one for each set of indexes and add them together (scaling if necessary)  \n * @param numElements The range of each index. In the example above, this would be {n,m} \n * @param k Difference order. Require size[indices] \u003e k\n * @param index Which set of indices does the matrix act on \n * @return A penalty matrix \n */\n","tf":{"freq":{"scale":1,"last":1,"link":1,"one":1,"add":1,"necessari":1,"flatten":2,"requir":1,"indic":2,"order":1,"given":1,"vector":1,"rang":1,"element":1,"index":6,"penalti":4,"assum":1,"multipl":1,"matrix":6,"produc":3,"togeth":1,"rapid":1,"size":1,"differ":1,"num":1,"exampl":1,"chang":1,"tensor":1,"act":3},"maxFreq":6,"totalTerms":48},"loc":6}