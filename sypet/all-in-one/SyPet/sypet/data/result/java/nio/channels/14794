{"id":14794,"className":"java.nio.channels.SocketChannel","methodName":"connect","signature":"\u003cjava.nio.channels.SocketChannel: boolean connect(java.net.SocketAddress)\u003e","javadoc":"/** \n * Connects this channel\u0027s socket. \u003cp\u003e If this channel is in non-blocking mode then an invocation of this method initiates a non-blocking connection operation.  If the connection is established immediately, as can happen with a local connection, then this method returns \u003ctt\u003etrue\u003c/tt\u003e.  Otherwise this method returns \u003ctt\u003efalse\u003c/tt\u003e and the connection operation must later be completed by invoking the  {@link #finishConnect finishConnect} method.\u003cp\u003e If this channel is in blocking mode then an invocation of this method will block until the connection is established or an I/O error occurs. \u003cp\u003e This method performs exactly the same security checks as the  {@link java.net.Socket} class.  That is, if a security manager has beeninstalled then this method verifies that its  {@link java.lang.SecurityManager#checkConnect checkConnect} method permitsconnecting to the address and port number of the given remote endpoint. \u003cp\u003e This method may be invoked at any time.  If a read or write operation upon this channel is invoked while an invocation of this method is in progress then that operation will first block until this invocation is complete.  If a connection attempt is initiated but fails, that is, if an invocation of this method throws a checked exception, then the channel will be closed.  \u003c/p\u003e\n * @param remote The remote address to which this channel is to be connected\n * @return  \u003ctt\u003etrue\u003c/tt\u003e if a connection was established,\u003ctt\u003efalse\u003c/tt\u003e if this channel is in non-blocking mode and the connection operation is in progress\n * @throws AlreadyConnectedException If this channel is already connected\n * @throws ConnectionPendingException If a non-blocking connection operation is already in progress on this channel\n * @throws ClosedChannelException If this channel is closed\n * @throws AsynchronousCloseException If another thread closes this channel while the connect operation is in progress\n * @throws ClosedByInterruptException If another thread interrupts the current thread while the connect operation is in progress, thereby closing the channel and setting the current thread\u0027s interrupt status\n * @throws UnresolvedAddressException If the given remote address is not fully resolved\n * @throws UnsupportedAddressTypeException If the type of the given remote address is not supported\n * @throws SecurityException If a security manager has been installed and it does not permit access to the given remote endpoint\n * @throws IOException If some other I/O error occurs\n */\n","tf":{"freq":{"progress":5,"fals":2,"unsupport":1,"permit":1,"therebi":1,"perform":1,"type":2,"must":1,"permitsconnect":1,"close":7,"time":1,"fail":1,"given":4,"oper":8,"thread":4,"exact":1,"verifi":1,"socket":2,"happen":1,"except":10,"support":1,"status":1,"invok":3,"resolv":1,"number":1,"invoc":5,"endpoint":2,"non":4,"finish":2,"remot":6,"will":3,"upon":1,"attempt":1,"otherwis":1,"port":1,"asynchron":1,"connect":21,"link":3,"block":7,"anoth":2,"net":1,"unresolv":1,"lang":1,"mode":3,"current":2,"write":1,"read":1,"immedi":1,"initi":2,"pend":1,"complet":2,"may":1,"error":2,"check":4,"later":1,"manag":3,"instal":1,"establish":3,"true":2,"fulli":1,"access":1,"interrupt":3,"secur":5,"address":6,"beeninstal":1,"alreadi":3,"method":11,"java":2,"local":1,"first":1,"channel":13,"occur":2},"maxFreq":21,"totalTerms":205},"loc":0}