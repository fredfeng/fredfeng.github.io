{"id":14912,"className":"java.nio.channels.FileChannel","methodName":"transferTo","signature":"\u003cjava.nio.channels.FileChannel: long transferTo(long,long,java.nio.channels.WritableByteChannel)\u003e","javadoc":"/** \n * Transfers bytes from this channel\u0027s file to the given writable byte channel. \u003cp\u003e An attempt is made to read up to \u003ctt\u003ecount\u003c/tt\u003e bytes starting at the given \u003ctt\u003eposition\u003c/tt\u003e in this channel\u0027s file and write them to the target channel.  An invocation of this method may or may not transfer all of the requested bytes; whether or not it does so depends upon the natures and states of the channels.  Fewer than the requested number of bytes are transferred if this channel\u0027s file contains fewer than \u003ctt\u003ecount\u003c/tt\u003e bytes starting at the given \u003ctt\u003eposition\u003c/tt\u003e, or if the target channel is non-blocking and it has fewer than \u003ctt\u003ecount\u003c/tt\u003e bytes free in its output buffer. \u003cp\u003e This method does not modify this channel\u0027s position.  If the given position is greater than the file\u0027s current size then no bytes are transferred.  If the target channel has a position then bytes are written starting at that position and then the position is incremented by the number of bytes written. \u003cp\u003e This method is potentially much more efficient than a simple loop that reads from this channel and writes to the target channel.  Many operating systems can transfer bytes directly from the filesystem cache to the target channel without actually copying them.  \u003c/p\u003e\n * @param position The position within the file at which the transfer is to begin; must be non-negative\n * @param count The maximum number of bytes to be transferred; must be non-negative\n * @param target The target channel\n * @return  The number of bytes, possibly zero,that were actually transferred\n * @throws IllegalArgumentException If the preconditions on the parameters do not hold\n * @throws NonReadableChannelException If this channel was not opened for reading\n * @throws NonWritableChannelException If the target channel was not opened for writing\n * @throws ClosedChannelException If either this channel or the target channel is closed\n * @throws AsynchronousCloseException If another thread closes either channel while the transfer is in progress\n * @throws ClosedByInterruptException If another thread interrupts the current thread while the transfer is in progress, thereby closing both channels and setting the current thread\u0027s interrupt status\n * @throws IOException If some other I/O error occurs\n */\n","tf":{"freq":{"progress":2,"greater":1,"count":4,"simpl":1,"precondit":1,"therebi":1,"possibl":1,"natur":1,"zero":1,"must":2,"copi":1,"whether":1,"close":6,"buffer":1,"open":2,"free":1,"given":4,"oper":1,"file":5,"thread":4,"request":2,"effici":1,"argument":1,"increment":1,"mani":1,"except":7,"transfer":11,"status":1,"hold":1,"number":4,"writabl":2,"without":1,"invoc":1,"much":1,"non":5,"size":1,"system":1,"start":3,"maximum":1,"contain":1,"fewer":3,"negat":2,"output":1,"posit":9,"upon":1,"attempt":1,"asynchron":1,"readabl":1,"state":1,"made":1,"block":1,"anoth":2,"written":2,"write":3,"current":3,"loop":1,"read":3,"direct":1,"may":2,"error":1,"depend":1,"paramet":1,"cach":1,"illeg":1,"interrupt":3,"potenti":1,"begin":1,"either":2,"target":9,"modifi":1,"actual":2,"method":3,"within":1,"channel":22,"filesystem":1,"occur":1},"maxFreq":22,"totalTerms":179},"loc":0}