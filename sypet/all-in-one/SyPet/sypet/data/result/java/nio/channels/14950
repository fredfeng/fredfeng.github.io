{"id":14950,"className":"java.nio.channels.Channels","methodName":"newReader","signature":"\u003cjava.nio.channels.Channels: java.io.Reader newReader(java.nio.channels.ReadableByteChannel,java.nio.charset.CharsetDecoder,int)\u003e","javadoc":"/** \n * Constructs a reader that decodes bytes from the given channel using the given decoder. \u003cp\u003e The resulting stream will contain an internal input buffer of at least \u003ctt\u003eminBufferCap\u003c/tt\u003e bytes.  The stream\u0027s \u003ctt\u003eread\u003c/tt\u003e methods will, as needed, fill the buffer by reading bytes from the underlying channel; if the channel is in non-blocking mode when bytes are to be read then an  {@link IllegalBlockingModeException} will be thrown.  Theresulting stream will not otherwise be buffered, and it will not support the  {@link Reader#mark mark} or {@link Reader#reset reset} methods.Closing the stream will in turn cause the channel to be closed.  \u003c/p\u003e\n * @param ch The channel from which bytes will be read\n * @param dec The charset decoder to be used\n * @param minBufferCap The minimum capacity of the internal byte buffer, or \u003ctt\u003e-1\u003c/tt\u003e if an implementation-dependent default capacity is to be used\n * @return  A new reader\n */\n","tf":{"freq":{"otherwis":1,"need":1,"result":1,"stream":4,"minimum":1,"least":1,"cap":2,"link":3,"use":3,"block":2,"close":2,"mode":2,"buffer":6,"dec":1,"given":2,"reset":2,"read":4,"min":2,"turn":1,"decod":3,"thrown":1,"except":1,"support":1,"depend":1,"fill":1,"charset":1,"mark":2,"theresult":1,"illeg":1,"non":1,"input":1,"caus":1,"reader":5,"contain":1,"intern":2,"will":7,"method":2,"capac":2,"construct":1,"channel":5},"maxFreq":7,"totalTerms":82},"loc":4}