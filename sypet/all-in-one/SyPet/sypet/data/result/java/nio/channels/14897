{"id":14897,"className":"java.nio.channels.AsynchronousSocketChannel","methodName":"write","signature":"\u003cjava.nio.channels.AsynchronousSocketChannel: void write(java.nio.ByteBuffer[],int,int,long,java.util.concurrent.TimeUnit,A,java.nio.channels.CompletionHandler)\u003e","javadoc":"/** \n * Writes a sequence of bytes to this channel from a subsequence of the given buffers. This operation, sometimes called a \u003cem\u003egathering write\u003c/em\u003e, is often useful when implementing network protocols that group data into segments consisting of one or more fixed-length headers followed by a variable-length body. The  {@code handler} parameter is a completionhandler that is invoked when the write operation completes (or fails). The result passed to the completion handler is the number of bytes written. \u003cp\u003e This method initiates a write of up to \u003ci\u003er\u003c/i\u003e bytes to this channel, where \u003ci\u003er\u003c/i\u003e is the total number of bytes remaining in the specified subsequence of the given buffer array, that is, \u003cblockquote\u003e\u003cpre\u003e srcs[offset].remaining() + srcs[offset+1].remaining() + ... + srcs[offset+length-1].remaining()\u003c/pre\u003e\u003c/blockquote\u003e at the moment that the write is attempted. \u003cp\u003e Suppose that a byte sequence of length \u003ci\u003en\u003c/i\u003e is written, where \u003ctt\u003e0\u003c/tt\u003e\u0026nbsp;\u003ctt\u003e\u0026lt;\u003c/tt\u003e\u0026nbsp;\u003ci\u003en\u003c/i\u003e\u0026nbsp;\u003ctt\u003e\u0026lt;\u003d\u003c/tt\u003e\u0026nbsp;\u003ci\u003er\u003c/i\u003e. Up to the first \u003ctt\u003esrcs[offset].remaining()\u003c/tt\u003e bytes of this sequence are written from buffer \u003ctt\u003esrcs[offset]\u003c/tt\u003e, up to the next \u003ctt\u003esrcs[offset+1].remaining()\u003c/tt\u003e bytes are written from buffer \u003ctt\u003esrcs[offset+1]\u003c/tt\u003e, and so forth, until the entire byte sequence is written.  As many bytes as possible are written from each buffer, hence the final position of each updated buffer, except the last updated buffer, is guaranteed to be equal to that buffer\u0027s limit. The underlying operating system may impose a limit on the number of buffers that may be used in an I/O operation. Where the number of buffers (with bytes remaining), exceeds this limit, then the I/O operation is performed with the maximum number of buffers allowed by the operating system. \u003cp\u003e If a timeout is specified and the timeout elapses before the operation completes then it completes with the exception  {@link InterruptedByTimeoutException}. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been written, or will not be written to the channel from the given buffers, then further attempts to write to the channel will cause an unspecific runtime exception to be thrown.\n * @param srcs The buffers from which bytes are to be retrieved\n * @param offset The offset within the buffer array of the first buffer from which bytes are to be retrieved; must be non-negative and no larger than  {@code srcs.length}\n * @param length The maximum number of buffers to be accessed; must be non-negative and no larger than  {@code srcs.length - offset}\n * @param timeout The maximum time for the I/O operation to complete\n * @param unit The time unit of the  {@code timeout} argument\n * @param attachment The object to attach to the I/O operation; can be  {@code null}\n * @param handler The handler for consuming the result\n * @throws IndexOutOfBoundsException If the pre-conditions for the  {@code offset}  and {@code length}parameter aren\u0027t met\n * @throws WritePendingException If a write operation is already in progress on this channel\n * @throws NotYetConnectedException If this channel is not yet connected\n * @throws ShutdownChannelGroupException If the channel group has terminated\n */\n","tf":{"freq":{"total":1,"forth":1,"variabl":1,"specifi":2,"elaps":1,"time":2,"fail":1,"given":3,"oper":10,"blockquot":2,"sequenc":4,"nbsp":4,"limit":3,"mani":1,"henc":1,"invok":1,"runtim":1,"number":6,"header":1,"non":2,"system":2,"will":2,"entir":1,"posit":1,"array":2,"moment":1,"next":1,"link":1,"data":1,"use":2,"written":8,"write":9,"length":8,"sometim":1,"initi":1,"shutdown":1,"complet":5,"may":2,"larger":2,"exceed":1,"suppos":1,"access":1,"srcs":10,"remain":7,"retriev":2,"attach":2,"alreadi":1,"method":1,"within":1,"bound":1,"yet":2,"progress":1,"last":1,"segment":1,"possibl":1,"perform":1,"must":2,"buffer":16,"gather":1,"follow":1,"argument":1,"except":8,"thrown":1,"index":1,"consist":1,"bodi":1,"updat":2,"often":1,"maximum":3,"negat":2,"attempt":2,"result":2,"call":1,"connect":2,"allow":1,"one":1,"completionhandl":1,"object":1,"network":1,"consum":1,"met":1,"unspecif":1,"fix":1,"offset":11,"subsequ":2,"pend":1,"condit":1,"protocol":1,"guarante":2,"paramet":2,"equal":1,"interrupt":1,"pass":1,"impos":1,"unit":2,"termin":1,"caus":1,"pre":3,"group":3,"channel":8,"first":2,"timeout":6,"handler":4,"occur":1},"maxFreq":16,"totalTerms":246},"loc":0}