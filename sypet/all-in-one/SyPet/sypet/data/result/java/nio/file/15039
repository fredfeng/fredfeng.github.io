{"id":15039,"className":"java.nio.file.FileSystem","methodName":"getPathMatcher","signature":"\u003cjava.nio.file.FileSystem: java.nio.file.PathMatcher getPathMatcher(java.lang.String)\u003e","javadoc":"/** \n * Returns a  {@code PathMatcher} that performs match operations on the{@code String} representation of {@link Path} objects by interpreting agiven pattern. The  {@code syntaxAndPattern} parameter identifies the syntax and thepattern and takes the form: \u003cblockquote\u003e\u003cpre\u003e \u003ci\u003esyntax\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e\u003ci\u003epattern\u003c/i\u003e \u003c/pre\u003e\u003c/blockquote\u003e where  {@code \u0027:\u0027} stands for itself.\u003cp\u003e A  {@code FileSystem} implementation supports the \"{@code glob}\" and \" {@code regex}\" syntaxes, and may support others. The value of the syntax component is compared without regard to case. \u003cp\u003e When the syntax is \" {@code glob}\" then the  {@code String}representation of the path is matched using a limited pattern language that resembles regular expressions but with a simpler syntax. For example: \u003cblockquote\u003e \u003ctable border\u003d\"0\"\u003e \u003ctr\u003e \u003ctd\u003e {@code *.java}\u003c/td\u003e \u003ctd\u003eMatches a path that represents a file name ending in  {@code .java}\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e {@code *.*}\u003c/td\u003e \u003ctd\u003eMatches file names containing a dot\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctr\u003e \u003ctd\u003e {@code} *.java,class}}\u003c/td\u003e \u003ctd\u003eMatches file names ending with  {@code .java} or {@code .class}\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e {@code foo.?}\u003c/td\u003e \u003ctd\u003eMatches file names starting with  {@code foo.} and a singlecharacter extension\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e\u003ctt\u003e\u0026#47;home\u0026#47;*\u0026#47;*\u003c/tt\u003e \u003ctd\u003eMatches \u003ctt\u003e\u0026#47;home\u0026#47;gus\u0026#47;data\u003c/tt\u003e on UNIX platforms\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e\u003ctt\u003e\u0026#47;home\u0026#47;**\u003c/tt\u003e \u003ctd\u003eMatches \u003ctt\u003e\u0026#47;home\u0026#47;gus\u003c/tt\u003e and \u003ctt\u003e\u0026#47;home\u0026#47;gus\u0026#47;data\u003c/tt\u003e on UNIX platforms\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e\u003ctt\u003eC:\u0026#92;\u0026#92;*\u003c/tt\u003e \u003ctd\u003eMatches \u003ctt\u003eC:\u0026#92;foo\u003c/tt\u003e and \u003ctt\u003eC:\u0026#92;bar\u003c/tt\u003e on the Windows platform (note that the backslash is escaped; as a string literal in the Java Language the pattern would be \u003ctt\u003e\"C:\u0026#92;\u0026#92;\u0026#92;\u0026#92*\"\u003c/tt\u003e) \u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003c/blockquote\u003e \u003cp\u003e The following rules are used to interpret glob patterns: \u003cp\u003e \u003cul\u003e \u003cli\u003e\u003cp\u003e The  {@code *} character matches zero or more {@link Character characters} of a {@link Path#getName(int) name} component withoutcrossing directory boundaries. \u003c/p\u003e\u003c/li\u003e \u003cli\u003e\u003cp\u003e The  {@code **} characters matches zero or more {@link Character characters} crossing directory boundaries. \u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e The  {@code ?} character matches exactly one character of aname component.\u003c/p\u003e\u003c/li\u003e \u003cli\u003e\u003cp\u003e The backslash character ( {@code \\}) is used to escape characters that would otherwise be interpreted as special characters. The expression {@code \\\\} matches a single backslash and \"\\{\" matches a left bracefor example.  \u003c/p\u003e\u003c/li\u003e \u003cli\u003e\u003cp\u003e The  {@code [ ]} characters are a \u003ci\u003ebracket expression\u003c/i\u003e thatmatch a single character of a name component out of a set of characters. For example,  {@code [abc]} matches {@code \"a\"},  {@code \"b\"}, or  {@code \"c\"}. The hyphen ( {@code -}) may be used to specify a range so  {@code [a-z]}specifies a range that matches from  {@code \"a\"} to {@code \"z\"} (inclusive).These forms can be mixed so [abce-g] matches  {@code \"a\"},  {@code \"b\"}, {@code \"c\"},  {@code \"e\"},  {@code \"f\"} or {@code \"g\"}. If the character after the  {@code [} is a {@code !} then it is used for negation so {@code [!a-c]} matches any character except {@code \"a\"},  {@code \"b\"}, or  {@code \"c\"}. \u003cp\u003e Within a bracket expression the  {@code *},  {@code ?} and {@code \\}characters match themselves. The ( {@code -}) character matches itself if it is the first character within the brackets, or the first character after the  {@code !} if negating.\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e The  {@code} characters are a group of subpatterns, where the group matches if any subpattern in the group matches. The  {@code \",\"}character is used to separate the subpatterns. Groups cannot be nested. \u003c/p\u003e\u003c/li\u003e \u003cli\u003e\u003cp\u003e Leading period\u003ctt\u003e\u0026#47;\u003c/tt\u003edot characters in file name are treated as regular characters in match operations. For example, the  {@code \"*\"} glob pattern matches file name {@code \".login\"}. The  {@link Files#isHidden} method may be used to test whether a fileis considered hidden. \u003c/p\u003e\u003c/li\u003e \u003cli\u003e\u003cp\u003e All other characters match themselves in an implementation dependent manner. This includes characters representing any  {@link FileSystem#getSeparator name-separators}. \u003c/p\u003e\u003c/li\u003e \u003cli\u003e\u003cp\u003e The matching of  {@link Path#getRoot root} components is highlyimplementation-dependent and is not specified. \u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e \u003cp\u003e When the syntax is \" {@code regex}\" then the pattern component is a regular expression as defined by the  {@link java.util.regex.Pattern}class. \u003cp\u003e  For both the glob and regex syntaxes, the matching details, such as whether the matching is case sensitive, are implementation-dependent and therefore not specified.\n * @param syntaxAndPattern The syntax and pattern\n * @return  A path matcher that may be used to match paths against the pattern\n * @throws IllegalArgumentException If the parameter does not take the form:  {@code syntax:pattern}\n * @throws java.util.regex.PatternSyntaxException If the pattern is invalid\n * @throws UnsupportedOperationException If the pattern syntax is not known to the implementation\n * @see Files#newDirectoryStream(Path,String)\n */\n","tf":{"freq":{"abc":2,"test":1,"singl":2,"languag":2,"foo":3,"zero":2,"whether":2,"dot":2,"specifi":4,"matcher":3,"oper":3,"blockquot":4,"file":10,"rang":2,"border":1,"limit":1,"platform":3,"support":2,"form":3,"charact":26,"regex":5,"agiven":1,"regard":1,"resembl":1,"without":1,"system":2,"start":1,"bar":1,"cross":1,"home":5,"stream":1,"directori":3,"link":8,"data":2,"use":8,"therefor":1,"express":5,"consid":1,"simpler":1,"left":1,"end":2,"note":1,"may":4,"repres":2,"thepattern":1,"gus":3,"mix":1,"represent":2,"compon":6,"pattern":16,"tabl":2,"string":4,"exampl":4,"filei":1,"method":1,"within":2,"anam":1,"unsupport":1,"detail":1,"root":2,"highlyimplement":1,"lead":1,"perform":1,"bracket":3,"thatmatch":1,"bracefor":1,"invalid":1,"exact":1,"login":1,"follow":1,"argument":1,"sensit":1,"liter":1,"except":4,"withoutcross":1,"period":1,"syntax":14,"window":1,"separ":3,"contain":1,"negat":2,"known":1,"match":29,"compar":1,"boundari":2,"util":2,"treat":1,"hyphen":1,"otherwis":1,"defin":1,"one":1,"interpret":3,"identifi":1,"object":1,"escap":2,"backslash":3,"inclus":1,"extens":1,"name":10,"rule":1,"path":10,"valu":1,"includ":1,"regular":3,"depend":3,"nest":1,"paramet":2,"illeg":1,"singlecharact":1,"stand":1,"hidden":2,"take":2,"pre":2,"glob":5,"manner":1,"java":7,"special":1,"group":4,"first":2,"subpattern":3},"maxFreq":29,"totalTerms":343},"loc":0}