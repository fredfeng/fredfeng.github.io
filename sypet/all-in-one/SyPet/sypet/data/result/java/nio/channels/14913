{"id":14913,"className":"java.nio.channels.FileChannel","methodName":"transferFrom","signature":"\u003cjava.nio.channels.FileChannel: long transferFrom(java.nio.channels.ReadableByteChannel,long,long)\u003e","javadoc":"/** \n * Transfers bytes into this channel\u0027s file from the given readable byte channel. \u003cp\u003e An attempt is made to read up to \u003ctt\u003ecount\u003c/tt\u003e bytes from the source channel and write them to this channel\u0027s file starting at the given \u003ctt\u003eposition\u003c/tt\u003e.  An invocation of this method may or may not transfer all of the requested bytes; whether or not it does so depends upon the natures and states of the channels.  Fewer than the requested number of bytes will be transferred if the source channel has fewer than \u003ctt\u003ecount\u003c/tt\u003e bytes remaining, or if the source channel is non-blocking and has fewer than \u003ctt\u003ecount\u003c/tt\u003e bytes immediately available in its input buffer. \u003cp\u003e This method does not modify this channel\u0027s position.  If the given position is greater than the file\u0027s current size then no bytes are transferred.  If the source channel has a position then bytes are read starting at that position and then the position is incremented by the number of bytes read. \u003cp\u003e This method is potentially much more efficient than a simple loop that reads from the source channel and writes to this channel.  Many operating systems can transfer bytes directly from the source channel into the filesystem cache without actually copying them.  \u003c/p\u003e\n * @param src The source channel\n * @param position The position within the file at which the transfer is to begin; must be non-negative\n * @param count The maximum number of bytes to be transferred; must be non-negative\n * @return  The number of bytes, possibly zero,that were actually transferred\n * @throws IllegalArgumentException If the preconditions on the parameters do not hold\n * @throws NonReadableChannelException If the source channel was not opened for reading\n * @throws NonWritableChannelException If this channel was not opened for writing\n * @throws ClosedChannelException If either this channel or the source channel is closed\n * @throws AsynchronousCloseException If another thread closes either channel while the transfer is in progress\n * @throws ClosedByInterruptException If another thread interrupts the current thread while the transfer is in progress, thereby closing both channels and setting the current thread\u0027s interrupt status\n * @throws IOException If some other I/O error occurs\n */\n","tf":{"freq":{"progress":2,"greater":1,"count":4,"simpl":1,"precondit":1,"therebi":1,"possibl":1,"natur":1,"zero":1,"must":2,"copi":1,"whether":1,"close":6,"buffer":1,"open":2,"given":3,"oper":1,"file":4,"thread":4,"request":2,"effici":1,"argument":1,"increment":1,"mani":1,"except":7,"transfer":11,"status":1,"hold":1,"writabl":1,"number":4,"avail":1,"without":1,"invoc":1,"much":1,"non":5,"size":1,"input":1,"system":1,"start":2,"maximum":1,"will":1,"fewer":3,"negat":2,"sourc":9,"posit":8,"upon":1,"attempt":1,"asynchron":1,"readabl":2,"state":1,"made":1,"block":1,"anoth":2,"write":3,"current":3,"loop":1,"read":5,"immedi":1,"src":1,"direct":1,"may":2,"error":1,"depend":1,"paramet":1,"cach":1,"illeg":1,"interrupt":3,"potenti":1,"begin":1,"either":2,"remain":1,"modifi":1,"actual":2,"method":3,"within":1,"channel":22,"filesystem":1,"occur":1},"maxFreq":22,"totalTerms":178},"loc":0}