{"id":14920,"className":"java.nio.channels.FileChannel","methodName":"tryLock","signature":"\u003cjava.nio.channels.FileChannel: java.nio.channels.FileLock tryLock(long,long,boolean)\u003e","javadoc":"/** \n * Attempts to acquire a lock on the given region of this channel\u0027s file. \u003cp\u003e This method does not block.  An invocation always returns immediately, either having acquired a lock on the requested region or having failed to do so.  If it fails to acquire a lock because an overlapping lock is held by another program then it returns \u003ctt\u003enull\u003c/tt\u003e.  If it fails to acquire a lock for any other reason then an appropriate exception is thrown. \u003cp\u003e The region specified by the \u003ctt\u003eposition\u003c/tt\u003e and \u003ctt\u003esize\u003c/tt\u003e parameters need not be contained within, or even overlap, the actual underlying file.  Lock regions are fixed in size; if a locked region initially contains the end of the file and the file grows beyond the region then the new portion of the file will not be covered by the lock. If a file is expected to grow in size and a lock on the entire file is required then a region starting at zero, and no smaller than the expected maximum size of the file, should be locked.  The zero-argument {@link #tryLock()} method simply locks a region of size {@link Long#MAX_VALUE}. \u003cp\u003e Some operating systems do not support shared locks, in which case a request for a shared lock is automatically converted into a request for an exclusive lock.  Whether the newly-acquired lock is shared or exclusive may be tested by invoking the resulting lock object\u0027s  {@link FileLock#isShared() isShared} method.\u003cp\u003e File locks are held on behalf of the entire Java virtual machine. They are not suitable for controlling access to a file by multiple threads within the same virtual machine.  \u003c/p\u003e\n * @param position The position at which the locked region is to start; must be non-negative\n * @param size The size of the locked region; must be non-negative, and the sum \u003ctt\u003eposition\u003c/tt\u003e\u0026nbsp;+\u0026nbsp;\u003ctt\u003esize\u003c/tt\u003e must be non-negative\n * @param shared \u003ctt\u003etrue\u003c/tt\u003e to request a shared lock, \u003ctt\u003efalse\u003c/tt\u003e to request an exclusive lock\n * @return  A lock object representing the newly-acquired lock,or \u003ctt\u003enull\u003c/tt\u003e if the lock could not be acquired because another program holds an overlapping lock\n * @throws IllegalArgumentException If the preconditions on the parameters do not hold\n * @throws ClosedChannelException If this channel is closed\n * @throws OverlappingFileLockException If a lock that overlaps the requested region is already held by this Java virtual machine, or if another thread is already blocked in this method and is attempting to lock an overlapping region of the same file\n * @throws IOException If some other I/O error occurs\n * @see #lock()\n * @see #lock(long,long,boolean)\n * @see #tryLock()\n */\n","tf":{"freq":{"fals":1,"behalf":1,"acquir":7,"need":1,"test":1,"reason":1,"suitabl":1,"precondit":1,"zero":2,"must":3,"whether":1,"close":2,"specifi":1,"beyond":1,"expect":2,"cover":1,"requir":1,"fail":3,"given":1,"oper":1,"file":13,"thread":2,"request":6,"nbsp":2,"argument":2,"control":1,"thrown":1,"except":5,"support":1,"overlap":6,"multipl":1,"invok":1,"alway":1,"hold":2,"invoc":1,"non":3,"size":8,"newli":2,"machin":3,"system":1,"start":2,"program":2,"maximum":1,"contain":2,"will":1,"negat":3,"even":1,"posit":4,"entir":2,"virtual":3,"attempt":2,"region":12,"result":1,"simpli":1,"link":3,"sum":1,"convert":1,"block":2,"object":2,"anoth":3,"automat":1,"smaller":1,"share":7,"fix":1,"immedi":1,"exclus":3,"initi":1,"end":1,"portion":1,"held":3,"may":1,"error":1,"repres":1,"lock":34,"paramet":2,"true":1,"access":1,"illeg":1,"either":1,"appropri":1,"grow":2,"actual":1,"alreadi":2,"java":2,"method":4,"within":2,"channel":3,"occur":1},"maxFreq":34,"totalTerms":225},"loc":0}