{"id":14918,"className":"java.nio.channels.FileChannel","methodName":"lock","signature":"\u003cjava.nio.channels.FileChannel: java.nio.channels.FileLock lock(long,long,boolean)\u003e","javadoc":"/** \n * Acquires a lock on the given region of this channel\u0027s file. \u003cp\u003e An invocation of this method will block until the region can be locked, this channel is closed, or the invoking thread is interrupted, whichever comes first. \u003cp\u003e If this channel is closed by another thread during an invocation of this method then an  {@link AsynchronousCloseException} will be thrown.\u003cp\u003e If the invoking thread is interrupted while waiting to acquire the lock then its interrupt status will be set and a  {@link FileLockInterruptionException} will be thrown.  If the invoker\u0027sinterrupt status is set when this method is invoked then that exception will be thrown immediately; the thread\u0027s interrupt status will not be changed. \u003cp\u003e The region specified by the \u003ctt\u003eposition\u003c/tt\u003e and \u003ctt\u003esize\u003c/tt\u003e parameters need not be contained within, or even overlap, the actual underlying file.  Lock regions are fixed in size; if a locked region initially contains the end of the file and the file grows beyond the region then the new portion of the file will not be covered by the lock. If a file is expected to grow in size and a lock on the entire file is required then a region starting at zero, and no smaller than the expected maximum size of the file, should be locked.  The zero-argument {@link #lock()} method simply locks a region of size {@link Long#MAX_VALUE}. \u003cp\u003e Some operating systems do not support shared locks, in which case a request for a shared lock is automatically converted into a request for an exclusive lock.  Whether the newly-acquired lock is shared or exclusive may be tested by invoking the resulting lock object\u0027s  {@link FileLock#isShared() isShared} method.\u003cp\u003e File locks are held on behalf of the entire Java virtual machine. They are not suitable for controlling access to a file by multiple threads within the same virtual machine.  \u003c/p\u003e\n * @param position The position at which the locked region is to start; must be non-negative\n * @param size The size of the locked region; must be non-negative, and the sum \u003ctt\u003eposition\u003c/tt\u003e\u0026nbsp;+\u0026nbsp;\u003ctt\u003esize\u003c/tt\u003e must be non-negative\n * @param shared \u003ctt\u003etrue\u003c/tt\u003e to request a shared lock, in which case this channel must be open for reading (and possibly writing); \u003ctt\u003efalse\u003c/tt\u003e to request an exclusive lock, in which case this channel must be open for writing (and possibly reading)\n * @return  A lock object representing the newly-acquired lock\n * @throws IllegalArgumentException If the preconditions on the parameters do not hold\n * @throws ClosedChannelException If this channel is closed\n * @throws AsynchronousCloseException If another thread closes this channel while the invoking thread is blocked in this method\n * @throws FileLockInterruptionException If the invoking thread is interrupted while blocked in this method\n * @throws OverlappingFileLockException If a lock that overlaps the requested region is already held by this Java virtual machine, or if another thread is already blocked in this method and is attempting to lock an overlapping region\n * @throws NonReadableChannelException If \u003ctt\u003eshared\u003c/tt\u003e is \u003ctt\u003etrue\u003c/tt\u003e this channel was not opened for reading\n * @throws NonWritableChannelException If \u003ctt\u003eshared\u003c/tt\u003e is \u003ctt\u003efalse\u003c/tt\u003e but this channel was not opened for writing\n * @throws IOException If some other I/O error occurs\n * @see #lock()\n * @see #tryLock()\n * @see #tryLock(long,long,boolean)\n */\n","tf":{"freq":{"fals":2,"behalf":1,"acquir":4,"need":1,"test":1,"suitabl":1,"precondit":1,"possibl":2,"wait":1,"zero":2,"must":5,"whether":1,"close":7,"specifi":1,"beyond":1,"whichev":1,"expect":2,"open":4,"cover":1,"requir":1,"given":1,"oper":1,"file":14,"request":5,"thread":9,"sinterrupt":1,"nbsp":2,"argument":2,"control":1,"thrown":3,"except":11,"support":1,"overlap":4,"multipl":1,"status":3,"invok":7,"hold":1,"writabl":1,"invoc":2,"non":5,"size":8,"newli":2,"machin":3,"system":1,"start":2,"maximum":1,"contain":2,"will":7,"negat":3,"even":1,"posit":4,"entir":2,"attempt":1,"virtual":3,"region":12,"result":1,"asynchron":2,"simpli":1,"readabl":1,"link":5,"sum":1,"convert":1,"block":4,"object":2,"anoth":3,"automat":1,"smaller":1,"share":9,"fix":1,"write":3,"read":3,"immedi":1,"exclus":3,"initi":1,"end":1,"portion":1,"held":2,"may":1,"error":1,"repres":1,"lock":32,"paramet":2,"true":2,"come":1,"access":1,"illeg":1,"interrupt":7,"grow":2,"actual":1,"alreadi":2,"java":2,"method":8,"chang":1,"within":2,"first":1,"channel":12,"occur":1},"maxFreq":32,"totalTerms":296},"loc":0}