{"id":14893,"className":"java.nio.channels.AsynchronousSocketChannel","methodName":"read","signature":"\u003cjava.nio.channels.AsynchronousSocketChannel: void read(java.nio.ByteBuffer[],int,int,long,java.util.concurrent.TimeUnit,A,java.nio.channels.CompletionHandler)\u003e","javadoc":"/** \n * Reads a sequence of bytes from this channel into a subsequence of the given buffers. This operation, sometimes called a \u003cem\u003escattering read\u003c/em\u003e, is often useful when implementing network protocols that group data into segments consisting of one or more fixed-length headers followed by a variable-length body. The  {@code handler} parameter is a completionhandler that is invoked when the read operation completes (or fails). The result passed to the completion handler is the number of bytes read or {@code -1} if no bytes could be read because the channel has reachedend-of-stream. \u003cp\u003e This method initiates a read of up to \u003ci\u003er\u003c/i\u003e bytes from this channel, where \u003ci\u003er\u003c/i\u003e is the total number of bytes remaining in the specified subsequence of the given buffer array, that is, \u003cblockquote\u003e\u003cpre\u003e dsts[offset].remaining() + dsts[offset+1].remaining() + ... + dsts[offset+length-1].remaining()\u003c/pre\u003e\u003c/blockquote\u003e at the moment that the read is attempted. \u003cp\u003e Suppose that a byte sequence of length \u003ci\u003en\u003c/i\u003e is read, where \u003ctt\u003e0\u003c/tt\u003e\u0026nbsp;\u003ctt\u003e\u0026lt;\u003c/tt\u003e\u0026nbsp;\u003ci\u003en\u003c/i\u003e\u0026nbsp;\u003ctt\u003e\u0026lt;\u003d\u003c/tt\u003e\u0026nbsp;\u003ci\u003er\u003c/i\u003e. Up to the first \u003ctt\u003edsts[offset].remaining()\u003c/tt\u003e bytes of this sequence are transferred into buffer \u003ctt\u003edsts[offset]\u003c/tt\u003e, up to the next \u003ctt\u003edsts[offset+1].remaining()\u003c/tt\u003e bytes are transferred into buffer \u003ctt\u003edsts[offset+1]\u003c/tt\u003e, and so forth, until the entire byte sequence is transferred into the given buffers.  As many bytes as possible are transferred into each buffer, hence the final position of each updated buffer, except the last updated buffer, is guaranteed to be equal to that buffer\u0027s limit. The underlying operating system may impose a limit on the number of buffers that may be used in an I/O operation. Where the number of buffers (with bytes remaining), exceeds this limit, then the I/O operation is performed with the maximum number of buffers allowed by the operating system. \u003cp\u003e If a timeout is specified and the timeout elapses before the operation completes then it completes with the exception  {@link InterruptedByTimeoutException}. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been read, or will not be read from the channel into the given buffers, then further attempts to read from the channel will cause an unspecific runtime exception to be thrown.\n * @param dsts The buffers into which bytes are to be transferred\n * @param offset The offset within the buffer array of the first buffer into which bytes are to be transferred; must be non-negative and no larger than {@code dsts.length}\n * @param length The maximum number of buffers to be accessed; must be non-negative and no larger than  {@code dsts.length - offset}\n * @param timeout The maximum time for the I/O operation to complete\n * @param unit The time unit of the  {@code timeout} argument\n * @param attachment The object to attach to the I/O operation; can be  {@code null}\n * @param handler The handler for consuming the result\n * @throws IndexOutOfBoundsException If the pre-conditions for the  {@code offset}  and {@code length}parameter aren\u0027t met\n * @throws IllegalArgumentException If the buffer is read-only\n * @throws ReadPendingException If a read operation is already in progress on this channel\n * @throws NotYetConnectedException If this channel is not yet connected\n * @throws ShutdownChannelGroupException If the channel group has terminated\n */\n","tf":{"freq":{"total":1,"forth":1,"variabl":1,"specifi":2,"elaps":1,"time":2,"fail":1,"given":4,"oper":10,"blockquot":2,"sequenc":4,"nbsp":4,"limit":3,"mani":1,"transfer":6,"henc":1,"invok":1,"runtim":1,"number":6,"header":1,"non":2,"system":2,"will":2,"entir":1,"posit":1,"array":2,"stream":1,"moment":1,"next":1,"link":1,"data":1,"use":2,"length":8,"sometim":1,"initi":1,"shutdown":1,"complet":5,"may":2,"larger":2,"exceed":1,"suppos":1,"access":1,"scatter":1,"remain":7,"attach":2,"alreadi":1,"method":1,"within":1,"bound":1,"yet":2,"progress":1,"last":1,"segment":1,"possibl":1,"perform":1,"must":2,"reachedend":1,"buffer":18,"follow":1,"argument":2,"except":9,"thrown":1,"index":1,"consist":1,"bodi":1,"updat":2,"often":1,"maximum":3,"negat":2,"attempt":2,"result":2,"call":1,"connect":2,"allow":1,"dsts":10,"one":1,"completionhandl":1,"object":1,"network":1,"consum":1,"met":1,"unspecif":1,"fix":1,"read":15,"offset":11,"subsequ":2,"pend":1,"condit":1,"protocol":1,"guarante":2,"paramet":2,"equal":1,"illeg":1,"interrupt":1,"pass":1,"impos":1,"unit":2,"termin":1,"caus":1,"pre":3,"group":3,"channel":9,"first":2,"timeout":6,"handler":4,"occur":1},"maxFreq":18,"totalTerms":257},"loc":0}