{"id":23376,"className":"java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock","methodName":"newCondition","signature":"\u003cjava.util.concurrent.locks.ReentrantReadWriteLock$WriteLock: java.util.concurrent.locks.Condition newCondition()\u003e","javadoc":"/** \n * Returns a  {@link Condition} instance for use with this{@link Lock} instance.\u003cp\u003eThe returned  {@link Condition} instance supports the sameusages as do the  {@link Object} monitor methods ({@link Object#wait() wait},  {@link Object#notify notify}, and  {@link Object#notifyAll notifyAll}) when used with the built-in monitor lock. \u003cul\u003e \u003cli\u003eIf this write lock is not held when any  {@link Condition} method is called then an {@link IllegalMonitorStateException} is thrown.  (Read locks areheld independently of write locks, so are not checked or affected. However it is essentially always an error to invoke a condition waiting method when the current thread has also acquired read locks, since other threads that could unblock it will not be able to acquire the write lock.) \u003cli\u003eWhen the condition  {@linkplain Condition#await() waiting}methods are called the write lock is released and, before they return, the write lock is reacquired and the lock hold count restored to what it was when the method was called. \u003cli\u003eIf a thread is  {@linkplain Thread#interrupt interrupted} whilewaiting then the wait will terminate, an  {@link InterruptedException} will be thrown, and the thread\u0027sinterrupted status will be cleared. \u003cli\u003e Waiting threads are signalled in FIFO order. \u003cli\u003eThe ordering of lock reacquisition for threads returning from waiting methods is the same as for threads initially acquiring the lock, which is in the default case not specified, but for \u003cem\u003efair\u003c/em\u003e locks favors those threads that have been waiting the longest. \u003c/ul\u003e\n * @return the Condition object\n */\n","tf":{"freq":{"acquir":3,"count":1,"unblock":1,"wait":8,"abl":1,"specifi":1,"independ":1,"essenti":1,"thread":9,"howev":1,"sinterrupt":1,"notifi":4,"thrown":2,"except":2,"support":1,"monitor":3,"status":1,"alway":1,"invok":1,"hold":1,"whilewait":1,"fair":1,"reacquisit":1,"instanc":3,"await":1,"sameusag":1,"will":4,"restor":1,"favor":1,"call":3,"linkplain":2,"areheld":1,"link":10,"state":1,"use":2,"signal":1,"object":5,"longest":1,"affect":1,"clear":1,"order":2,"releas":1,"write":5,"current":1,"read":2,"initi":1,"built":1,"condit":8,"held":1,"check":1,"error":1,"lock":13,"illeg":1,"reacquir":1,"interrupt":3,"termin":1,"method":6,"also":1},"maxFreq":13,"totalTerms":136},"loc":3}