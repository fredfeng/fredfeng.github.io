{"id":21402,"className":"java.util.ServiceLoader","methodName":"loadInstalled","signature":"\u003cjava.util.ServiceLoader: java.util.ServiceLoader\u003cS\u003e loadInstalled(java.lang.Class)\u003e","javadoc":"/** \n * Creates a new service loader for the given service type, using the extension class loader. \u003cp\u003e This convenience method simply locates the extension class loader, call it \u003ctt\u003e\u003ci\u003eextClassLoader\u003c/i\u003e\u003c/tt\u003e, and then returns \u003cblockquote\u003e\u003cpre\u003e ServiceLoader.load(\u003ci\u003eservice\u003c/i\u003e, \u003ci\u003eextClassLoader\u003c/i\u003e)\u003c/pre\u003e\u003c/blockquote\u003e \u003cp\u003e If the extension class loader cannot be found then the system class loader is used; if there is no system class loader then the bootstrap class loader is used. \u003cp\u003e This method is intended for use when only installed providers are desired.  The resulting service will only find and load providers that have been installed into the current Java virtual machine; providers on the application\u0027s class path will be ignored.\n * @param service The interface or abstract class representing the service\n * @return A new service loader\n */\n","tf":{"freq":{"virtual":1,"call":1,"result":1,"simpli":1,"bootstrap":1,"servic":8,"use":4,"type":1,"desir":1,"applic":1,"ext":2,"given":1,"extens":3,"blockquot":2,"path":1,"current":1,"find":1,"conveni":1,"ignor":1,"locat":1,"repres":1,"creat":1,"loader":11,"instal":3,"provid":3,"machin":1,"system":2,"pre":2,"will":2,"java":1,"method":2,"load":3,"intend":1,"found":1},"maxFreq":11,"totalTerms":68},"loc":9}