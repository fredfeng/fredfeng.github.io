{"id":23963,"className":"java.util.regex.Matcher","methodName":"appendReplacement","signature":"\u003cjava.util.regex.Matcher: java.util.regex.Matcher appendReplacement(java.lang.StringBuffer,java.lang.String)\u003e","javadoc":"/** \n * Implements a non-terminal append-and-replace step. \u003cp\u003e This method performs the following actions: \u003c/p\u003e \u003col\u003e \u003cli\u003e\u003cp\u003e It reads characters from the input sequence, starting at the append position, and appends them to the given string buffer.  It stops after reading the last character preceding the previous match, that is, the character at index  {@link #start()}\u0026nbsp;\u003ctt\u003e-\u003c/tt\u003e\u0026nbsp;\u003ctt\u003e1\u003c/tt\u003e.  \u003c/p\u003e\u003c/li\u003e \u003cli\u003e\u003cp\u003e It appends the given replacement string to the string buffer. \u003c/p\u003e\u003c/li\u003e \u003cli\u003e\u003cp\u003e It sets the append position of this matcher to the index of the last character matched, plus one, that is, to  {@link #end()}. \u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e \u003cp\u003e The replacement string may contain references to subsequences captured during the previous match: Each occurrence of \u003ctt\u003e${\u003c/tt\u003e\u003ci\u003ename\u003c/i\u003e\u003ctt\u003e}\u003c/tt\u003e or \u003ctt\u003e$\u003c/tt\u003e\u003ci\u003eg\u003c/i\u003e will be replaced by the result of evaluating the corresponding {@link #group(String) group(name)} or {@link #group(int) group(g)\u003c/tt\u003e}respectively. For  \u003ctt\u003e$\u003c/tt\u003e\u003ci\u003eg\u003c/i\u003e\u003ctt\u003e\u003c/tt\u003e, the first number after the \u003ctt\u003e$\u003c/tt\u003e is always treated as part of the group reference. Subsequent numbers are incorporated into g if they would form a legal group reference. Only the numerals \u00270\u0027 through \u00279\u0027 are considered as potential components of the group reference. If the second group matched the string \u003ctt\u003e\"foo\"\u003c/tt\u003e, for example, then passing the replacement string \u003ctt\u003e\"$2bar\"\u003c/tt\u003e would cause \u003ctt\u003e\"foobar\"\u003c/tt\u003e to be appended to the string buffer. A dollar sign (\u003ctt\u003e$\u003c/tt\u003e) may be included as a literal in the replacement string by preceding it with a backslash (\u003ctt\u003e\\$\u003c/tt\u003e). \u003cp\u003e Note that backslashes (\u003ctt\u003e\\\u003c/tt\u003e) and dollar signs (\u003ctt\u003e$\u003c/tt\u003e) in the replacement string may cause the results to be different than if it were being treated as a literal replacement string. Dollar signs may be treated as references to captured subsequences as described above, and backslashes are used to escape literal characters in the replacement string. \u003cp\u003e This method is intended to be used in a loop together with the {@link #appendTail appendTail} and {@link #find find} methods.  Thefollowing code, for example, writes \u003ctt\u003eone dog two dogs in the yard\u003c/tt\u003e to the standard-output stream: \u003c/p\u003e \u003cblockquote\u003e\u003cpre\u003e Pattern p \u003d Pattern.compile(\"cat\"); Matcher m \u003d p.matcher(\"one cat two cats in the yard\"); StringBuffer sb \u003d new StringBuffer(); while (m.find()) { m.appendReplacement(sb, \"dog\"); } m.appendTail(sb); System.out.println(sb.toString());\u003c/pre\u003e\u003c/blockquote\u003e\n * @param sb The target string buffer\n * @param replacement The replacement string\n * @return  This matcher\n * @throws IllegalStateException If no match has yet been attempted, or if the previous match operation failed\n * @throws IllegalArgumentException If the replacement string refers to a named-capturing group that does not exist in the pattern\n * @throws IndexOutOfBoundsException If the replacement string refers to a capturing group that does not exist in the pattern\n */\n","tf":{"freq":{"foo":1,"occurr":1,"matcher":4,"fail":1,"given":2,"oper":1,"refer":7,"sequenc":1,"blockquot":2,"nbsp":2,"plus":1,"form":1,"charact":5,"numer":1,"alway":1,"describ":1,"number":2,"tail":3,"non":1,"system":1,"start":2,"will":1,"bar":1,"posit":2,"compil":1,"stream":1,"correspond":1,"link":6,"use":2,"thefollow":1,"consid":1,"loop":1,"write":1,"dollar":3,"end":1,"note":1,"may":4,"previous":3,"potenti":1,"preced":2,"differ":1,"compon":1,"pattern":4,"string":19,"exampl":2,"method":3,"part":1,"dog":3,"bound":1,"respect":1,"yet":1,"last":2,"second":1,"incorpor":1,"perform":1,"buffer":6,"println":1,"action":1,"captur":4,"follow":1,"argument":1,"append":11,"index":3,"liter":3,"except":3,"foobar":1,"togeth":1,"sign":3,"input":1,"contain":1,"match":6,"output":1,"treat":3,"attempt":1,"legal":1,"result":2,"stop":1,"cat":3,"yard":2,"one":3,"state":1,"escap":1,"backslash":3,"name":3,"read":2,"subsequ":3,"exist":2,"find":3,"includ":1,"standard":1,"evalu":1,"illeg":2,"pass":1,"two":2,"termin":1,"caus":2,"pre":2,"replac":15,"target":1,"group":10,"intend":1,"first":1,"step":1},"maxFreq":19,"totalTerms":241},"loc":98}