{"id":20371,"className":"java.util.ResourceBundle$Control","methodName":"getCandidateLocales","signature":"\u003cjava.util.ResourceBundle$Control: java.util.List\u003cjava.util.Locale\u003e getCandidateLocales(java.lang.String,java.util.Locale)\u003e","javadoc":"/** \n * Returns a \u003ccode\u003eList\u003c/code\u003e of \u003ccode\u003eLocale\u003c/code\u003es as candidate locales for \u003ccode\u003ebaseName\u003c/code\u003e and \u003ccode\u003elocale\u003c/code\u003e. This method is called by the \u003ccode\u003eResourceBundle.getBundle\u003c/code\u003e factory method each time the factory method tries finding a resource bundle for a target \u003ccode\u003eLocale\u003c/code\u003e. \u003cp\u003eThe sequence of the candidate locales also corresponds to the runtime resource lookup path (also known as the \u003cI\u003eparent chain\u003c/I\u003e), if the corresponding resource bundles for the candidate locales exist and their parents are not defined by loaded resource bundles themselves.  The last element of the list must be a  {@linkplain Locale#ROOT root locale} if it is desired tohave the base bundle as the terminal of the parent chain. \u003cp\u003eIf the given locale is equal to \u003ccode\u003eLocale.ROOT\u003c/code\u003e (the root locale), a \u003ccode\u003eList\u003c/code\u003e containing only the root \u003ccode\u003eLocale\u003c/code\u003e must be returned. In this case, the \u003ccode\u003eResourceBundle.getBundle\u003c/code\u003e factory method loads only the base bundle as the resulting resource bundle. \u003cp\u003eIt is not a requirement to return an immutable (unmodifiable) \u003ccode\u003eList\u003c/code\u003e. However, the returned \u003ccode\u003eList\u003c/code\u003e must not be mutated after it has been returned by \u003ccode\u003egetCandidateLocales\u003c/code\u003e. \u003cp\u003eThe default implementation returns a \u003ccode\u003eList\u003c/code\u003e containing \u003ccode\u003eLocale\u003c/code\u003es using the rules described below.  In the description below, \u003cem\u003eL\u003c/em\u003e, \u003cem\u003eS\u003c/em\u003e, \u003cem\u003eC\u003c/em\u003e and \u003cem\u003eV\u003c/em\u003e respectively represent non-empty language, script, country, and variant.  For example, [\u003cem\u003eL\u003c/em\u003e, \u003cem\u003eC\u003c/em\u003e] represents a \u003ccode\u003eLocale\u003c/code\u003e that has non-empty values only for language and country.  The form \u003cem\u003eL\u003c/em\u003e(\"xx\") represents the (non-empty) language value is \"xx\".  For all cases, \u003ccode\u003eLocale\u003c/code\u003es whose final component values are empty strings are omitted. \u003col\u003e\u003cli\u003eFor an input \u003ccode\u003eLocale\u003c/code\u003e with an empty script value, append candidate \u003ccode\u003eLocale\u003c/code\u003es by omitting the final component one by one as below: \u003cul\u003e \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e, \u003cem\u003eC\u003c/em\u003e, \u003cem\u003eV\u003c/em\u003e] \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e, \u003cem\u003eC\u003c/em\u003e] \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e] \u003cli\u003e \u003ccode\u003eLocale.ROOT\u003c/code\u003e \u003c/ul\u003e \u003cli\u003eFor an input \u003ccode\u003eLocale\u003c/code\u003e with a non-empty script value, append candidate \u003ccode\u003eLocale\u003c/code\u003es by omitting the final component up to language, then append candidates generated from the \u003ccode\u003eLocale\u003c/code\u003e with country and variant restored: \u003cul\u003e \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e, \u003cem\u003eS\u003c/em\u003e, \u003cem\u003eC\u003c/em\u003e, \u003cem\u003eV\u003c/em\u003e] \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e, \u003cem\u003eS\u003c/em\u003e, \u003cem\u003eC\u003c/em\u003e] \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e, \u003cem\u003eS\u003c/em\u003e] \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e, \u003cem\u003eC\u003c/em\u003e, \u003cem\u003eV\u003c/em\u003e] \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e, \u003cem\u003eC\u003c/em\u003e] \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e] \u003cli\u003e \u003ccode\u003eLocale.ROOT\u003c/code\u003e \u003c/ul\u003e \u003cli\u003eFor an input \u003ccode\u003eLocale\u003c/code\u003e with a variant value consisting of multiple subtags separated by underscore, generate candidate \u003ccode\u003eLocale\u003c/code\u003es by omitting the variant subtags one by one, then insert them after every occurence of \u003ccode\u003e Locale\u003c/code\u003es with the full variant value in the original list.  For example, if the the variant consists of two subtags \u003cem\u003eV1\u003c/em\u003e and \u003cem\u003eV2\u003c/em\u003e: \u003cul\u003e \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e, \u003cem\u003eS\u003c/em\u003e, \u003cem\u003eC\u003c/em\u003e, \u003cem\u003eV1\u003c/em\u003e, \u003cem\u003eV2\u003c/em\u003e] \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e, \u003cem\u003eS\u003c/em\u003e, \u003cem\u003eC\u003c/em\u003e, \u003cem\u003eV1\u003c/em\u003e] \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e, \u003cem\u003eS\u003c/em\u003e, \u003cem\u003eC\u003c/em\u003e] \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e, \u003cem\u003eS\u003c/em\u003e] \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e, \u003cem\u003eC\u003c/em\u003e, \u003cem\u003eV1\u003c/em\u003e, \u003cem\u003eV2\u003c/em\u003e] \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e, \u003cem\u003eC\u003c/em\u003e, \u003cem\u003eV1\u003c/em\u003e] \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e, \u003cem\u003eC\u003c/em\u003e] \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e] \u003cli\u003e \u003ccode\u003eLocale.ROOT\u003c/code\u003e \u003c/ul\u003e \u003cli\u003eSpecial cases for Chinese.  When an input \u003ccode\u003eLocale\u003c/code\u003e has the language \"zh\" (Chinese) and an empty script value, either \"Hans\" (Simplified) or \"Hant\" (Traditional) might be supplied, depending on the country. When the country is \"CN\" (China) or \"SG\" (Singapore), \"Hans\" is supplied. When the country is \"HK\" (Hong Kong SAR China), \"MO\" (Macau SAR China), or \"TW\" (Taiwan), \"Hant\" is supplied.  For all other countries or when the country is empty, no script is supplied.  For example, for \u003ccode\u003eLocale(\"zh\", \"CN\") \u003c/code\u003e, the candidate list will be: \u003cul\u003e \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e(\"zh\"), \u003cem\u003eS\u003c/em\u003e(\"Hans\"), \u003cem\u003eC\u003c/em\u003e(\"CN\")] \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e(\"zh\"), \u003cem\u003eS\u003c/em\u003e(\"Hans\")] \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e(\"zh\"), \u003cem\u003eC\u003c/em\u003e(\"CN\")] \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e(\"zh\")] \u003cli\u003e \u003ccode\u003eLocale.ROOT\u003c/code\u003e \u003c/ul\u003e For \u003ccode\u003eLocale(\"zh\", \"TW\")\u003c/code\u003e, the candidate list will be: \u003cul\u003e \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e(\"zh\"), \u003cem\u003eS\u003c/em\u003e(\"Hant\"), \u003cem\u003eC\u003c/em\u003e(\"TW\")] \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e(\"zh\"), \u003cem\u003eS\u003c/em\u003e(\"Hant\")] \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e(\"zh\"), \u003cem\u003eC\u003c/em\u003e(\"TW\")] \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e(\"zh\")] \u003cli\u003e \u003ccode\u003eLocale.ROOT\u003c/code\u003e \u003c/ul\u003e \u003cli\u003eSpecial cases for Norwegian.  Both \u003ccode\u003eLocale(\"no\", \"NO\", \"NY\")\u003c/code\u003e and \u003ccode\u003eLocale(\"nn\", \"NO\")\u003c/code\u003e represent Norwegian Nynorsk.  When a locale\u0027s language is \"nn\", the standard candidate list is generated up to [\u003cem\u003eL\u003c/em\u003e(\"nn\")], and then the following candidates are added: \u003cul\u003e\u003cli\u003e [\u003cem\u003eL\u003c/em\u003e(\"no\"), \u003cem\u003eC\u003c/em\u003e(\"NO\"), \u003cem\u003eV\u003c/em\u003e(\"NY\")] \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e(\"no\"), \u003cem\u003eC\u003c/em\u003e(\"NO\")] \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e(\"no\")] \u003cli\u003e \u003ccode\u003eLocale.ROOT\u003c/code\u003e \u003c/ul\u003e If the locale is exactly \u003ccode\u003eLocale(\"no\", \"NO\", \"NY\")\u003c/code\u003e, it is first converted to \u003ccode\u003eLocale(\"nn\", \"NO\")\u003c/code\u003e and then the above procedure is followed. \u003cp\u003eAlso, Java treats the language \"no\" as a synonym of Norwegian Bokm\u0026#xE5;l \"nb\".  Except for the single case \u003ccode\u003eLocale(\"no\", \"NO\", \"NY\")\u003c/code\u003e (handled above), when an input \u003ccode\u003eLocale\u003c/code\u003e has language \"no\" or \"nb\", candidate \u003ccode\u003eLocale\u003c/code\u003es with language code \"no\" and \"nb\" are interleaved, first using the requested language, then using its synonym. For example, \u003ccode\u003eLocale(\"nb\", \"NO\", \"POSIX\")\u003c/code\u003e generates the following candidate list: \u003cul\u003e \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e(\"nb\"), \u003cem\u003eC\u003c/em\u003e(\"NO\"), \u003cem\u003eV\u003c/em\u003e(\"POSIX\")] \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e(\"no\"), \u003cem\u003eC\u003c/em\u003e(\"NO\"), \u003cem\u003eV\u003c/em\u003e(\"POSIX\")] \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e(\"nb\"), \u003cem\u003eC\u003c/em\u003e(\"NO\")] \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e(\"no\"), \u003cem\u003eC\u003c/em\u003e(\"NO\")] \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e(\"nb\")] \u003cli\u003e [\u003cem\u003eL\u003c/em\u003e(\"no\")] \u003cli\u003e \u003ccode\u003eLocale.ROOT\u003c/code\u003e \u003c/ul\u003e \u003ccode\u003eLocale(\"no\", \"NO\", \"POSIX\")\u003c/code\u003e would generate the same list except that locales with \"no\" would appear before the corresponding locales with \"nb\".\u003c/li\u003e \u003c/li\u003e \u003c/ol\u003e \u003cp\u003eThe default implementation uses an  {@link ArrayList} thatoverriding implementations may modify before returning it to the caller. However, a subclass must not modify it after it has been returned by \u003ccode\u003egetCandidateLocales\u003c/code\u003e. \u003cp\u003eFor example, if the given \u003ccode\u003ebaseName\u003c/code\u003e is \"Messages\" and the given \u003ccode\u003elocale\u003c/code\u003e is \u003ccode\u003eLocale(\"ja\",\u0026nbsp;\"\",\u0026nbsp;\"XX\")\u003c/code\u003e, then a \u003ccode\u003eList\u003c/code\u003e of \u003ccode\u003eLocale\u003c/code\u003es: \u003cpre\u003e Locale(\"ja\", \"\", \"XX\") Locale(\"ja\") Locale.ROOT \u003c/pre\u003e is returned. And if the resource bundles for the \"ja\" and \"\" \u003ccode\u003eLocale\u003c/code\u003es are found, then the runtime resource lookup path (parent chain) is: \u003cpre\u003e Messages_ja -\u003e Messages \u003c/pre\u003e\n * @param baseName the base name of the resource bundle, a fully qualified class name\n * @param locale the locale for which a resource bundle is desired\n * @return a \u003ccode\u003eList\u003c/code\u003e of candidate\u003ccode\u003eLocale\u003c/code\u003es for the given \u003ccode\u003elocale\u003c/code\u003e\n * @exception NullPointerException if \u003ccode\u003ebaseName\u003c/code\u003e or \u003ccode\u003elocale\u003c/code\u003e is \u003ccode\u003enull\u003c/code\u003e\n */\n","tf":{"freq":{"appear":1,"singl":1,"languag":10,"thatoverrid":1,"desir":2,"lookup":2,"time":1,"given":4,"sequenc":1,"nbsp":2,"element":1,"form":1,"multipl":1,"runtim":2,"describ":1,"parent":4,"procedur":1,"tradit":1,"non":4,"will":2,"pointer":1,"macau":1,"load":2,"nynorsk":1,"array":1,"caller":1,"linkplain":1,"subtag":3,"might":1,"singapor":1,"correspond":3,"link":1,"interleav":1,"use":4,"variant":6,"factori":3,"may":1,"repres":4,"messag":3,"taiwan":1,"fulli":1,"empti":8,"unmodifi":1,"either":1,"compon":3,"norwegian":3,"chain":3,"omit":4,"bokm":1,"string":1,"base":7,"exampl":5,"method":4,"insert":1,"respect":1,"hong":1,"han":4,"last":1,"synonym":2,"root":3,"kong":1,"must":4,"chines":2,"requir":1,"request":1,"exact":1,"howev":2,"everi":1,"follow":3,"china":3,"append":3,"except":4,"whose":1,"consist":2,"descript":1,"immut":1,"candid":17,"script":5,"simplifi":1,"input":5,"separ":1,"contain":2,"subclass":1,"restor":1,"tohav":1,"known":1,"bundl":13,"countri":8,"treat":1,"result":1,"call":1,"defin":1,"hant":4,"one":4,"convert":1,"resourc":11,"full":1,"rule":1,"name":6,"path":2,"valu":8,"exist":1,"find":1,"standard":1,"depend":1,"origin":1,"equal":1,"list":15,"suppli":4,"mutat":1,"underscor":1,"handl":1,"two":1,"termin":1,"pre":4,"generat":5,"modifi":2,"target":1,"ad":1,"java":1,"special":2,"local":61,"first":2,"also":3,"qualifi":1,"found":1,"occur":1},"maxFreq":61,"totalTerms":382},"loc":6}