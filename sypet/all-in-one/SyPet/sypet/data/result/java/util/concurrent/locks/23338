{"id":23338,"className":"java.util.concurrent.locks.Condition","methodName":"awaitNanos","signature":"\u003cjava.util.concurrent.locks.Condition: long awaitNanos(long)\u003e","javadoc":"/** \n * Causes the current thread to wait until it is signalled or interrupted, or the specified waiting time elapses. \u003cp\u003eThe lock associated with this condition is atomically released and the current thread becomes disabled for thread scheduling purposes and lies dormant until \u003cem\u003eone\u003c/em\u003e of five things happens: \u003cul\u003e \u003cli\u003eSome other thread invokes the  {@link #signal} method for this{@code Condition} and the current thread happens to be chosen as thethread to be awakened; or \u003cli\u003eSome other thread invokes the  {@link #signalAll} method for this{@code Condition}; or \u003cli\u003eSome other thread  {@linkplain Thread#interrupt interrupts} thecurrent thread, and interruption of thread suspension is supported; or \u003cli\u003eThe specified waiting time elapses; or \u003cli\u003eA \u0026quot;\u003cem\u003espurious wakeup\u003c/em\u003e\u0026quot; occurs. \u003c/ul\u003e \u003cp\u003eIn all cases, before this method can return the current thread must re-acquire the lock associated with this condition. When the thread returns it is \u003cem\u003eguaranteed\u003c/em\u003e to hold this lock. \u003cp\u003eIf the current thread: \u003cul\u003e \u003cli\u003ehas its interrupted status set on entry to this method; or \u003cli\u003eis  {@linkplain Thread#interrupt interrupted} while waitingand interruption of thread suspension is supported, \u003c/ul\u003e then  {@link InterruptedException} is thrown and the current thread\u0027sinterrupted status is cleared. It is not specified, in the first case, whether or not the test for interruption occurs before the lock is released. \u003cp\u003eThe method returns an estimate of the number of nanoseconds remaining to wait given the supplied  {@code nanosTimeout}value upon return, or a value less than or equal to zero if it timed out. This value can be used to determine whether and how long to re-wait in cases where the wait returns but an awaited condition still does not hold. Typical uses of this method take the following form: \u003cpre\u003e  {@code}boolean aMethod(long timeout, TimeUnit unit)  long nanos \u003d unit.toNanos(timeout); lock.lock(); try { while (!conditionBeingWaitedFor()) { if (nanos \u003c\u003d 0L) return false; nanos \u003d theCondition.awaitNanos(nanos); } // ... } finally { lock.unlock(); } }}\u003c/pre\u003e \u003cp\u003e Design note: This method requires a nanosecond argument so as to avoid truncation errors in reporting remaining times. Such precision loss would make it difficult for programmers to ensure that total waiting times are not systematically shorter than specified when re-waits occur. \u003cp\u003e\u003cb\u003eImplementation Considerations\u003c/b\u003e \u003cp\u003eThe current thread is assumed to hold the lock associated with this {@code Condition} when this method is called.It is up to the implementation to determine if this is the case and if not, how to respond. Typically, an exception will be thrown (such as  {@link IllegalMonitorStateException}) and the implementation must document that fact. \u003cp\u003eAn implementation can favor responding to an interrupt over normal method return in response to a signal, or over indicating the elapse of the specified waiting time. In either case the implementation must ensure that the signal is redirected to another waiting thread, if there is one.\n * @param nanosTimeout the maximum time to wait, in nanoseconds\n * @return an estimate of the {@code nanosTimeout} value minusthe time spent waiting upon return from this method. A positive value may be used as the argument to a subsequent call to this method to finish waiting out the desired time.  A value less than or equal to zero indicates that no time remains.\n * @throws InterruptedException if the current thread is interrupted(and interruption of thread suspension is supported)\n */\n","tf":{"freq":{"total":1,"test":1,"wait":14,"desir":1,"zero":2,"whether":2,"specifi":5,"elaps":3,"avoid":1,"time":11,"estim":2,"becom":1,"given":1,"respond":2,"wakeup":1,"thread":20,"report":1,"purpos":1,"happen":2,"quot":2,"sinterrupt":1,"awaken":1,"unlock":1,"support":3,"respons":1,"form":1,"invok":2,"hold":3,"programm":1,"number":1,"disabl":1,"will":1,"thecurr":1,"favor":1,"posit":1,"shorter":1,"upon":2,"linkplain":2,"waitingand":1,"link":4,"typic":2,"use":3,"truncat":1,"anoth":1,"nanosecond":3,"difficult":1,"ensur":2,"clear":1,"document":1,"indic":2,"associ":3,"consider":1,"current":8,"note":1,"may":1,"assum":1,"thethread":1,"either":1,"fact":1,"remain":3,"method":12,"design":1,"acquir":1,"fals":1,"atom":1,"normal":1,"must":3,"requir":1,"precis":1,"follow":1,"argument":2,"except":4,"thrown":2,"monitor":1,"spurious":1,"status":2,"finish":1,"await":3,"maximum":1,"minusth":1,"determin":2,"make":1,"thing":1,"call":2,"loss":1,"one":2,"state":1,"schedul":1,"systemat":1,"signal":5,"chosen":1,"releas":2,"redirect":1,"valu":6,"subsequ":1,"spent":1,"less":2,"condit":8,"five":1,"error":1,"entri":1,"guarante":1,"lock":8,"suppli":1,"equal":2,"still":1,"nano":10,"illeg":1,"interrupt":14,"suspens":3,"unit":3,"caus":1,"take":1,"pre":2,"first":1,"lie":1,"timeout":5,"occur":3,"dormant":1},"maxFreq":20,"totalTerms":284},"loc":0}