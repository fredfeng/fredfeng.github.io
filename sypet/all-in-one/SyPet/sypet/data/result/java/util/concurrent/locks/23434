{"id":23434,"className":"java.util.concurrent.locks.AbstractQueuedLongSynchronizer","methodName":"hasQueuedPredecessors","signature":"\u003cjava.util.concurrent.locks.AbstractQueuedLongSynchronizer: boolean hasQueuedPredecessors()\u003e","javadoc":"/** \n * Queries whether any threads have been waiting to acquire longer than the current thread. \u003cp\u003eAn invocation of this method is equivalent to (but may be more efficient than): \u003cpre\u003e  {@code getFirstQueuedThread() !\u003d Thread.currentThread() \u0026\u0026 hasQueuedThreads()}\u003c/pre\u003e \u003cp\u003eNote that because cancellations due to interrupts and timeouts may occur at any time, a  {@code true} return does notguarantee that some other thread will acquire before the current thread.  Likewise, it is possible for another thread to win a race to enqueue after this method has returned  {@code false}, due to the queue being empty. \u003cp\u003eThis method is designed to be used by a fair synchronizer to avoid \u003ca href\u003d\"AbstractQueuedSynchronizer#barging\"\u003ebarging\u003c/a\u003e. Such a synchronizer\u0027s  {@link #tryAcquire} method should return{@code false}, and its  {@link #tryAcquireShared} method shouldreturn a negative value, if this method returns  {@code true}(unless this is a reentrant acquire).  For example, the  {@code tryAcquire} method for a fair, reentrant, exclusive modesynchronizer might look like this: \u003cpre\u003e  {@code}protected boolean tryAcquire(int arg)  if (isHeldExclusively()) { // A reentrant acquire; increment hold count return true; } else if (hasQueuedPredecessors()) { return false; } else { // try to acquire normally } }}\u003c/pre\u003e\n * @return {@code true} if there is a queued thread preceding thecurrent thread, and  {@code false} if the current threadis at the head of the queue or the queue is empty\n * @since 1.7\n */\n","tf":{"freq":{"acquir":9,"fals":4,"queue":3,"count":1,"normal":1,"enqueu":1,"possibl":1,"cancel":1,"wait":1,"race":1,"reentrant":3,"whether":1,"arg":1,"avoid":1,"time":1,"equival":1,"thread":11,"longer":1,"effici":1,"barg":2,"head":1,"href":1,"threadi":1,"increment":1,"hold":1,"notguarante":1,"like":1,"fair":2,"els":2,"invoc":1,"queri":1,"likewis":1,"thecurr":1,"will":1,"due":2,"negat":1,"might":1,"link":2,"use":1,"anoth":1,"predecessor":2,"share":1,"unless":1,"current":4,"valu":1,"exclus":2,"note":1,"look":1,"held":1,"may":2,"queu":6,"true":4,"win":1,"modesynchron":1,"interrupt":1,"empti":2,"shouldreturn":1,"preced":1,"pre":4,"exampl":1,"method":7,"first":1,"timeout":1,"design":1,"occur":1},"maxFreq":11,"totalTerms":119},"loc":10}