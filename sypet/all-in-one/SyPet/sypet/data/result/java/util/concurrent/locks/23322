{"id":23322,"className":"java.util.concurrent.locks.ReentrantLock","methodName":"tryLock","signature":"\u003cjava.util.concurrent.locks.ReentrantLock: boolean tryLock()\u003e","javadoc":"/** \n * Acquires the lock only if it is not held by another thread at the time of invocation. \u003cp\u003eAcquires the lock if it is not held by another thread and returns immediately with the value  {@code true}, setting the lock hold count to one. Even when this lock has been set to use a fair ordering policy, a call to  {@code tryLock()} \u003cem\u003ewill\u003c/em\u003eimmediately acquire the lock if it is available, whether or not other threads are currently waiting for the lock. This \u0026quot;barging\u0026quot; behavior can be useful in certain circumstances, even though it breaks fairness. If you want to honor the fairness setting for this lock, then use {@link #tryLock(long,TimeUnit) tryLock(0, TimeUnit.SECONDS) }which is almost equivalent (it also detects interruption). \u003cp\u003e If the current thread already holds this lock then the hold count is incremented by one and the method returns  {@code true}. \u003cp\u003eIf the lock is held by another thread then this method will return immediately with the value  {@code false}.\n * @return {@code true} if the lock was free and was acquired by thecurrent thread, or the lock was already held by the current thread; and  {@code false} otherwise\n */\n","tf":{"freq":{"otherwis":1,"fals":2,"acquir":4,"call":1,"count":2,"behavior":1,"link":1,"one":2,"use":3,"anoth":3,"wait":1,"though":1,"whether":1,"almost":1,"free":1,"time":3,"order":1,"equival":1,"thread":7,"current":3,"valu":2,"immedi":3,"barg":1,"quot":2,"want":1,"increment":1,"detect":1,"held":4,"honor":1,"hold":3,"lock":15,"true":3,"circumst":1,"avail":1,"polici":1,"fair":3,"interrupt":1,"invoc":1,"unit":2,"thecurr":1,"will":2,"method":2,"alreadi":2,"even":2,"certain":1,"also":1},"maxFreq":15,"totalTerms":98},"loc":3}