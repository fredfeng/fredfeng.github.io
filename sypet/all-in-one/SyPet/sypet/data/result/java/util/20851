{"id":20851,"className":"java.util.Comparator","methodName":"equals","signature":"\u003cjava.util.Comparator: boolean equals(java.lang.Object)\u003e","javadoc":"/** \n * Indicates whether some other object is \u0026quot;equal to\u0026quot; this comparator.  This method must obey the general contract of {@link Object#equals(Object)}.  Additionally, this method can return \u003ctt\u003etrue\u003c/tt\u003e \u003ci\u003eonly\u003c/i\u003e if the specified object is also a comparator and it imposes the same ordering as this comparator.  Thus, \u003ccode\u003ecomp1.equals(comp2)\u003c/code\u003e implies that \u003ctt\u003esgn(comp1.compare(o1, o2))\u003d\u003dsgn(comp2.compare(o1, o2))\u003c/tt\u003e for every object reference \u003ctt\u003eo1\u003c/tt\u003e and \u003ctt\u003eo2\u003c/tt\u003e.\u003cp\u003e Note that it is \u003ci\u003ealways\u003c/i\u003e safe \u003ci\u003enot\u003c/i\u003e to override \u003ctt\u003eObject.equals(Object)\u003c/tt\u003e.  However, overriding this method may, in some cases, improve performance by allowing programs to determine that two distinct comparators impose the same order.\n * @param obj   the reference object with which to compare.\n * @return  \u003ccode\u003etrue\u003c/code\u003e only if the specified object is alsoa comparator and it imposes the same ordering as this comparator.\n * @see Object#equals(Object)\n * @see Object#hashCode()\n */\n","tf":{"freq":{"allow":1,"link":1,"perform":1,"object":12,"must":1,"whether":1,"distinct":1,"specifi":2,"indic":1,"order":3,"refer":2,"impli":1,"howev":1,"quot":2,"everi":1,"note":1,"safe":1,"addit":1,"may":1,"comp":4,"hash":1,"contract":1,"thus":1,"alway":1,"alsoa":1,"true":2,"equal":6,"general":1,"impos":3,"sgn":2,"two":1,"obey":1,"program":1,"determin":1,"obj":1,"improv":1,"method":3,"compar":9,"also":1},"maxFreq":12,"totalTerms":77},"loc":0}