{"id":23925,"className":"java.util.jar.JarInputStream","methodName":"read","signature":"\u003cjava.util.jar.JarInputStream: int read(byte[],int,int)\u003e","javadoc":"/** \n * Reads from the current JAR file entry into an array of bytes. If \u003ccode\u003elen\u003c/code\u003e is not zero, the method blocks until some input is available; otherwise, no bytes are read and \u003ccode\u003e0\u003c/code\u003e is returned. If verification has been enabled, any invalid signature on the current entry will be reported at some point before the end of the entry is reached.\n * @param b the buffer into which the data is read\n * @param off the start offset in the destination array \u003ccode\u003eb\u003c/code\u003e\n * @param len the maximum number of bytes to read\n * @return the actual number of bytes read, or -1 if the end of theentry is reached\n * @exception NullPointerException If \u003ccode\u003eb\u003c/code\u003e is \u003ccode\u003enull\u003c/code\u003e.\n * @exception IndexOutOfBoundsException If \u003ccode\u003eoff\u003c/code\u003e is negative,\u003ccode\u003elen\u003c/code\u003e is negative, or \u003ccode\u003elen\u003c/code\u003e is greater than \u003ccode\u003eb.length - off\u003c/code\u003e\n * @exception ZipException if a ZIP file error has occurred\n * @exception IOException if an I/O error has occurred\n * @exception SecurityException if any of the jar file entriesare incorrectly signed.\n */\n","tf":{"freq":{"otherwis":1,"verif":1,"greater":1,"data":1,"block":1,"zero":1,"signatur":1,"buffer":1,"reach":2,"invalid":1,"jar":1,"file":3,"length":1,"current":2,"report":1,"read":6,"incorrect":1,"offset":1,"end":2,"zip":1,"index":1,"except":10,"error":2,"entri":3,"enabl":1,"number":2,"avail":1,"len":4,"sign":1,"theentri":1,"point":1,"input":1,"secur":1,"start":1,"maximum":1,"entriesar":1,"will":1,"pointer":1,"actual":1,"negat":2,"method":1,"bound":1,"occur":2,"destin":1,"array":2},"maxFreq":10,"totalTerms":74},"loc":12}