{"id":23356,"className":"java.util.concurrent.locks.Lock","methodName":"tryLock","signature":"\u003cjava.util.concurrent.locks.Lock: boolean tryLock(long,java.util.concurrent.TimeUnit)\u003e","javadoc":"/** \n * Acquires the lock if it is free within the given waiting time and the current thread has not been  {@linkplain Thread#interrupt interrupted}. \u003cp\u003eIf the lock is available this method returns immediately with the value  {@code true}. If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens: \u003cul\u003e \u003cli\u003eThe lock is acquired by the current thread; or \u003cli\u003eSome other thread  {@linkplain Thread#interrupt interrupts} thecurrent thread, and interruption of lock acquisition is supported; or \u003cli\u003eThe specified waiting time elapses \u003c/ul\u003e \u003cp\u003eIf the lock is acquired then the value  {@code true} is returned.\u003cp\u003eIf the current thread: \u003cul\u003e \u003cli\u003ehas its interrupted status set on entry to this method; or \u003cli\u003eis  {@linkplain Thread#interrupt interrupted} while acquiringthe lock, and interruption of lock acquisition is supported, \u003c/ul\u003e then  {@link InterruptedException} is thrown and the current thread\u0027sinterrupted status is cleared. \u003cp\u003eIf the specified waiting time elapses then the value  {@code false}is returned. If the time is less than or equal to zero, the method will not wait at all. \u003cp\u003e\u003cb\u003eImplementation Considerations\u003c/b\u003e \u003cp\u003eThe ability to interrupt a lock acquisition in some implementations may not be possible, and if possible may be an expensive operation. The programmer should be aware that this may be the case. An implementation should document when this is the case. \u003cp\u003eAn implementation can favor responding to an interrupt over normal method return, or reporting a timeout. \u003cp\u003eA  {@code Lock} implementation may be able to detecterroneous use of the lock, such as an invocation that would cause deadlock, and may throw an (unchecked) exception in such circumstances. The circumstances and the exception type must be documented by that {@code Lock} implementation.\n * @param time the maximum time to wait for the lock\n * @param unit the time unit of the {@code time} argument\n * @return {@code true} if the lock was acquired and {@code false}if the waiting time elapsed before the lock was acquired\n * @throws InterruptedException if the current thread is interruptedwhile acquiring the lock (and interruption of lock acquisition is supported)\n */\n","tf":{"freq":{"acquir":6,"fals":2,"detecterron":1,"normal":1,"uncheck":1,"possibl":2,"abl":1,"wait":6,"type":1,"zero":1,"abil":1,"must":1,"specifi":2,"elaps":3,"free":1,"time":9,"becom":1,"given":1,"oper":1,"respond":1,"thread":12,"report":1,"three":1,"purpos":1,"happen":1,"sinterrupt":1,"argument":1,"acquiringth":1,"except":4,"thrown":1,"support":3,"status":2,"programm":1,"circumst":2,"avail":2,"invoc":1,"disabl":1,"maximum":1,"thecurr":1,"will":1,"favor":1,"thing":1,"linkplain":3,"one":1,"link":1,"acquisit":4,"use":1,"schedul":1,"clear":1,"interruptedwhil":1,"document":2,"consider":1,"current":6,"valu":3,"immedi":1,"less":1,"deadlock":1,"may":5,"entri":1,"lock":18,"true":3,"equal":1,"interrupt":14,"unit":2,"caus":1,"awar":1,"expens":1,"method":4,"within":1,"timeout":1,"lie":1,"dormant":1},"maxFreq":18,"totalTerms":167},"loc":0}