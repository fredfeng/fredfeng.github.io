{"id":23644,"className":"java.util.zip.Deflater","methodName":"deflate","signature":"\u003cjava.util.zip.Deflater: int deflate(byte[],int,int,int)\u003e","javadoc":"/** \n * Compresses the input data and fills the specified buffer with compressed data. Returns actual number of bytes of data compressed. \u003cp\u003eCompression flush mode is one of the following three modes: \u003cul\u003e \u003cli\u003e {@link #NO_FLUSH}: allows the deflater to decide how much data to accumulate, before producing output, in order to achieve the best compression (should be used in normal use scenario). A return value of 0 in this flush mode indicates that  {@link #needsInput()} shouldbe called in order to determine if more input data is required. \u003cli\u003e {@link #SYNC_FLUSH}: all pending output in the deflater is flushed, to the specified output buffer, so that an inflater that works on compressed data can get all input data available so far (In particular the  {@link #needsInput()} returns {@code true} after this invocationif enough output space is provided). Flushing with  {@link #SYNC_FLUSH}may degrade compression for some compression algorithms and so it should be used only when necessary. \u003cli\u003e {@link #FULL_FLUSH}: all pending output is flushed out as with {@link #SYNC_FLUSH}. The compression state is reset so that the inflater that works on the compressed output data can restart from this point if previous compressed data has been damaged or if random access is desired. Using  {@link #FULL_FLUSH} too often can seriously degradecompression. \u003c/ul\u003e \u003cp\u003eIn the case of  {@link #FULL_FLUSH} or {@link #SYNC_FLUSH}, if the return value is  {@code len}, the space available in output buffer  {@code b}, this method should be invoked again with the same {@code flush} parameter and more output space.\n * @param b the buffer for the compressed data\n * @param off the start offset of the data\n * @param len the maximum number of bytes of compressed data\n * @param flush the compression flush mode\n * @return the actual number of bytes of compressed data written tothe output buffer\n * @throws IllegalArgumentException if the flush mode is invalid\n * @since 1.7\n */\n","tf":{"freq":{"need":2,"degradecompress":1,"normal":1,"particular":1,"inflat":2,"toth":1,"desir":1,"enough":1,"necessari":1,"specifi":2,"buffer":5,"requir":1,"invalid":1,"three":1,"reset":1,"serious":1,"follow":1,"argument":1,"work":2,"except":1,"invok":1,"random":1,"far":1,"number":3,"avail":2,"provid":1,"much":1,"accumul":1,"compress":15,"shouldb":1,"input":5,"scenario":1,"start":1,"maximum":1,"often":1,"determin":1,"output":9,"call":1,"allow":1,"link":10,"one":1,"state":1,"data":13,"use":4,"space":3,"mode":5,"algorithm":1,"order":2,"indic":1,"written":1,"best":1,"valu":2,"offset":1,"pend":2,"restart":1,"may":1,"invocationif":1,"previous":1,"fill":1,"paramet":1,"true":1,"produc":1,"len":2,"access":1,"illeg":1,"achiev":1,"damag":1,"point":1,"flush":9,"decid":1,"actual":2,"degrad":1,"method":1,"deflat":3},"maxFreq":15,"totalTerms":156},"loc":15}