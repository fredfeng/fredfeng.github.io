{"id":24269,"className":"java.util.prefs.AbstractPreferences","methodName":"flush","signature":"\u003cjava.util.prefs.AbstractPreferences: void flush()\u003e","javadoc":"/** \n * Implements the \u003ctt\u003eflush\u003c/tt\u003e method as per the specification in {@link Preferences#flush()}. \u003cp\u003eThis implementation calls a recursive helper method that locks this node, invokes flushSpi() on it, unlocks this node, and recursively invokes this method on each \"cached child.\"  A cached child is a child of this node that has been created in this VM and not subsequently removed.  In effect, this method does a depth first traversal of the \"cached subtree\" rooted at this node, calling flushSpi() on each node in the subTree while only that node is locked. Note that flushSpi() is invoked top-down. \u003cp\u003e If this method is invoked on a node that has been removed with the  {@link #removeNode()} method, flushSpi() is invoked on this node,but not on others.\n * @throws BackingStoreException if this operation cannot be completeddue to a failure in the backing store, or inability to communicate with it.\n * @see #flush()\n */\n","tf":{"freq":{"call":2,"sub":1,"store":2,"completeddu":1,"root":1,"link":2,"child":3,"tree":1,"oper":1,"spi":4,"subtre":1,"subsequ":1,"note":1,"top":1,"travers":1,"inabl":1,"except":1,"unlock":1,"helper":1,"failur":1,"creat":1,"invok":5,"lock":2,"remov":3,"back":2,"cach":3,"depth":1,"node":9,"specif":1,"flush":8,"communic":1,"per":1,"effect":1,"method":6,"prefer":1,"first":1,"recurs":2},"maxFreq":9,"totalTerms":76},"loc":3}