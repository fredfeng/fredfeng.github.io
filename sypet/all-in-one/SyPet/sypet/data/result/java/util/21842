{"id":21842,"className":"java.util.Collections","methodName":"rotate","signature":"\u003cjava.util.Collections: void rotate(java.util.List,int)\u003e","javadoc":"/** \n * Rotates the elements in the specified list by the specified distance. After calling this method, the element at index \u003ctt\u003ei\u003c/tt\u003e will be the element previously at index \u003ctt\u003e(i - distance)\u003c/tt\u003e mod \u003ctt\u003elist.size()\u003c/tt\u003e, for all values of \u003ctt\u003ei\u003c/tt\u003e between \u003ctt\u003e0\u003c/tt\u003e and \u003ctt\u003elist.size()-1\u003c/tt\u003e, inclusive.  (This method has no effect on the size of the list.) \u003cp\u003eFor example, suppose \u003ctt\u003elist\u003c/tt\u003e comprises\u003ctt\u003e [t, a, n, k, s]\u003c/tt\u003e. After invoking \u003ctt\u003eCollections.rotate(list, 1)\u003c/tt\u003e (or \u003ctt\u003eCollections.rotate(list, -4)\u003c/tt\u003e), \u003ctt\u003elist\u003c/tt\u003e will comprise \u003ctt\u003e[s, t, a, n, k]\u003c/tt\u003e. \u003cp\u003eNote that this method can usefully be applied to sublists to move one or more elements within a list while preserving the order of the remaining elements.  For example, the following idiom moves the element at index \u003ctt\u003ej\u003c/tt\u003e forward to position \u003ctt\u003ek\u003c/tt\u003e (which must be greater than or equal to \u003ctt\u003ej\u003c/tt\u003e): \u003cpre\u003e Collections.rotate(list.subList(j, k+1), -1); \u003c/pre\u003e To make this concrete, suppose \u003ctt\u003elist\u003c/tt\u003e comprises \u003ctt\u003e[a, b, c, d, e]\u003c/tt\u003e.  To move the element at index \u003ctt\u003e1\u003c/tt\u003e (\u003ctt\u003eb\u003c/tt\u003e) forward two positions, perform the following invocation: \u003cpre\u003e Collections.rotate(l.subList(1, 4), -1); \u003c/pre\u003e The resulting list is \u003ctt\u003e[a, c, d, b, e]\u003c/tt\u003e. \u003cp\u003eTo move more than one element forward, increase the absolute value of the rotation distance.  To move elements backward, use a positive shift distance. \u003cp\u003eIf the specified list is small or implements the  {@link RandomAccess} interface, this implementation exchanges the firstelement into the location it should go, and then repeatedly exchanges the displaced element into the location it should go until a displaced element is swapped into the first element.  If necessary, the process is repeated on the second and successive elements, until the rotation is complete.  If the specified list is large and doesn\u0027t implement the \u003ctt\u003eRandomAccess\u003c/tt\u003e interface, this implementation breaks the list into two sublist views around index \u003ctt\u003e-distance mod size\u003c/tt\u003e. Then the  {@link #reverse(List)} method is invoked on each sublist view,and finally it is invoked on the entire list.  For a more complete description of both algorithms, see Section 2.3 of Jon Bentley\u0027s \u003ci\u003eProgramming Pearls\u003c/i\u003e (Addison-Wesley, 1986).\n * @param list the list to be rotated.\n * @param distance the distance to rotate the list.  There are noconstraints on this value; it may be zero, negative, or greater than \u003ctt\u003elist.size()\u003c/tt\u003e.\n * @throws UnsupportedOperationException if the specified list orits list-iterator does not support the \u003ctt\u003eset\u003c/tt\u003e operation.\n * @since 1.4\n */\n","tf":{"freq":{"firstel":1,"unsupport":1,"greater":2,"second":1,"orit":1,"wesley":1,"idiom":1,"perform":1,"zero":1,"necessari":1,"must":1,"specifi":5,"compris":3,"oper":2,"forward":3,"bentley":1,"addison":1,"move":5,"follow":2,"element":13,"except":1,"index":5,"support":1,"noconstraint":1,"invok":3,"mod":2,"descript":1,"random":2,"rotat":10,"preserv":1,"absolut":1,"sublist":3,"invoc":1,"size":5,"pearl":1,"appli":1,"program":1,"distanc":7,"will":2,"negat":1,"view":2,"entir":1,"small":1,"posit":3,"make":1,"collect":4,"increas":1,"call":1,"result":1,"displac":2,"sub":2,"backward":1,"link":2,"one":2,"use":2,"repeat":2,"algorithm":1,"inclus":1,"revers":1,"order":1,"concret":1,"jon":1,"valu":3,"note":1,"complet":2,"may":1,"locat":2,"previous":1,"suppos":2,"list":25,"equal":1,"access":2,"section":1,"exchang":2,"around":1,"process":1,"two":2,"effect":1,"remain":1,"larg":1,"pre":4,"exampl":2,"method":4,"swap":1,"within":1,"iter":1,"success":1,"first":1,"shift":1},"maxFreq":25,"totalTerms":197},"loc":6}