{"id":23796,"className":"java.util.zip.GZIPInputStream","methodName":"read","signature":"\u003cjava.util.zip.GZIPInputStream: int read(byte[],int,int)\u003e","javadoc":"/** \n * Reads uncompressed data into an array of bytes. If \u003ccode\u003elen\u003c/code\u003e is not zero, the method will block until some input can be decompressed; otherwise, no bytes are read and \u003ccode\u003e0\u003c/code\u003e is returned.\n * @param buf the buffer into which the data is read\n * @param off the start offset in the destination array \u003ccode\u003eb\u003c/code\u003e\n * @param len the maximum number of bytes read\n * @return  the actual number of bytes read, or -1 if the end of thecompressed input stream is reached\n * @exception NullPointerException If \u003ccode\u003ebuf\u003c/code\u003e is \u003ccode\u003enull\u003c/code\u003e.\n * @exception IndexOutOfBoundsException If \u003ccode\u003eoff\u003c/code\u003e is negative,\u003ccode\u003elen\u003c/code\u003e is negative, or \u003ccode\u003elen\u003c/code\u003e is greater than \u003ccode\u003ebuf.length - off\u003c/code\u003e\n * @exception ZipException if the compressed input data is corrupt.\n * @exception IOException if an I/O error has occurred.\n */\n","tf":{"freq":{"otherwis":1,"stream":1,"greater":1,"data":3,"block":1,"zero":1,"corrupt":1,"buffer":1,"reach":1,"decompress":1,"length":1,"read":6,"offset":1,"end":1,"zip":1,"index":1,"except":8,"error":1,"number":2,"len":4,"compress":1,"thecompress":1,"input":3,"start":1,"maximum":1,"will":1,"pointer":1,"actual":1,"negat":2,"method":1,"uncompress":1,"bound":1,"buf":3,"occur":1,"array":2,"destin":1},"maxFreq":8,"totalTerms":60},"loc":16}