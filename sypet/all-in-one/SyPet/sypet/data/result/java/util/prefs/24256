{"id":24256,"className":"java.util.prefs.AbstractPreferences","methodName":"node","signature":"\u003cjava.util.prefs.AbstractPreferences: java.util.prefs.Preferences node(java.lang.String)\u003e","javadoc":"/** \n * Implements the \u003ctt\u003enode\u003c/tt\u003e method as per the specification in {@link Preferences#node(String)}. \u003cp\u003eThis implementation obtains this preference node\u0027s lock and checks that the node has not been removed.  If \u003ctt\u003epath\u003c/tt\u003e is \u003ctt\u003e\"\"\u003c/tt\u003e, this node is returned; if \u003ctt\u003epath\u003c/tt\u003e is \u003ctt\u003e\"/\"\u003c/tt\u003e, this node\u0027s root is returned.  If the first character in \u003ctt\u003epath\u003c/tt\u003e is not \u003ctt\u003e\u0027/\u0027\u003c/tt\u003e, the implementation breaks \u003ctt\u003epath\u003c/tt\u003e into tokens and recursively traverses the path from this node to the named node, \"consuming\" a name and a slash from \u003ctt\u003epath\u003c/tt\u003e at each step of the traversal.  At each step, the current node is locked and the node\u0027s child-cache is checked for the named node.  If it is not found, the name is checked to make sure its length does not exceed \u003ctt\u003eMAX_NAME_LENGTH\u003c/tt\u003e.  Then the  {@link #childSpi(String)}method is invoked, and the result stored in this node\u0027s child-cache. If the newly created \u003ctt\u003ePreferences\u003c/tt\u003e object\u0027s  {@link #newNode}field is \u003ctt\u003etrue\u003c/tt\u003e and there are any node change listeners, a notification event is enqueued for processing by the event dispatch thread. \u003cp\u003eWhen there are no more tokens, the last value found in the child-cache or returned by \u003ctt\u003echildSpi\u003c/tt\u003e is returned by this method.  If during the traversal, two \u003ctt\u003e\"/\"\u003c/tt\u003e tokens occur consecutively, or the final token is \u003ctt\u003e\"/\"\u003c/tt\u003e (rather than a name), an appropriate \u003ctt\u003eIllegalArgumentException\u003c/tt\u003e is thrown. \u003cp\u003e If the first character of \u003ctt\u003epath\u003c/tt\u003e is \u003ctt\u003e\u0027/\u0027\u003c/tt\u003e (indicating an absolute path name) this preference node\u0027s lock is dropped prior to breaking \u003ctt\u003epath\u003c/tt\u003e into tokens, and this method recursively traverses the path starting from the root (rather than starting from this node).  The traversal is otherwise identical to the one described for relative path names.  Dropping the lock on this node prior to commencing the traversal at the root node is essential to avoid the possibility of deadlock, as per the {@link #lock locking invariant}.\n * @param path the path name of the preference node to return.\n * @return the specified preference node.\n * @throws IllegalArgumentException if the path name is invalid (i.e.,it contains multiple consecutive slash characters, or ends with a slash character and is more than one character long).\n * @throws IllegalStateException if this node (or an ancestor) has beenremoved with the  {@link #removeNode()} method.\n */\n","tf":{"freq":{"store":1,"last":1,"root":3,"drop":2,"enqueu":1,"possibl":1,"specifi":1,"prior":2,"avoid":1,"notif":1,"invalid":1,"essenti":1,"event":2,"spi":2,"thread":1,"relat":1,"sure":1,"argument":2,"thrown":1,"except":3,"multipl":1,"charact":5,"creat":1,"invok":1,"beenremov":1,"remov":2,"describ":1,"absolut":1,"commenc":1,"invari":1,"consecut":2,"newli":1,"node":23,"obtain":1,"start":2,"contain":1,"prefer":6,"make":1,"recurs":2,"otherwis":1,"result":1,"one":2,"link":5,"state":1,"object":1,"child":5,"consum":1,"ident":1,"indic":1,"token":5,"name":9,"current":1,"path":14,"length":1,"rather":2,"valu":1,"dispatch":1,"ancestor":1,"listen":1,"end":1,"deadlock":1,"travers":6,"slash":3,"check":3,"lock":6,"exceed":1,"true":1,"cach":3,"illeg":3,"field":1,"process":1,"two":1,"specif":1,"per":2,"appropri":1,"string":2,"method":5,"chang":1,"first":2,"step":2,"occur":1,"found":2},"maxFreq":23,"totalTerms":188},"loc":15}