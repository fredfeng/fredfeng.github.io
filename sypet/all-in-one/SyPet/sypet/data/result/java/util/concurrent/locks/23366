{"id":23366,"className":"java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock","methodName":"tryLock","signature":"\u003cjava.util.concurrent.locks.ReentrantReadWriteLock$ReadLock: boolean tryLock()\u003e","javadoc":"/** \n * Acquires the read lock only if the write lock is not held by another thread at the time of invocation. \u003cp\u003eAcquires the read lock if the write lock is not held by another thread and returns immediately with the value {@code true}. Even when this lock has been set to use a fair ordering policy, a call to  {@code tryLock()}\u003cem\u003ewill\u003c/em\u003e immediately acquire the read lock if it is available, whether or not other threads are currently waiting for the read lock.  This \u0026quot;barging\u0026quot; behavior can be useful in certain circumstances, even though it breaks fairness. If you want to honor the fairness setting for this lock, then use  {@link #tryLock(long,TimeUnit) tryLock(0, TimeUnit.SECONDS) } which is almost equivalent(it also detects interruption). \u003cp\u003eIf the write lock is held by another thread then this method will return immediately with the value {@code false}.\n * @return {@code true} if the read lock was acquired\n */\n","tf":{"freq":{"fals":1,"acquir":4,"call":1,"behavior":1,"link":1,"use":3,"anoth":3,"wait":1,"though":1,"whether":1,"almost":1,"time":3,"order":1,"equival":1,"thread":4,"write":3,"current":1,"read":5,"valu":2,"immedi":3,"barg":1,"quot":2,"want":1,"detect":1,"held":3,"honor":1,"lock":14,"true":2,"circumst":1,"avail":1,"polici":1,"fair":3,"interrupt":1,"invoc":1,"unit":2,"will":2,"method":1,"even":2,"certain":1,"also":1},"maxFreq":14,"totalTerms":83},"loc":3}