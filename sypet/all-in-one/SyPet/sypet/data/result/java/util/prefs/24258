{"id":24258,"className":"java.util.prefs.AbstractPreferences","methodName":"removeNode","signature":"\u003cjava.util.prefs.AbstractPreferences: void removeNode()\u003e","javadoc":"/** \n * Implements the \u003ctt\u003eremoveNode()\u003c/tt\u003e method as per the specification in {@link Preferences#removeNode()}. \u003cp\u003eThis implementation checks to see that this node is the root; if so, it throws an appropriate exception.  Then, it locks this node\u0027s parent, and calls a recursive helper method that traverses the subtree rooted at this node.  The recursive method locks the node on which it was called, checks that it has not already been removed, and then ensures that all of its children are cached: The  {@link #childrenNamesSpi()} method isinvoked and each returned child name is checked for containment in the child-cache.  If a child is not already cached, the  {@link #childSpi(String)} method is invoked to create a \u003ctt\u003ePreferences\u003c/tt\u003einstance for it, and this instance is put into the child-cache.  Then the helper method calls itself recursively on each node contained in its child-cache.  Next, it invokes  {@link #removeNodeSpi()}, marks itself as removed, and removes itself from its parent\u0027s child-cache.  Finally, if there are any node change listeners, it enqueues a notification event for processing by the event dispatch thread. \u003cp\u003eNote that the helper method is always invoked with all ancestors up to the \"closest non-removed ancestor\" locked.\n * @throws IllegalStateException if this node (or an ancestor) has alreadybeen removed with the  {@link #removeNode()} method.\n * @throws UnsupportedOperationException if this method is invoked onthe root node.\n * @throws BackingStoreException if this operation cannot be completeddue to a failure in the backing store, or inability to communicate with it.\n */\n","tf":{"freq":{"unsupport":1,"store":2,"root":3,"enqueu":1,"alreadybeen":1,"notif":1,"oper":2,"event":2,"spi":3,"thread":1,"closest":1,"except":4,"creat":1,"invok":4,"alway":1,"onth":1,"remov":10,"parent":2,"mark":1,"instanc":2,"non":1,"node":13,"contain":2,"prefer":2,"recurs":3,"call":3,"put":1,"completeddu":1,"link":5,"next":1,"state":1,"children":2,"ensur":1,"child":7,"name":2,"dispatch":1,"subtre":1,"listen":1,"ancestor":3,"note":1,"travers":1,"inabl":1,"helper":3,"check":3,"failur":1,"isinvok":1,"lock":3,"back":2,"cach":6,"illeg":1,"process":1,"specif":1,"communic":1,"per":1,"appropri":1,"string":1,"alreadi":2,"method":9,"chang":1},"maxFreq":13,"totalTerms":136},"loc":8}