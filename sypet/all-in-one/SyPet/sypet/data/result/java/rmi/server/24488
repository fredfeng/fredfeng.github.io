{"id":24488,"className":"java.rmi.server.RMIClassLoader","methodName":"getDefaultProviderInstance","signature":"\u003cjava.rmi.server.RMIClassLoader: java.rmi.server.RMIClassLoaderSpi getDefaultProviderInstance()\u003e","javadoc":"/** \n * Returns the canonical instance of the default provider for the service provider interface  {@link RMIClassLoaderSpi}. If the system property \u003ccode\u003ejava.rmi.server.RMIClassLoaderSpi\u003c/code\u003e is not defined, then the \u003ccode\u003eRMIClassLoader\u003c/code\u003e static methods \u003cul\u003e \u003cli\u003e {@link #loadClass(URL,String)}\u003cli\u003e {@link #loadClass(String,String)}\u003cli\u003e {@link #loadClass(String,String,ClassLoader)}\u003cli\u003e {@link #loadProxyClass(String,String[],ClassLoader)}\u003cli\u003e {@link #getClassLoader(String)}\u003cli\u003e {@link #getClassAnnotation(Class)}\u003c/ul\u003e will use the canonical instance of the default provider as the service provider instance. \u003cp\u003eIf there is a security manager, its \u003ccode\u003echeckPermission\u003c/code\u003e method will be invoked with a \u003ccode\u003eRuntimePermission(\"setFactory\")\u003c/code\u003e permission; this could result in a \u003ccode\u003eSecurityException\u003c/code\u003e. \u003cp\u003eThe default service provider instance implements {@link RMIClassLoaderSpi} as follows:\u003cblockquote\u003e \u003cp\u003eThe \u003cb\u003e {@link RMIClassLoaderSpi#getClassAnnotation(Class) getClassAnnotation}\u003c/b\u003e method returns a \u003ccode\u003eString\u003c/code\u003e representing the codebase URL path that a remote party should use to download the definition for the specified class.  The format of the returned string is a path of URLs separated by spaces. The codebase string returned depends on the defining class loader of the specified class: \u003cul\u003e \u003cp\u003e\u003cli\u003eIf the class loader is the system class loader (see {@link ClassLoader#getSystemClassLoader}), a parent of the system class loader such as the loader used for installed extensions, or the bootstrap class loader (which may be represented by \u003ccode\u003enull\u003c/code\u003e), then the value of the \u003ccode\u003ejava.rmi.server.codebase\u003c/code\u003e property (or possibly an earlier cached value) is returned, or \u003ccode\u003enull\u003c/code\u003e is returned if that property is not set. \u003cp\u003e\u003cli\u003eOtherwise, if the class loader is an instance of \u003ccode\u003eURLClassLoader\u003c/code\u003e, then the returned string is a space-separated list of the external forms of the URLs returned by invoking the \u003ccode\u003egetURLs\u003c/code\u003e methods of the loader.  If the \u003ccode\u003eURLClassLoader\u003c/code\u003e was created by this provider to service an invocation of its \u003ccode\u003eloadClass\u003c/code\u003e or \u003ccode\u003eloadProxyClass\u003c/code\u003e methods, then no permissions are required to get the associated codebase string.  If it is an arbitrary other \u003ccode\u003eURLClassLoader\u003c/code\u003e instance, then if there is a security manager, its \u003ccode\u003echeckPermission\u003c/code\u003e method will be invoked once for each URL returned by the \u003ccode\u003egetURLs\u003c/code\u003e method, with the permission returned by invoking \u003ccode\u003eopenConnection().getPermission()\u003c/code\u003e on each URL; if any of those invocations throws a \u003ccode\u003eSecurityException\u003c/code\u003e or an \u003ccode\u003eIOException\u003c/code\u003e, then the value of the \u003ccode\u003ejava.rmi.server.codebase\u003c/code\u003e property (or possibly an earlier cached value) is returned, or \u003ccode\u003enull\u003c/code\u003e is returned if that property is not set. \u003cp\u003e\u003cli\u003eFinally, if the class loader is not an instance of \u003ccode\u003eURLClassLoader\u003c/code\u003e, then the value of the \u003ccode\u003ejava.rmi.server.codebase\u003c/code\u003e property (or possibly an earlier cached value) is returned, or \u003ccode\u003enull\u003c/code\u003e is returned if that property is not set. \u003c/ul\u003e \u003cp\u003eFor the implementations of the methods described below, which all take a \u003ccode\u003eString\u003c/code\u003e parameter named \u003ccode\u003ecodebase\u003c/code\u003e that is a space-separated list of URLs, each invocation has an associated \u003ci\u003ecodebase loader\u003c/i\u003e that is identified using the \u003ccode\u003ecodebase\u003c/code\u003e argument in conjunction with the current thread\u0027s context class loader (see {@link Thread#getContextClassLoader()}).  When there is a security manager, this provider maintains an internal table of class loader instances (which are at least instances of  {@link java.net.URLClassLoader}) keyed by the pair of their parent class loader and their codebase URL path (an ordered list of URLs).  If the \u003ccode\u003ecodebase\u003c/code\u003e argument is \u003ccode\u003enull\u003c/code\u003e, the codebase URL path is the value of the system property \u003ccode\u003ejava.rmi.server.codebase\u003c/code\u003e or possibly an earlier cached value.  For a given codebase URL path passed as the \u003ccode\u003ecodebase\u003c/code\u003e argument to an invocation of one of the below methods in a given context, the codebase loader is the loader in the table with the specified codebase URL path and the current thread\u0027s context class loader as its parent.  If no such loader exists, then one is created and added to the table. The table does not maintain strong references to its contained loaders, in order to allow them and their defined classes to be garbage collected when not otherwise reachable.  In order to prevent arbitrary untrusted code from being implicitly loaded into a virtual machine with no security manager, if there is no security manager set, the codebase loader is just the current thread\u0027s context class loader (the supplied codebase URL path is ignored, so remote class loading is disabled). \u003cp\u003eThe \u003cb\u003e {@link RMIClassLoaderSpi#getClassLoader(String) getClassLoader}\u003c/b\u003e method returns the codebase loader for the specified codebase URL path.  If there is a security manager, then if the calling context does not have permission to connect to all of the URLs in the codebase URL path, a \u003ccode\u003eSecurityException\u003c/code\u003e will be thrown. \u003cp\u003eThe \u003cb\u003e {@link RMIClassLoaderSpi#loadClass(String,String,ClassLoader) loadClass}\u003c/b\u003e method attempts to load the class with the specified name as follows: \u003cblockquote\u003e If the \u003ccode\u003edefaultLoader\u003c/code\u003e argument is non-\u003ccode\u003enull\u003c/code\u003e, it first attempts to load the class with the specified \u003ccode\u003ename\u003c/code\u003e using the \u003ccode\u003edefaultLoader\u003c/code\u003e, such as by evaluating \u003cpre\u003e Class.forName(name, false, defaultLoader) \u003c/pre\u003e If the class is successfully loaded from the \u003ccode\u003edefaultLoader\u003c/code\u003e, that class is returned.  If an exception other than \u003ccode\u003eClassNotFoundException\u003c/code\u003e is thrown, that exception is thrown to the caller. \u003cp\u003eNext, the \u003ccode\u003eloadClass\u003c/code\u003e method attempts to load the class with the specified \u003ccode\u003ename\u003c/code\u003e using the codebase loader for the specified codebase URL path. If there is a security manager, then the calling context must have permission to connect to all of the URLs in the codebase URL path; otherwise, the current thread\u0027s context class loader will be used instead of the codebase loader. \u003c/blockquote\u003e \u003cp\u003eThe \u003cb\u003e {@link RMIClassLoaderSpi#loadProxyClass(String,String[],ClassLoader) loadProxyClass}\u003c/b\u003e method attempts to return a dynamic proxy class with the named interface as follows: \u003cblockquote\u003e \u003cp\u003eIf the \u003ccode\u003edefaultLoader\u003c/code\u003e argument is non-\u003ccode\u003enull\u003c/code\u003e and all of the named interfaces can be resolved through that loader, then, \u003cul\u003e \u003cli\u003eif all of the resolved interfaces are \u003ccode\u003epublic\u003c/code\u003e, then it first attempts to obtain a dynamic proxy class (using {@link java.lang.reflect.Proxy#getProxyClass(ClassLoader,Class[]) Proxy.getProxyClass}) for the resolved interfaces defined in the codebase loader; if that attempt throws an \u003ccode\u003eIllegalArgumentException\u003c/code\u003e, it then attempts to obtain a dynamic proxy class for the resolved interfaces defined in the \u003ccode\u003edefaultLoader\u003c/code\u003e.  If both attempts throw \u003ccode\u003eIllegalArgumentException\u003c/code\u003e, then this method throws a \u003ccode\u003eClassNotFoundException\u003c/code\u003e.  If any other exception is thrown, that exception is thrown to the caller. \u003cli\u003eif all of the non-\u003ccode\u003epublic\u003c/code\u003e resolved interfaces are defined in the same class loader, then it attempts to obtain a dynamic proxy class for the resolved interfaces defined in that loader. \u003cli\u003eotherwise, a \u003ccode\u003eLinkageError\u003c/code\u003e is thrown (because a class that implements all of the specified interfaces cannot be defined in any loader). \u003c/ul\u003e \u003cp\u003eOtherwise, if all of the named interfaces can be resolved through the codebase loader, then, \u003cul\u003e \u003cli\u003eif all of the resolved interfaces are \u003ccode\u003epublic\u003c/code\u003e, then it attempts to obtain a dynamic proxy class for the resolved interfaces in the codebase loader.  If the attempt throws an \u003ccode\u003eIllegalArgumentException\u003c/code\u003e, then this method throws a \u003ccode\u003eClassNotFoundException\u003c/code\u003e. \u003cli\u003eif all of the non-\u003ccode\u003epublic\u003c/code\u003e resolved interfaces are defined in the same class loader, then it attempts to obtain a dynamic proxy class for the resolved interfaces defined in that loader. \u003cli\u003eotherwise, a \u003ccode\u003eLinkageError\u003c/code\u003e is thrown (because a class that implements all of the specified interfaces cannot be defined in any loader). \u003c/ul\u003e \u003cp\u003eOtherwise, a \u003ccode\u003eClassNotFoundException\u003c/code\u003e is thrown for one of the named interfaces that could not be resolved. \u003c/blockquote\u003e \u003c/blockquote\u003e\n * @return  the canonical instance of the default service provider\n * @throws SecurityException if there is a security manager and theinvocation of its \u003ccode\u003echeckPermission\u003c/code\u003e method fails\n * @since   1.4\n */\n","tf":{"freq":{"servic":5,"maintain":2,"specifi":10,"open":1,"fail":1,"given":2,"refer":1,"blockquot":6,"spi":7,"thread":5,"linkag":2,"ignor":1,"form":1,"invok":4,"loader":64,"runtim":1,"resolv":12,"parent":3,"describ":1,"prevent":1,"provid":9,"invoc":4,"non":4,"instanc":11,"conjunct":1,"obtain":5,"system":5,"earlier":4,"disabl":1,"remot":2,"will":5,"load":17,"parti":1,"caller":2,"virtual":1,"theinvoc":1,"iclass":8,"bootstrap":1,"pair":1,"next":1,"link":16,"use":8,"space":3,"net":1,"associ":2,"factori":1,"annot":3,"extern":1,"current":4,"just":1,"may":1,"proxi":14,"repres":2,"tabl":4,"string":19,"lclass":5,"intern":1,"method":16,"reachabl":1,"reflect":1,"rmi":5,"fals":1,"least":1,"implicit":1,"possibl":4,"download":1,"garbag":1,"must":1,"arbitrari":2,"requir":1,"permiss":10,"dynam":6,"key":1,"follow":3,"argument":8,"thrown":8,"except":16,"creat":2,"format":1,"machin":1,"separ":3,"strong":1,"definit":1,"contain":1,"properti":8,"collect":1,"attempt":12,"canon":3,"otherwis":7,"call":2,"result":1,"defin":11,"connect":3,"allow":1,"one":3,"identifi":1,"lang":1,"codebas":29,"order":3,"extens":1,"name":10,"path":11,"valu":8,"exist":1,"error":2,"check":3,"depend":1,"manag":8,"instal":1,"paramet":1,"suppli":1,"list":3,"evalu":1,"cach":4,"illeg":3,"pass":1,"secur":12,"pre":2,"take":1,"instead":1,"context":8,"ad":1,"java":7,"server":5,"success":1,"first":2,"untrust":1,"found":4},"maxFreq":64,"totalTerms":589},"loc":7}