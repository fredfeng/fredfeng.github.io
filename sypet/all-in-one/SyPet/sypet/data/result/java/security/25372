{"id":25372,"className":"java.security.DigestInputStream","methodName":"read","signature":"\u003cjava.security.DigestInputStream: int read(byte[],int,int)\u003e","javadoc":"/** \n * Reads into a byte array, and updates the message digest (if the digest function is on).  That is, this method reads up to \u003ccode\u003elen\u003c/code\u003e bytes from the input stream into the array \u003ccode\u003eb\u003c/code\u003e, starting at offset \u003ccode\u003eoff\u003c/code\u003e. This method blocks until the data is actually read. If the digest function is on (see {@link #on(boolean) on}), this method will then call \u003ccode\u003eupdate\u003c/code\u003e on the message digest associated with this stream, passing it the data.\n * @param b the array into which the data is read.\n * @param off the starting offset into \u003ccode\u003eb\u003c/code\u003e of where thedata should be placed.\n * @param len the maximum number of bytes to be read from the inputstream into b, starting at offset \u003ccode\u003eoff\u003c/code\u003e.\n * @return  the actual number of bytes read. This is less than\u003ccode\u003elen\u003c/code\u003e if the end of the stream is reached prior to reading \u003ccode\u003elen\u003c/code\u003e bytes. -1 is returned if no bytes were read because the end of the stream had already been reached when the call was made.\n * @exception IOException if an I/O error occurs.\n * @see MessageDigest#update(byte[],int,int)\n */\n","tf":{"freq":{"call":2,"stream":4,"link":1,"made":1,"data":3,"block":1,"digest":5,"prior":1,"function":2,"reach":2,"associ":1,"thedata":1,"read":9,"offset":3,"place":1,"end":2,"less":1,"except":2,"error":1,"messag":3,"number":2,"inputstream":1,"len":4,"pass":1,"input":1,"updat":3,"start":3,"maximum":1,"will":1,"actual":2,"alreadi":1,"method":3,"occur":1,"array":3},"maxFreq":9,"totalTerms":73},"loc":7}