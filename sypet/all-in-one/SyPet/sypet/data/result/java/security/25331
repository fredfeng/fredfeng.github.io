{"id":25331,"className":"java.security.ProtectionDomain","methodName":"implies","signature":"\u003cjava.security.ProtectionDomain: boolean implies(java.security.Permission)\u003e","javadoc":"/** \n * Check and see if this ProtectionDomain implies the permissions expressed in the Permission object. \u003cp\u003e The set of permissions evaluated is a function of whether the ProtectionDomain was constructed with a static set of permissions or it was bound to a dynamically mapped set of permissions. \u003cp\u003e If the ProtectionDomain was constructed to a {@link #ProtectionDomain(CodeSource,PermissionCollection) statically bound} PermissionCollection then the permission willonly be checked against the PermissionCollection supplied at construction. \u003cp\u003e However, if the ProtectionDomain was constructed with the constructor variant which supports {@link #ProtectionDomain(CodeSource,PermissionCollection,ClassLoader,java.security.Principal[]) dynamically binding}permissions, then the permission will be checked against the combination of the PermissionCollection supplied at construction and the current Policy binding. \u003cp\u003e\n * @param permission the Permission object to check.\n * @return true if \"permission\" is implicit to this ProtectionDomain.\n */\n","tf":{"freq":{"willon":1,"link":2,"implicit":1,"object":2,"express":1,"variant":1,"whether":1,"function":1,"current":1,"combin":1,"permiss":16,"domain":7,"impli":2,"map":1,"howev":1,"dynam":2,"constructor":1,"support":1,"check":4,"loader":1,"true":1,"suppli":2,"polici":1,"evalu":1,"secur":1,"will":1,"sourc":2,"java":1,"construct":5,"bind":2,"bound":2,"princip":1,"collect":5},"maxFreq":16,"totalTerms":73},"loc":16}