{"id":14457,"className":"java.lang.invoke.MethodHandles$Lookup","methodName":"unreflect","signature":"\u003cjava.lang.invoke.MethodHandles$Lookup: java.lang.invoke.MethodHandle unreflect(java.lang.reflect.Method)\u003e","javadoc":"/** \n * Makes a direct method handle to \u003ci\u003em\u003c/i\u003e, if the lookup class has permission. If \u003ci\u003em\u003c/i\u003e is non-static, the receiver argument is treated as an initial argument. If \u003ci\u003em\u003c/i\u003e is virtual, overriding is respected on every call. Unlike the Core Reflection API, exceptions are \u003cem\u003enot\u003c/em\u003e wrapped. The type of the method handle will be that of the method, with the receiver type prepended (but only if it is non-static). If the method\u0027s  {@code accessible} flag is not set,access checking is performed immediately on behalf of the lookup class. If \u003ci\u003em\u003c/i\u003e is not public, do not share the resulting handle with untrusted parties. \u003cp\u003e The returned method handle will have {@linkplain MethodHandle#asVarargsCollector variable arity} if and only ifthe method\u0027s variable arity modifier bit ( {@code 0x0080}) is set.\n * @param m the reflected method\n * @return a method handle which can invoke the reflected method\n * @throws IllegalAccessException if access checking failsor if the method\u0027s variable arity modifier bit is set and  {@code asVarargsCollector} fails\n * @throws NullPointerException if the argument is null\n */\n","tf":{"freq":{"behalf":1,"virtual":1,"linkplain":1,"result":1,"call":1,"vararg":2,"variabl":3,"perform":1,"type":2,"lookup":2,"collector":2,"share":1,"fail":1,"unreflect":1,"permiss":1,"unlik":1,"immedi":1,"initi":1,"everi":1,"argument":3,"direct":1,"ariti":3,"wrap":1,"except":3,"ifth":1,"check":2,"invok":1,"prepend":1,"receiv":2,"access":4,"illeg":1,"non":2,"handl":6,"bit":2,"failsor":1,"flag":1,"modifi":2,"will":2,"pointer":1,"method":11,"core":1,"make":1,"untrust":1,"respect":1,"reflect":3,"parti":1,"treat":1},"maxFreq":11,"totalTerms":85},"loc":8}