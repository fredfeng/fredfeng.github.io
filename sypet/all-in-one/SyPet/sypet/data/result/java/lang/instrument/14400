{"id":14400,"className":"java.lang.instrument.ClassFileTransformer","methodName":"transform","signature":"\u003cjava.lang.instrument.ClassFileTransformer: byte[] transform(java.lang.ClassLoader,java.lang.String,java.lang.Class,java.security.ProtectionDomain,byte[])\u003e","javadoc":"/** \n * The implementation of this method may transform the supplied class file and return a new replacement class file. \u003cP\u003e There are two kinds of transformers, determined by the \u003ccode\u003ecanRetransform\u003c/code\u003e parameter of {@link java.lang.instrument.Instrumentation#addTransformer(ClassFileTransformer,boolean)}: \u003cul\u003e \u003cli\u003e\u003ci\u003eretransformation capable\u003c/i\u003e transformers that were added with \u003ccode\u003ecanRetransform\u003c/code\u003e as true \u003c/li\u003e \u003cli\u003e\u003ci\u003eretransformation incapable\u003c/i\u003e transformers that were added with \u003ccode\u003ecanRetransform\u003c/code\u003e as false or where added with {@link java.lang.instrument.Instrumentation#addTransformer(ClassFileTransformer)}\u003c/li\u003e \u003c/ul\u003e \u003cP\u003e Once a transformer has been registered with {@link java.lang.instrument.Instrumentation#addTransformer(ClassFileTransformer,boolean) addTransformer}, the transformer will be called for every new class definition and every class redefinition. Retransformation capable transformers will also be called on every class retransformation. The request for a new class definition is made with {@link java.lang.ClassLoader#defineClass ClassLoader.defineClass}or its native equivalents. The request for a class redefinition is made with {@link java.lang.instrument.Instrumentation#redefineClasses Instrumentation.redefineClasses}or its native equivalents. The request for a class retransformation is made with {@link java.lang.instrument.Instrumentation#retransformClasses Instrumentation.retransformClasses}or its native equivalents. The transformer is called during the processing of the request, before the class file bytes have been verified or applied. When there are multiple transformers, transformations are composed by chaining the \u003ccode\u003etransform\u003c/code\u003e calls. That is, the byte array returned by one call to \u003ccode\u003etransform\u003c/code\u003e becomes the input (via the \u003ccode\u003eclassfileBuffer\u003c/code\u003e parameter) to the next call. \u003cP\u003e Transformations are applied in the following order: \u003cul\u003e \u003cli\u003eRetransformation incapable transformers \u003c/li\u003e \u003cli\u003eRetransformation incapable native transformers \u003c/li\u003e \u003cli\u003eRetransformation capable transformers \u003c/li\u003e \u003cli\u003eRetransformation capable native transformers \u003c/li\u003e \u003c/ul\u003e \u003cP\u003e For retransformations, the retransformation incapable transformers are not called, instead the result of the previous transformation is reused. In all other cases, this method is called. Within each of these groupings, transformers are called in the order registered. Native transformers are provided by the \u003ccode\u003eClassFileLoadHook\u003c/code\u003e event in the Java Virtual Machine Tool Interface). \u003cP\u003e The input (via the \u003ccode\u003eclassfileBuffer\u003c/code\u003e parameter) to the first transformer is: \u003cul\u003e \u003cli\u003efor new class definition, the bytes passed to \u003ccode\u003eClassLoader.defineClass\u003c/code\u003e \u003c/li\u003e \u003cli\u003efor class redefinition, \u003ccode\u003edefinitions.getDefinitionClassFile()\u003c/code\u003e where \u003ccode\u003edefinitions\u003c/code\u003e is the parameter to {@link java.lang.instrument.Instrumentation#redefineClasses Instrumentation.redefineClasses}\u003c/li\u003e \u003cli\u003efor class retransformation, the bytes passed to the new class definition or, if redefined, the last redefinition, with all transformations made by retransformation incapable transformers reapplied automatically and unaltered; for details see {@link java.lang.instrument.Instrumentation#retransformClasses Instrumentation.retransformClasses}\u003c/li\u003e \u003c/ul\u003e \u003cP\u003e If the implementing method determines that no transformations are needed, it should return \u003ccode\u003enull\u003c/code\u003e. Otherwise, it should create a new \u003ccode\u003ebyte[]\u003c/code\u003e array, copy the input \u003ccode\u003eclassfileBuffer\u003c/code\u003e into it, along with all desired transformations, and return the new array. The input \u003ccode\u003eclassfileBuffer\u003c/code\u003e must not be modified. \u003cP\u003e In the retransform and redefine cases, the transformer must support the redefinition semantics: if a class that the transformer changed during initial definition is later retransformed or redefined, the transformer must insure that the second class output class file is a legal redefinition of the first output class file. \u003cP\u003e If the transformer throws an exception (which it doesn\u0027t catch), subsequent transformers will still be called and the load, redefine or retransform will still be attempted. Thus, throwing an exception has the same effect as returning \u003ccode\u003enull\u003c/code\u003e. To prevent unexpected behavior when unchecked exceptions are generated in transformer code, a transformer can catch \u003ccode\u003eThrowable\u003c/code\u003e. If the transformer believes the \u003ccode\u003eclassFileBuffer\u003c/code\u003e does not represent a validly formatted class file, it should throw an \u003ccode\u003eIllegalClassFormatException\u003c/code\u003e; while this has the same effect as returning null. it facilitates the logging or debugging of format corruptions.\n * @param loader                the defining loader of the class to be transformed,may be \u003ccode\u003enull\u003c/code\u003e if the bootstrap loader\n * @param className             the name of the class in the internal form of fullyqualified class and interface names as defined in \u003ci\u003eThe Java Virtual Machine Specification\u003c/i\u003e. For example, \u003ccode\u003e\"java/util/List\"\u003c/code\u003e.\n * @param classBeingRedefined   if this is triggered by a redefine or retransform,the class being redefined or retransformed; if this is a class load, \u003ccode\u003enull\u003c/code\u003e\n * @param protectionDomain      the protection domain of the class being defined or redefined\n * @param classfileBuffer       the input byte buffer in class file format - must not be modified\n * @throws IllegalClassFormatException if the input does not represent a well-formed class file\n * @return  a well-formed class file buffer (the result of the transform),or \u003ccode\u003enull\u003c/code\u003e if no transform is performed.\n * @see Instrumentation#redefineClasses\n */\n","tf":{"freq":{"need":1,"via":2,"desir":1,"corrupt":1,"reus":1,"copi":1,"becom":1,"file":15,"event":1,"verifi":1,"along":1,"incap":5,"support":1,"form":3,"multipl":1,"loader":6,"prevent":1,"log":1,"provid":1,"will":4,"load":3,"array":3,"virtual":2,"bootstrap":1,"behavior":1,"next":1,"link":8,"made":4,"debug":1,"kind":1,"retransform":25,"transform":45,"insur":1,"semant":1,"domain":2,"initi":1,"trigger":1,"may":2,"previous":1,"repres":2,"later":1,"compos":1,"true":1,"process":1,"redefinit":6,"redefin":13,"chain":1,"exampl":1,"intern":1,"method":3,"throwabl":1,"within":1,"classfil":5,"fals":1,"detail":1,"last":1,"second":1,"tool":1,"facilit":1,"uncheck":1,"perform":1,"must":4,"buffer":8,"equival":3,"request":4,"everi":3,"follow":1,"hook":1,"except":5,"creat":1,"format":5,"believ":1,"input":6,"appli":2,"machin":2,"definit":8,"determin":2,"output":2,"util":1,"otherwis":1,"legal":1,"attempt":1,"valid":1,"defin":6,"call":10,"result":2,"unexpect":1,"one":1,"fullyqualifi":1,"well":2,"add":4,"lang":8,"automat":1,"order":2,"name":3,"unalt":1,"regist":2,"subsequ":1,"thus":1,"paramet":4,"list":1,"suppli":1,"capabl":4,"still":2,"instrument":19,"illeg":2,"pass":2,"two":1,"specif":1,"effect":2,"generat":1,"replac":1,"instead":1,"modifi":2,"ad":3,"java":11,"chang":1,"group":1,"reappli":1,"also":1,"first":2},"maxFreq":45,"totalTerms":372},"loc":0}