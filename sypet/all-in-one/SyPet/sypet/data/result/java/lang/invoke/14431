{"id":14431,"className":"java.lang.invoke.MethodHandle","methodName":"asCollector","signature":"\u003cjava.lang.invoke.MethodHandle: java.lang.invoke.MethodHandle asCollector(java.lang.Class,int)\u003e","javadoc":"/** \n * Makes an \u003cem\u003earray-collecting\u003c/em\u003e method handle, which accepts a given number of trailing positional arguments and collects them into an array argument. The new method handle adapts, as its \u003ci\u003etarget\u003c/i\u003e, the current method handle.  The type of the adapter will be the same as the type of the target, except that a single trailing parameter (usually of type  {@code arrayType}) is replaced by {@code arrayLength} parameters whose type is element type of {@code arrayType}. \u003cp\u003e If the array type differs from the final argument type on the original target, the original target is adapted to take the array type directly, as if by a call to  {@link #asType asType}. \u003cp\u003e When called, the adapter replaces its trailing  {@code arrayLength}arguments by a single new array of type  {@code arrayType}, whose elements comprise (in order) the replaced arguments. Finally the target is called. What the target eventually returns is returned unchanged by the adapter. \u003cp\u003e (The array may also be a shared constant when  {@code arrayLength} is zero.)\u003cp\u003e (\u003cem\u003eNote:\u003c/em\u003e The  {@code arrayType} is often identical to the lastparameter type of the original target. It is an explicit argument for symmetry with  {@code asSpreader}, and also to allow the target to use a simple  {@code Object} as its last parameter type.)\u003cp\u003e In order to create a collecting adapter which is not restricted to a particular number of collected arguments, use  {@link #asVarargsCollector asVarargsCollector} instead.\u003cp\u003e Here are some examples of array-collecting method handles: \u003cblockquote\u003e\u003cpre\u003e MethodHandle deepToString \u003d publicLookup() .findStatic(Arrays.class, \"deepToString\", methodType(String.class, Object[].class)); assertEquals(\"[won]\",   (String) deepToString.invokeExact(new Object[]{\"won\"})); MethodHandle ts1 \u003d deepToString.asCollector(Object[].class, 1); assertEquals(methodType(String.class, Object.class), ts1.type()); //assertEquals(\"[won]\", (String) ts1.invokeExact(         new Object[]{\"won\"})); //FAIL assertEquals(\"[[won]]\", (String) ts1.invokeExact((Object) new Object[]{\"won\"})); // arrayType can be a subtype of Object[] MethodHandle ts2 \u003d deepToString.asCollector(String[].class, 2); assertEquals(methodType(String.class, String.class, String.class), ts2.type()); assertEquals(\"[two, too]\", (String) ts2.invokeExact(\"two\", \"too\")); MethodHandle ts0 \u003d deepToString.asCollector(Object[].class, 0); assertEquals(\"[]\", (String) ts0.invokeExact()); // collectors can be nested, Lisp-style MethodHandle ts22 \u003d deepToString.asCollector(Object[].class, 3).asCollector(String[].class, 2); assertEquals(\"[A, B, [C, D]]\", ((String) ts22.invokeExact((Object)\u0027A\u0027, (Object)\"B\", \"C\", \"D\"))); // arrayType can be any primitive array type MethodHandle bytesToString \u003d publicLookup() .findStatic(Arrays.class, \"toString\", methodType(String.class, byte[].class)) .asCollector(byte[].class, 3); assertEquals(\"[1, 2, 3]\", (String) bytesToString.invokeExact((byte)1, (byte)2, (byte)3)); MethodHandle longsToString \u003d publicLookup() .findStatic(Arrays.class, \"toString\", methodType(String.class, long[].class)) .asCollector(long[].class, 1); assertEquals(\"[123]\", (String) longsToString.invokeExact((long)123)); \u003c/pre\u003e\u003c/blockquote\u003e\n * @param arrayType often {@code Object[]}, the type of the array argument which will collect the arguments\n * @param arrayLength the number of arguments to collect into a new array argument\n * @return a new method handle which collects some trailing argumentinto an array, before calling the original method handle\n * @throws NullPointerException if {@code arrayType} is a null reference\n * @throws IllegalArgumentException if {@code arrayType} is not an array typeor  {@code arrayType} is not assignable to this method handle\u0027s trailing parameter type,or  {@code arrayLength} is not a legal array size\n * @throws WrongMethodTypeException if the implied {@code asType} call fails\n * @see #asSpreader\n * @see #asVarargsCollector\n */\n","tf":{"freq":{"assign":1,"vararg":3,"last":1,"simpl":1,"singl":2,"accept":1,"particular":1,"subtyp":1,"type":35,"zero":1,"lookup":3,"compris":1,"fail":1,"given":1,"refer":1,"argumentinto":1,"blockquot":2,"exact":8,"trail":5,"impli":1,"deep":7,"argument":12,"element":2,"except":4,"unchang":1,"creat":1,"whose":2,"invok":8,"number":3,"symmetri":1,"typeor":1,"restrict":1,"size":1,"explicit":1,"often":2,"will":2,"pointer":1,"make":1,"posit":1,"array":31,"collect":8,"spreader":2,"legal":1,"primit":1,"call":5,"eventu":1,"allow":1,"link":2,"use":2,"object":14,"adapt":6,"collector":12,"share":1,"style":1,"order":2,"ident":1,"length":5,"current":1,"find":3,"note":1,"usual":1,"direct":1,"lastparamet":1,"may":1,"constant":1,"nest":1,"paramet":4,"origin":4,"equal":10,"illeg":1,"lisp":1,"handl":14,"two":2,"differ":1,"pre":2,"take":1,"string":30,"replac":3,"exampl":1,"instead":1,"target":8,"wrong":1,"method":20,"also":2},"maxFreq":35,"totalTerms":336},"loc":5}