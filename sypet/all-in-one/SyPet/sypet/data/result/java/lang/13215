{"id":13215,"className":"java.lang.Float","methodName":"valueOf","signature":"\u003cjava.lang.Float: java.lang.Float valueOf(java.lang.String)\u003e","javadoc":"/** \n * Returns a  {@code Float} object holding the{@code float} value represented by the argument string{@code s}. \u003cp\u003eIf  {@code s} is {@code null}, then a {@code NullPointerException} is thrown.\u003cp\u003eLeading and trailing whitespace characters in  {@code s}are ignored.  Whitespace is removed as if by the  {@link String#trim} method; that is, both ASCII space and controlcharacters are removed. The rest of  {@code s} shouldconstitute a \u003ci\u003eFloatValue\u003c/i\u003e as described by the lexical syntax rules: \u003cblockquote\u003e \u003cdl\u003e \u003cdt\u003e\u003ci\u003eFloatValue:\u003c/i\u003e \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e  {@code NaN}\u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e  {@code Infinity}\u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e FloatingPointLiteral\u003c/i\u003e \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e HexFloatingPointLiteral\u003c/i\u003e \u003cdd\u003e\u003ci\u003eSignedInteger\u003c/i\u003e \u003c/dl\u003e \u003cp\u003e \u003cdl\u003e \u003cdt\u003e\u003ci\u003eHexFloatingPointLiteral\u003c/i\u003e: \u003cdd\u003e \u003ci\u003eHexSignificand BinaryExponent FloatTypeSuffix\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e \u003c/dl\u003e \u003cp\u003e \u003cdl\u003e \u003cdt\u003e\u003ci\u003eHexSignificand:\u003c/i\u003e \u003cdd\u003e\u003ci\u003eHexNumeral\u003c/i\u003e \u003cdd\u003e\u003ci\u003eHexNumeral\u003c/i\u003e  {@code .}\u003cdd\u003e {@code 0x} \u003ci\u003eHexDigits\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code .}\u003ci\u003e HexDigits\u003c/i\u003e \u003cdd\u003e {@code 0X}\u003ci\u003e HexDigits\u003csub\u003eopt\u003c/sub\u003e \u003c/i\u003e {@code .} \u003ci\u003eHexDigits\u003c/i\u003e\u003c/dl\u003e \u003cp\u003e \u003cdl\u003e \u003cdt\u003e\u003ci\u003eBinaryExponent:\u003c/i\u003e \u003cdd\u003e\u003ci\u003eBinaryExponentIndicator SignedInteger\u003c/i\u003e \u003c/dl\u003e \u003cp\u003e \u003cdl\u003e \u003cdt\u003e\u003ci\u003eBinaryExponentIndicator:\u003c/i\u003e \u003cdd\u003e {@code p}\u003cdd\u003e {@code P}\u003c/dl\u003e \u003c/blockquote\u003e where \u003ci\u003eSign\u003c/i\u003e, \u003ci\u003eFloatingPointLiteral\u003c/i\u003e, \u003ci\u003eHexNumeral\u003c/i\u003e, \u003ci\u003eHexDigits\u003c/i\u003e, \u003ci\u003eSignedInteger\u003c/i\u003e and \u003ci\u003eFloatTypeSuffix\u003c/i\u003e are as defined in the lexical structure sections of \u003ccite\u003eThe Java\u0026trade; Language Specification\u003c/cite\u003e, except that underscores are not accepted between digits. If  {@code s} does not have the form ofa \u003ci\u003eFloatValue\u003c/i\u003e, then a  {@code NumberFormatException}is thrown. Otherwise,  {@code s} is regarded asrepresenting an exact decimal value in the usual \"computerized scientific notation\" or as an exact hexadecimal value; this exact numerical value is then conceptually converted to an \"infinitely precise\" binary value that is then rounded to type  {@code float}by the usual round-to-nearest rule of IEEE 754 floating-point arithmetic, which includes preserving the sign of a zero value. Note that the round-to-nearest rule also implies overflow and underflow behaviour; if the exact value of  {@code s} is largeenough in magnitude (greater than or equal to ( {@link #MAX_VALUE} + {@link Math#ulp(float) ulp(MAX_VALUE)}/2), rounding to  {@code float} will result in an infinity and if theexact value of  {@code s} is small enough in magnitude (lessthan or equal to  {@link #MIN_VALUE}/2), rounding to float will result in a zero. Finally, after rounding a  {@code Float} object representingthis  {@code float} value is returned.\u003cp\u003eTo interpret localized string representations of a floating-point value, use subclasses of  {@link java.text.NumberFormat}. \u003cp\u003eNote that trailing format specifiers, specifiers that determine the type of a floating-point literal ( {@code 1.0f} is a {@code float} value;{@code 1.0d} is a {@code double} value), do\u003cem\u003enot\u003c/em\u003e influence the results of this method.  In other words, the numerical value of the input string is converted directly to the target floating-point type.  In general, the two-step sequence of conversions, string to  {@code double}followed by  {@code double} to {@code float}, is \u003cem\u003enot\u003c/em\u003e equivalent to converting a string directly to {@code float}.  For example, if first converted to an intermediate  {@code double} and then to{@code float}, the string\u003cbr\u003e {@code \"1.00000017881393421514957253748434595763683319091796875001d\"}\u003cbr\u003e results in the  {@code float} value{@code 1.0000002f}; if the string is converted directly to {@code float}, \u003ccode\u003e1.000000\u003cb\u003e1\u003c/b\u003ef\u003c/code\u003e results. \u003cp\u003eTo avoid calling this method on an invalid string and having a  {@code NumberFormatException} be thrown, the documentationfor  {@link Double#valueOf Double.valueOf} lists a regularexpression which can be used to screen the input.\n * @param s   the string to be parsed.\n * @return  a {@code Float} object holding the valuerepresented by the  {@code String} argument.\n * @throws NumberFormatException  if the string does not contain aparsable number.\n */\n","tf":{"freq":{"greater":1,"infin":2,"accept":1,"languag":1,"zero":2,"intermedi":1,"specifi":2,"avoid":1,"hex":12,"largeenough":1,"sequenc":1,"blockquot":2,"impli":1,"controlcharact":1,"opt":7,"screen":1,"ignor":1,"form":1,"numer":5,"charact":1,"hold":2,"remov":2,"describ":1,"theexact":1,"apars":1,"number":5,"regard":1,"cite":2,"digit":6,"will":2,"pointer":1,"valuerepres":1,"small":1,"computer":1,"structur":1,"significand":2,"link":6,"use":2,"representingthi":1,"space":1,"decim":1,"indic":2,"note":2,"direct":3,"usual":2,"repres":1,"asrepres":1,"ulp":2,"hexadecim":1,"documentationfor":1,"represent":1,"math":1,"point":8,"string":12,"exampl":1,"influenc":1,"method":3,"pars":1,"arithmet":1,"lead":1,"round":6,"type":5,"enough":1,"infinit":1,"lexic":2,"invalid":1,"equival":1,"lessthan":1,"trail":2,"exact":4,"precis":1,"follow":1,"expon":4,"argument":2,"text":1,"liter":5,"thrown":3,"except":5,"shouldconstitut":1,"scientif":1,"preserv":1,"format":5,"underflow":1,"regularexpress":1,"sign":9,"input":2,"syntax":1,"contain":1,"determin":1,"overflow":1,"subclass":1,"word":1,"rest":1,"otherwis":1,"call":1,"defin":1,"result":5,"binari":5,"sub":14,"trade":1,"behaviour":1,"convers":1,"interpret":1,"convert":5,"object":3,"rule":3,"valu":20,"trim":1,"includ":1,"whitespac":2,"magnitud":2,"list":1,"equal":2,"underscor":1,"conceptu":1,"suffix":2,"nearest":2,"general":1,"section":1,"two":1,"specif":1,"notat":1,"target":1,"java":2,"local":1,"first":1,"integ":3,"ofa":1,"also":1,"step":1},"maxFreq":20,"totalTerms":298},"loc":3}