{"id":14476,"className":"java.lang.invoke.MethodHandles","methodName":"foldArguments","signature":"\u003cjava.lang.invoke.MethodHandles: java.lang.invoke.MethodHandle foldArguments(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)\u003e","javadoc":"/** \n * Adapts a target method handle by pre-processing some of its arguments, and then calling the target with the result of the pre-processing, inserted into the original sequence of arguments. \u003cp\u003e The pre-processing is performed by  {@code combiner}, a second method handle. Of the arguments passed to the adapter, the first  {@code N} argumentsare copied to the combiner, which is then called. (Here,  {@code N} is defined as the parameter count of the combiner.)After this, control passes to the target, with any result from the combiner inserted before the original  {@code N} incomingarguments. \u003cp\u003e If the combiner returns a value, the first parameter type of the target must be identical with the return type of the combiner, and the next {@code N} parameter types of the target must exactly match the parametersof the combiner. \u003cp\u003e If the combiner has a void return, no result will be inserted, and the first  {@code N} parameter types of the targetmust exactly match the parameters of the combiner. \u003cp\u003e The resulting adapter is the same type as the target, except that the first parameter type is dropped, if it corresponds to the result of the combiner. \u003cp\u003e (Note that  {@link #dropArguments(MethodHandle,int,List) dropArguments} can be used to remove any argumentsthat either the combiner or the target does not wish to receive. If some of the incoming arguments are destined only for the combiner, consider using  {@link MethodHandle#asCollector asCollector} instead, since thosearguments will not need to be live on the stack on entry to the target.) \u003cb\u003eExample:\u003c/b\u003e \u003cp\u003e\u003cblockquote\u003e\u003cpre\u003e import static java.lang.invoke.MethodHandles.*; import static java.lang.invoke.MethodType.*; ... MethodHandle trace \u003d publicLookup().findVirtual(java.io.PrintStream.class, \"println\", methodType(void.class, String.class)) .bindTo(System.out); MethodHandle cat \u003d lookup().findVirtual(String.class, \"concat\", methodType(String.class, String.class)); assertEquals(\"boojum\", (String) cat.invokeExact(\"boo\", \"jum\")); MethodHandle catTrace \u003d foldArguments(cat, trace); // also prints \"boo\": assertEquals(\"boojum\", (String) catTrace.invokeExact(\"boo\", \"jum\")); \u003c/pre\u003e\u003c/blockquote\u003e \u003cp\u003e Here is pseudocode for the resulting adapter: \u003cblockquote\u003e\u003cpre\u003e // there are N arguments in A... T target(V, A[N]..., B...); V combiner(A...); T adapter(A... a, B... b) { V v \u003d combiner(a...); return target(v, a..., b...); } // and if the combiner has a void return: T target2(A[N]..., B...); void combiner2(A...); T adapter2(A... a, B... b) { combiner2(a...); return target2(a..., b...); } \u003c/pre\u003e\u003c/blockquote\u003e\n * @param target the method handle to invoke after arguments are combined\n * @param combiner method handle to call initially on the incoming arguments\n * @return method handle which incorporates the specified argument folding logic\n * @throws NullPointerException if either argument is null\n * @throws IllegalArgumentException if {@code combiner}\u0027s return type is non-void and not the same as the first argument type of the target, or if the initial  {@code N} argument typesof the target (skipping one matching the  {@code combiner}\u0027s return type) are not identical with the argument types of  {@code combiner}\n */\n","tf":{"freq":{"need":1,"count":1,"second":1,"wish":1,"incorpor":1,"drop":3,"thoseargu":1,"perform":1,"skip":1,"type":13,"lookup":2,"copi":1,"must":2,"specifi":1,"println":1,"parametersof":1,"blockquot":4,"sequenc":1,"exact":4,"combin":22,"live":1,"argument":17,"control":1,"except":3,"invok":5,"targetmust":1,"remov":1,"logic":1,"non":1,"system":1,"will":2,"pointer":1,"argumentsar":1,"match":3,"stack":1,"incomingargu":1,"incom":2,"virtual":2,"defin":1,"call":3,"result":6,"cat":5,"stream":1,"correspond":1,"one":1,"next":1,"link":2,"use":2,"adapt":6,"pseudocod":1,"lang":2,"consid":1,"boojum":2,"argumentsthat":1,"collector":2,"ident":2,"valu":1,"initi":2,"find":2,"note":1,"trace":4,"entri":1,"paramet":6,"origin":2,"equal":2,"list":1,"receiv":1,"jum":2,"fold":3,"illeg":1,"concat":1,"print":2,"pass":2,"handl":11,"process":3,"either":2,"boo":3,"pre":7,"string":6,"exampl":1,"instead":1,"target":15,"java":3,"method":14,"insert":3,"also":1,"bind":1,"first":5,"typesof":1,"destin":1},"maxFreq":22,"totalTerms":260},"loc":22}