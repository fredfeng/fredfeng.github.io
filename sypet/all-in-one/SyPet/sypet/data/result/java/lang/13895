{"id":13895,"className":"java.lang.Object","methodName":"wait","signature":"\u003cjava.lang.Object: void wait(long)\u003e","javadoc":"/** \n * Causes the current thread to wait until either another thread invokes the {@link java.lang.Object#notify()} method or the{@link java.lang.Object#notifyAll()} method for this object, or aspecified amount of time has elapsed. \u003cp\u003e The current thread must own this object\u0027s monitor. \u003cp\u003e This method causes the current thread (call it \u003cvar\u003eT\u003c/var\u003e) to place itself in the wait set for this object and then to relinquish any and all synchronization claims on this object. Thread \u003cvar\u003eT\u003c/var\u003e becomes disabled for thread scheduling purposes and lies dormant until one of four things happens: \u003cul\u003e \u003cli\u003eSome other thread invokes the  {@code notify} method for thisobject and thread \u003cvar\u003eT\u003c/var\u003e happens to be arbitrarily chosen as the thread to be awakened. \u003cli\u003eSome other thread invokes the  {@code notifyAll} method for thisobject. \u003cli\u003eSome other thread  {@linkplain Thread#interrupt() interrupts}thread \u003cvar\u003eT\u003c/var\u003e. \u003cli\u003eThe specified amount of real time has elapsed, more or less.  If {@code timeout} is zero, however, then real time is not taken intoconsideration and the thread simply waits until notified. \u003c/ul\u003e The thread \u003cvar\u003eT\u003c/var\u003e is then removed from the wait set for this object and re-enabled for thread scheduling. It then competes in the usual manner with other threads for the right to synchronize on the object; once it has gained control of the object, all its synchronization claims on the object are restored to the status quo ante - that is, to the situation as of the time that the  {@code wait}method was invoked. Thread \u003cvar\u003eT\u003c/var\u003e then returns from the invocation of the  {@code wait} method. Thus, on return from the{@code wait} method, the synchronization state of the object and ofthread  {@code T} is exactly as it was when the {@code wait} methodwas invoked. \u003cp\u003e A thread can also wake up without being notified, interrupted, or timing out, a so-called \u003ci\u003espurious wakeup\u003c/i\u003e.  While this will rarely occur in practice, applications must guard against it by testing for the condition that should have caused the thread to be awakened, and continuing to wait if the condition is not satisfied.  In other words, waits should always occur in loops, like this one: \u003cpre\u003e synchronized (obj) { while (\u0026lt;condition does not hold\u0026gt;) obj.wait(timeout); ... // Perform action appropriate to condition } \u003c/pre\u003e (For more information on this topic, see Section 3.2.3 in Doug Lea\u0027s \"Concurrent Programming in Java (Second Edition)\" (Addison-Wesley, 2000), or Item 50 in Joshua Bloch\u0027s \"Effective Java Programming Language Guide\" (Addison-Wesley, 2001). \u003cp\u003eIf the current thread is  {@linkplain java.lang.Thread#interrupt() interrupted} by any thread before or while it is waiting, then an{@code InterruptedException} is thrown.  This exception is notthrown until the lock status of this object has been restored as described above. \u003cp\u003e Note that the  {@code wait} method, as it places the current threadinto the wait set for this object, unlocks only this object; any other objects on which the current thread may be synchronized remain locked while the thread waits. \u003cp\u003e This method should only be called by a thread that is the owner of this object\u0027s monitor. See the  {@code notify} method for adescription of the ways in which a thread can become the owner of a monitor.\n * @param timeout   the maximum time to wait in milliseconds.\n * @exception IllegalArgumentException      if the value of timeout isnegative.\n * @exception IllegalMonitorStateException  if the current thread is notthe owner of the object\u0027s monitor.\n * @exception InterruptedException if any thread interrupted thecurrent thread before or while the current thread was waiting for a notification.  The \u003ci\u003einterrupted status\u003c/i\u003e of the current thread is cleared when this exception is thrown.\n * @see java.lang.Object#notify()\n * @see java.lang.Object#notifyAll()\n */\n","tf":{"freq":{"wesley":2,"test":1,"languag":1,"wait":18,"zero":1,"specifi":1,"elaps":2,"time":6,"becom":2,"thread":32,"wakeup":1,"purpos":1,"happen":2,"place":2,"right":1,"awaken":2,"topic":1,"unlock":1,"invok":5,"alway":1,"hold":1,"remov":1,"describ":1,"like":1,"without":1,"invoc":1,"disabl":1,"thecurr":1,"will":1,"linkplain":2,"simpli":1,"aspecifi":1,"concurr":1,"link":2,"anoth":1,"bloch":1,"applic":1,"clear":1,"notthrown":1,"guard":1,"current":9,"practic":1,"loop":1,"thisobject":2,"note":1,"methodwa":1,"usual":1,"may":1,"gain":1,"either":1,"remain":1,"appropri":1,"item":1,"lea":1,"satisfi":1,"method":11,"obj":2,"second":1,"doug":1,"perform":1,"isneg":1,"joshua":1,"must":2,"situat":1,"amount":2,"notif":1,"rare":1,"exact":1,"arbitrarili":1,"action":1,"taken":1,"howev":1,"ant":1,"addison":2,"argument":1,"notifi":9,"control":1,"thrown":2,"except":9,"monitor":5,"spurious":1,"status":3,"enabl":1,"ofthread":1,"continu":1,"inform":1,"maximum":1,"program":2,"owner":3,"restor":2,"word":1,"thing":1,"call":3,"compet":1,"var":12,"one":2,"state":2,"way":1,"intoconsider":1,"schedul":2,"chosen":1,"object":19,"lang":5,"quo":1,"real":2,"millisecond":1,"wake":1,"valu":1,"threadinto":1,"four":1,"less":1,"condit":4,"notth":1,"thus":1,"lock":2,"edit":1,"illeg":2,"interrupt":9,"section":1,"guid":1,"adescript":1,"caus":3,"effect":1,"relinquish":1,"pre":2,"java":7,"manner":1,"claim":2,"also":1,"timeout":4,"lie":1,"dormant":1,"occur":2},"maxFreq":32,"totalTerms":314},"loc":0}