{"id":14554,"className":"java.lang.invoke.SwitchPoint","methodName":"hasBeenInvalidated","signature":"\u003cjava.lang.invoke.SwitchPoint: boolean hasBeenInvalidated()\u003e","javadoc":"/** \n * Determines if this switch point has been invalidated yet. \u003cp style\u003d\"font-size:smaller;\"\u003e \u003cem\u003eDiscussion:\u003c/em\u003e Because of the one-way nature of invalidation, once a switch point begins to return true for  {@code hasBeenInvalidated}, it will always do so in the future. On the other hand, a valid switch point visible to other threads may be invalidated at any moment, due to a request by another thread. \u003cp style\u003d\"font-size:smaller;\"\u003e Since invalidation is a global and immediate operation, the execution of this query, on a valid switchpoint, must be internally sequenced with any other threads that could cause invalidation. This query may therefore be expensive. The recommended way to build a boolean-valued method handle which queries the invalidation state of a switch point  {@code s} isto call  {@code s.guardWithTest} on{@link MethodHandles#constant constant} true and false method handles.\n * @return true if this switch point has been invalidated\n */\n","tf":{"freq":{"fals":1,"test":1,"natur":1,"must":1,"invalid":9,"oper":1,"sequenc":1,"thread":3,"request":1,"alway":1,"font":2,"global":1,"size":2,"queri":3,"discuss":1,"determin":1,"will":1,"due":1,"execut":1,"valid":2,"call":1,"moment":1,"visibl":1,"link":1,"one":1,"state":1,"way":2,"anoth":1,"therefor":1,"build":1,"recommend":1,"smaller":2,"hand":1,"style":2,"guard":1,"immedi":1,"valu":1,"may":2,"constant":2,"futur":1,"isto":1,"true":3,"switchpoint":1,"begin":1,"handl":3,"point":5,"caus":1,"intern":1,"expens":1,"method":3,"yet":1},"maxFreq":9,"totalTerms":81},"loc":3}