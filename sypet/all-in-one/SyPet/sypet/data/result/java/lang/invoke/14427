{"id":14427,"className":"java.lang.invoke.MethodHandle","methodName":"invokeWithArguments","signature":"\u003cjava.lang.invoke.MethodHandle: java.lang.Object invokeWithArguments(java.lang.Object[])\u003e","javadoc":"/** \n * Performs a variable arity invocation, passing the arguments in the given array to the method handle, as if via an inexact  {@link #invoke invoke} from a call sitewhich mentions only the type  {@code Object}, and whose arity is the length of the argument array. \u003cp\u003e Specifically, execution proceeds as if by the following steps, although the methods are not guaranteed to be called if the JVM can predict their effects. \u003cul\u003e \u003cli\u003eDetermine the length of the argument array as  {@code N}. For a null reference,  {@code N\u003d0}. \u003c/li\u003e \u003cli\u003eDetermine the general type  {@code TN} of {@code N} arguments asas  {@code TN\u003dMethodType.genericMethodType(N)}.\u003c/li\u003e \u003cli\u003eForce the original target method handle  {@code MH0} to therequired type, as  {@code MH1 \u003d MH0.asType(TN)}. \u003c/li\u003e \u003cli\u003eSpread the array into  {@code N} separate arguments {@code A0, ...}. \u003c/li\u003e \u003cli\u003eInvoke the type-adjusted method handle on the unpacked arguments: MH1.invokeExact(A0, ...). \u003c/li\u003e \u003cli\u003eTake the return value as an  {@code Object} reference. \u003c/li\u003e\u003c/ul\u003e \u003cp\u003e Because of the action of the  {@code asType} step, the following argumentconversions are applied as necessary: \u003cul\u003e \u003cli\u003ereference casting \u003cli\u003eunboxing \u003cli\u003ewidening primitive conversions \u003c/ul\u003e \u003cp\u003e The result returned by the call is boxed if it is a primitive, or forced to null if the return type is void. \u003cp\u003e This call is equivalent to the following code: \u003cp\u003e\u003cblockquote\u003e\u003cpre\u003e MethodHandle invoker \u003d MethodHandles.spreadInvoker(this.type(), 0); Object result \u003d invoker.invokeExact(this, arguments); \u003c/pre\u003e\u003c/blockquote\u003e \u003cp\u003e Unlike the signature polymorphic methods  {@code invokeExact} and {@code invoke}, {@code invokeWithArguments} can be accessed normally via the Core Reflection API and JNI.It can therefore be used as a bridge between native or reflective code and method handles.\n * @param arguments the arguments to pass to the target\n * @return the result returned by the target\n * @throws ClassCastException if an argument cannot be converted by reference casting\n * @throws WrongMethodTypeException if the target\u0027s type cannot be adjusted to take the given number of {@code Object} arguments\n * @throws Throwable anything thrown by the target method invocation\n * @see MethodHandles#spreadInvoker\n */\n","tf":{"freq":{"anyth":1,"via":2,"normal":1,"variabl":1,"therequir":1,"perform":1,"type":12,"necessari":1,"inexact":1,"although":1,"given":2,"equival":1,"refer":4,"blockquot":2,"exact":3,"proceed":1,"sitewhich":1,"action":1,"follow":3,"argument":13,"thrown":1,"except":2,"whose":1,"invok":13,"number":1,"asa":1,"invoc":2,"appli":1,"cast":3,"separ":1,"determin":2,"execut":1,"array":4,"generic":1,"unpack":1,"result":3,"primit":2,"call":4,"argumentconvers":1,"link":1,"convers":1,"convert":1,"use":1,"therefor":1,"object":4,"signatur":1,"unlik":1,"length":2,"adjust":2,"bridg":1,"mention":1,"valu":1,"forc":2,"ariti":2,"guarante":1,"polymorph":1,"origin":1,"access":1,"general":1,"pass":2,"handl":7,"specif":1,"effect":1,"widen":1,"pre":2,"predict":1,"take":2,"target":5,"wrong":1,"core":1,"box":1,"method":13,"throwabl":1,"spread":3,"unbox":1,"reflect":2,"step":2},"maxFreq":13,"totalTerms":172},"loc":10}