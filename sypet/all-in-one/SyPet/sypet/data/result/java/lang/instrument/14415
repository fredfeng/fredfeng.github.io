{"id":14415,"className":"java.lang.instrument.Instrumentation","methodName":"setNativeMethodPrefix","signature":"\u003cjava.lang.instrument.Instrumentation: void setNativeMethodPrefix(java.lang.instrument.ClassFileTransformer,java.lang.String)\u003e","javadoc":"/** \n * This method modifies the failure handling of native method resolution by allowing retry with a prefix applied to the name. When used with the {@link java.lang.instrument.ClassFileTransformer ClassFileTransformer}, it enables native methods to be instrumented. \u003cp/\u003e Since native methods cannot be directly instrumented (they have no bytecodes), they must be wrapped with a non-native method which can be instrumented. For example, if we had: \u003cpre\u003e native boolean foo(int x);\u003c/pre\u003e \u003cp/\u003e We could transform the class file (with the ClassFileTransformer during the initial definition of the class) so that this becomes: \u003cpre\u003e boolean foo(int x) { \u003ci\u003e... record entry to foo ...\u003c/i\u003e return wrapped_foo(x); } native boolean wrapped_foo(int x);\u003c/pre\u003e \u003cp/\u003e Where \u003ccode\u003efoo\u003c/code\u003e becomes a wrapper for the actual native method with the appended prefix \"wrapped_\".  Note that \"wrapped_\" would be a poor choice of prefix since it might conceivably form the name of an existing method thus something like \"$$$MyAgentWrapped$$$_\" would be better but would make these examples less readable. \u003cp/\u003e The wrapper will allow data to be collected on the native method call, but now the problem becomes linking up the wrapped method with the native implementation. That is, the method \u003ccode\u003ewrapped_foo\u003c/code\u003e needs to be resolved to the native implementation of \u003ccode\u003efoo\u003c/code\u003e, which might be: \u003cpre\u003e Java_somePackage_someClass_foo(JNIEnv* env, jint x)\u003c/pre\u003e \u003cp/\u003e This function allows the prefix to be specified and the proper resolution to occur. Specifically, when the standard resolution fails, the resolution is retried taking the prefix into consideration. There are two ways that resolution occurs, explicit resolution with the JNI function \u003ccode\u003eRegisterNatives\u003c/code\u003e and the normal automatic resolution.  For \u003ccode\u003eRegisterNatives\u003c/code\u003e, the JVM will attempt this association: \u003cpre\u003e method(foo) -\u003e nativeImplementation(foo)\u003c/pre\u003e \u003cp/\u003e When this fails, the resolution will be retried with the specified prefix prepended to the method name, yielding the correct resolution: \u003cpre\u003e method(wrapped_foo) -\u003e nativeImplementation(foo)\u003c/pre\u003e \u003cp/\u003e For automatic resolution, the JVM will attempt: \u003cpre\u003e method(wrapped_foo) -\u003e nativeImplementation(wrapped_foo)\u003c/pre\u003e \u003cp/\u003e When this fails, the resolution will be retried with the specified prefix deleted from the implementation name, yielding the correct resolution: \u003cpre\u003e method(wrapped_foo) -\u003e nativeImplementation(foo)\u003c/pre\u003e \u003cp/\u003e Note that since the prefix is only used when standard resolution fails, native methods can be wrapped selectively. \u003cp/\u003e Since each \u003ccode\u003eClassFileTransformer\u003c/code\u003e can do its own transformation of the bytecodes, more than one layer of wrappers may be applied. Thus each transformer needs its own prefix.  Since transformations are applied in order, the prefixes, if applied, will be applied in the same order (see  {@link #addTransformer(ClassFileTransformer,boolean) addTransformer}). Thus if three transformers applied wrappers, \u003ccode\u003efoo\u003c/code\u003e might become \u003ccode\u003e$trans3_$trans2_$trans1_foo\u003c/code\u003e.  But if, say, the second transformer did not apply a wrapper to \u003ccode\u003efoo\u003c/code\u003e it would be just \u003ccode\u003e$trans3_$trans1_foo\u003c/code\u003e.  To be able to efficiently determine the sequence of prefixes, an intermediate prefix is only applied if its non-native wrapper exists.  Thus, in the last example, even though \u003ccode\u003e$trans1_foo\u003c/code\u003e is not a native method, the \u003ccode\u003e$trans1_\u003c/code\u003e prefix is applied since \u003ccode\u003e$trans1_foo\u003c/code\u003e exists.\n * @param transformer The ClassFileTransformer which wraps using this prefix.\n * @param prefix The prefix to apply to wrapped native methods when retrying a failed native method resolution. If prefix is either \u003ccode\u003enull\u003c/code\u003e or the empty string, then failed native method resolutions are not retried for this transformer.\n * @throws java.lang.NullPointerException if passed a \u003ccode\u003enull\u003c/code\u003e transformer.\n * @throws java.lang.UnsupportedOperationException if the current configuration ofthe JVM does not allow setting a native method prefix ( {@link #isNativeMethodPrefixSupported} is false).\n * @throws java.lang.IllegalArgumentException if the transformer is not registered(see  {@link #addTransformer(ClassFileTransformer,boolean) addTransformer}).\n * @since 1.6\n */\n","tf":{"freq":{"need":2,"conceiv":1,"yield":2,"foo":23,"abl":1,"intermedi":1,"specifi":3,"becom":4,"wrapper":6,"fail":6,"correct":2,"oper":1,"file":8,"sequenc":1,"effici":1,"support":1,"form":1,"resolv":1,"like":1,"non":2,"record":1,"configur":1,"now":1,"explicit":1,"prefix":20,"will":6,"say":1,"pointer":1,"bytecod":2,"might":3,"delet":1,"link":5,"data":1,"use":3,"someth":1,"retri":6,"resolut":15,"transform":21,"associ":1,"consider":1,"current":1,"initi":1,"note":2,"direct":1,"just":1,"may":1,"failur":1,"env":1,"empti":1,"either":1,"string":1,"exampl":3,"method":23,"ienv":1,"fals":1,"unsupport":1,"last":1,"second":1,"normal":1,"though":1,"must":1,"function":2,"jint":1,"three":1,"proper":1,"argument":1,"append":1,"wrap":15,"except":3,"enabl":1,"select":1,"tran":8,"agent":1,"appli":10,"better":1,"definit":1,"determin":1,"even":1,"make":1,"collect":1,"attempt":2,"call":1,"allow":4,"readabl":1,"one":1,"way":1,"add":4,"lang":4,"automat":2,"order":2,"ofth":1,"name":4,"regist":3,"exist":3,"less":1,"standard":2,"thus":4,"entri":1,"prepend":1,"poor":1,"layer":1,"choic":1,"problem":1,"instrument":4,"illeg":1,"pass":1,"handl":1,"two":1,"specif":1,"pre":14,"take":1,"modifi":1,"actual":1,"java":5,"occur":2},"maxFreq":23,"totalTerms":337},"loc":0}