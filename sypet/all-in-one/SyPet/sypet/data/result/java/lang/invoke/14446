{"id":14446,"className":"java.lang.invoke.MethodHandles$Lookup","methodName":"in","signature":"\u003cjava.lang.invoke.MethodHandles$Lookup: java.lang.invoke.MethodHandles$Lookup in(java.lang.Class)\u003e","javadoc":"/** \n * Creates a lookup on the specified new lookup class. The resulting object will report the specified class as its own  {@link #lookupClass lookupClass}. \u003cp\u003e However, the resulting  {@code Lookup} object is guaranteedto have no more access capabilities than the original. In particular, access capabilities can be lost as follows:\u003cul\u003e \u003cli\u003eIf the new lookup class differs from the old one, protected members will not be accessible by virtue of inheritance. (Protected members may continue to be accessible because of package sharing.) \u003cli\u003eIf the new lookup class is in a different package than the old one, protected and default (package) members will not be accessible. \u003cli\u003eIf the new lookup class is not within the same package member as the old one, private members will not be accessible. \u003cli\u003eIf the new lookup class is not accessible to the old lookup class, then no members, not even public members, will be accessible. (In all other cases, public members will continue to be accessible.) \u003c/ul\u003e\n * @param requestedLookupClass the desired lookup class for the new lookup object\n * @return a lookup object which reports the desired lookup class\n * @throws NullPointerException if the argument is null\n */\n","tf":{"freq":{"result":2,"old":4,"lost":1,"link":1,"one":3,"particular":1,"object":4,"desir":2,"lookup":15,"specifi":2,"share":1,"virtu":1,"request":1,"report":2,"howev":1,"guaranteedto":1,"follow":1,"argument":1,"member":8,"except":1,"may":1,"creat":1,"origin":1,"capabl":2,"access":9,"continu":2,"differ":2,"will":6,"pointer":1,"even":1,"within":1},"maxFreq":15,"totalTerms":80},"loc":25}