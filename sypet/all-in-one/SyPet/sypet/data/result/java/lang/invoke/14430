{"id":14430,"className":"java.lang.invoke.MethodHandle","methodName":"asSpreader","signature":"\u003cjava.lang.invoke.MethodHandle: java.lang.invoke.MethodHandle asSpreader(java.lang.Class,int)\u003e","javadoc":"/** \n * Makes an \u003cem\u003earray-spreading\u003c/em\u003e method handle, which accepts a trailing array argument and spreads its elements as positional arguments. The new method handle adapts, as its \u003ci\u003etarget\u003c/i\u003e, the current method handle.  The type of the adapter will be the same as the type of the target, except that the final {@code arrayLength} parameters of the target\u0027s type are replacedby a single array parameter of type  {@code arrayType}. \u003cp\u003e If the array element type differs from any of the corresponding argument types on the original target, the original target is adapted to take the array elements directly, as if by a call to  {@link #asType asType}. \u003cp\u003e When called, the adapter replaces a trailing array argument by the array\u0027s elements, each as its own argument to the target. (The order of the arguments is preserved.) They are converted pairwise by casting and/or unboxing to the types of the trailing parameters of the target. Finally the target is called. What the target eventually returns is returned unchanged by the adapter. \u003cp\u003e Before calling the target, the adapter verifies that the array contains exactly enough elements to provide a correct argument count to the target method handle. (The array may also be null when zero elements are required.) \u003cp\u003e Here are some simple examples of array-spreading method handles: \u003cblockquote\u003e\u003cpre\u003e MethodHandle equals \u003d publicLookup() .findVirtual(String.class, \"equals\", methodType(boolean.class, Object.class)); assert( (boolean) equals.invokeExact(\"me\", (Object)\"me\")); assert(!(boolean) equals.invokeExact(\"me\", (Object)\"thee\")); // spread both arguments from a 2-array: MethodHandle eq2 \u003d equals.asSpreader(Object[].class, 2); assert( (boolean) eq2.invokeExact(new Object[]{ \"me\", \"me\" })); assert(!(boolean) eq2.invokeExact(new Object[]{ \"me\", \"thee\" })); // spread both arguments from a String array: MethodHandle eq2s \u003d equals.asSpreader(String[].class, 2); assert( (boolean) eq2s.invokeExact(new String[]{ \"me\", \"me\" })); assert(!(boolean) eq2s.invokeExact(new String[]{ \"me\", \"thee\" })); // spread second arguments from a 1-array: MethodHandle eq1 \u003d equals.asSpreader(Object[].class, 1); assert( (boolean) eq1.invokeExact(\"me\", new Object[]{ \"me\" })); assert(!(boolean) eq1.invokeExact(\"me\", new Object[]{ \"thee\" })); // spread no arguments from a 0-array or null: MethodHandle eq0 \u003d equals.asSpreader(Object[].class, 0); assert( (boolean) eq0.invokeExact(\"me\", (Object)\"me\", new Object[0])); assert(!(boolean) eq0.invokeExact(\"me\", (Object)\"thee\", (Object[])null)); // asSpreader and asCollector are approximate inverses: for (int n \u003d 0; n \u003c\u003d 2; n++) { for (Class\u003c?\u003e a : new Class\u003c?\u003e[]{Object[].class, String[].class, CharSequence[].class}) { MethodHandle equals2 \u003d equals.asSpreader(a, n).asCollector(a, n); assert( (boolean) equals2.invokeWithArguments(\"me\", \"me\")); assert(!(boolean) equals2.invokeWithArguments(\"me\", \"thee\")); } } MethodHandle caToString \u003d publicLookup() .findStatic(Arrays.class, \"toString\", methodType(String.class, char[].class)); assertEquals(\"[A, B, C]\", (String) caToString.invokeExact(\"ABC\".toCharArray())); MethodHandle caString3 \u003d caToString.asCollector(char[].class, 3); assertEquals(\"[A, B, C]\", (String) caString3.invokeExact(\u0027A\u0027, \u0027B\u0027, \u0027C\u0027)); MethodHandle caToString2 \u003d caString3.asSpreader(char[].class, 2); assertEquals(\"[A, B, C]\", (String) caToString2.invokeExact(\u0027A\u0027, \"BC\".toCharArray())); \u003c/pre\u003e\u003c/blockquote\u003e\n * @param arrayType usually {@code Object[]}, the type of the array argument from which to extract the spread arguments\n * @param arrayLength the number of arguments to spread from an incoming array argument\n * @return a new method handle which spreads its final array argument,before calling the original method handle\n * @throws NullPointerException if {@code arrayType} is a null reference\n * @throws IllegalArgumentException if {@code arrayType} is not an array type\n * @throws IllegalArgumentException if target does not have at least{@code arrayLength} parameter types,or if  {@code arrayLength} is negative\n * @throws WrongMethodTypeException if the implied {@code asType} call fails\n * @see #asCollector\n */\n","tf":{"freq":{"second":1,"simpl":1,"count":1,"singl":1,"least":1,"accept":1,"approxim":1,"type":20,"enough":1,"zero":1,"lookup":2,"requir":1,"fail":1,"correct":1,"refer":1,"sequenc":1,"blockquot":2,"trail":3,"verifi":1,"exact":14,"impli":1,"argument":20,"element":6,"except":5,"unchang":1,"invok":15,"preserv":1,"number":1,"provid":1,"extract":1,"cast":1,"contain":1,"will":1,"pointer":1,"negat":1,"make":1,"posit":1,"thee":6,"incom":1,"spreader":8,"array":29,"virtual":1,"call":6,"eventu":1,"correspond":1,"link":1,"convert":1,"pairwis":1,"object":16,"adapt":6,"collector":4,"invers":1,"order":1,"length":4,"current":1,"find":2,"usual":1,"direct":1,"may":1,"origin":3,"paramet":4,"equal":15,"illeg":2,"handl":16,"differ":1,"pre":2,"take":1,"string":19,"replacedbi":1,"replac":1,"exampl":1,"target":12,"wrong":1,"method":19,"spread":10,"unbox":1,"also":1},"maxFreq":29,"totalTerms":319},"loc":4}