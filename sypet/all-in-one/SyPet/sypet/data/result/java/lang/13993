{"id":13993,"className":"java.lang.Double","methodName":"valueOf","signature":"\u003cjava.lang.Double: java.lang.Double valueOf(java.lang.String)\u003e","javadoc":"/** \n * Returns a  {@code Double} object holding the{@code double} value represented by the argument string{@code s}. \u003cp\u003eIf  {@code s} is {@code null}, then a {@code NullPointerException} is thrown.\u003cp\u003eLeading and trailing whitespace characters in  {@code s}are ignored.  Whitespace is removed as if by the  {@link String#trim} method; that is, both ASCII space and controlcharacters are removed. The rest of  {@code s} shouldconstitute a \u003ci\u003eFloatValue\u003c/i\u003e as described by the lexical syntax rules: \u003cblockquote\u003e \u003cdl\u003e \u003cdt\u003e\u003ci\u003eFloatValue:\u003c/i\u003e \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e  {@code NaN}\u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e  {@code Infinity}\u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e FloatingPointLiteral\u003c/i\u003e \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e HexFloatingPointLiteral\u003c/i\u003e \u003cdd\u003e\u003ci\u003eSignedInteger\u003c/i\u003e \u003c/dl\u003e \u003cp\u003e \u003cdl\u003e \u003cdt\u003e\u003ci\u003eHexFloatingPointLiteral\u003c/i\u003e: \u003cdd\u003e \u003ci\u003eHexSignificand BinaryExponent FloatTypeSuffix\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e \u003c/dl\u003e \u003cp\u003e \u003cdl\u003e \u003cdt\u003e\u003ci\u003eHexSignificand:\u003c/i\u003e \u003cdd\u003e\u003ci\u003eHexNumeral\u003c/i\u003e \u003cdd\u003e\u003ci\u003eHexNumeral\u003c/i\u003e  {@code .}\u003cdd\u003e {@code 0x} \u003ci\u003eHexDigits\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code .}\u003ci\u003e HexDigits\u003c/i\u003e \u003cdd\u003e {@code 0X}\u003ci\u003e HexDigits\u003csub\u003eopt\u003c/sub\u003e \u003c/i\u003e {@code .} \u003ci\u003eHexDigits\u003c/i\u003e\u003c/dl\u003e \u003cp\u003e \u003cdl\u003e \u003cdt\u003e\u003ci\u003eBinaryExponent:\u003c/i\u003e \u003cdd\u003e\u003ci\u003eBinaryExponentIndicator SignedInteger\u003c/i\u003e \u003c/dl\u003e \u003cp\u003e \u003cdl\u003e \u003cdt\u003e\u003ci\u003eBinaryExponentIndicator:\u003c/i\u003e \u003cdd\u003e {@code p}\u003cdd\u003e {@code P}\u003c/dl\u003e \u003c/blockquote\u003e where \u003ci\u003eSign\u003c/i\u003e, \u003ci\u003eFloatingPointLiteral\u003c/i\u003e, \u003ci\u003eHexNumeral\u003c/i\u003e, \u003ci\u003eHexDigits\u003c/i\u003e, \u003ci\u003eSignedInteger\u003c/i\u003e and \u003ci\u003eFloatTypeSuffix\u003c/i\u003e are as defined in the lexical structure sections of \u003ccite\u003eThe Java\u0026trade; Language Specification\u003c/cite\u003e, except that underscores are not accepted between digits. If  {@code s} does not have the form ofa \u003ci\u003eFloatValue\u003c/i\u003e, then a  {@code NumberFormatException}is thrown. Otherwise,  {@code s} is regarded asrepresenting an exact decimal value in the usual \"computerized scientific notation\" or as an exact hexadecimal value; this exact numerical value is then conceptually converted to an \"infinitely precise\" binary value that is then rounded to type  {@code double}by the usual round-to-nearest rule of IEEE 754 floating-point arithmetic, which includes preserving the sign of a zero value. Note that the round-to-nearest rule also implies overflow and underflow behaviour; if the exact value of  {@code s} is largeenough in magnitude (greater than or equal to ( {@link #MAX_VALUE} + {@link Math#ulp(double) ulp(MAX_VALUE)}/2), rounding to  {@code double} will result in an infinity and if theexact value of  {@code s} is small enough in magnitude (lessthan or equal to  {@link #MIN_VALUE}/2), rounding to float will result in a zero. Finally, after rounding a  {@code Double} object representingthis  {@code double} value is returned.\u003cp\u003e To interpret localized string representations of a floating-point value, use subclasses of  {@link java.text.NumberFormat}. \u003cp\u003eNote that trailing format specifiers, specifiers that determine the type of a floating-point literal ( {@code 1.0f} is a {@code float} value;{@code 1.0d} is a {@code double} value), do\u003cem\u003enot\u003c/em\u003e influence the results of this method.  In other words, the numerical value of the input string is converted directly to the target floating-point type.  The two-step sequence of conversions, string to  {@code float} followedby  {@code float} to {@code double}, is \u003cem\u003enot\u003c/em\u003e equivalent to converting a string directly to {@code double}. For example, the  {@code float}literal  {@code 0.1f} is equal to the {@code double}value  {@code 0.10000000149011612}; the  {@code float}literal  {@code 0.1f} represents a different numericalvalue than the  {@code double} literal{@code 0.1}. (The numerical value 0.1 cannot be exactly represented in a binary floating-point number.) \u003cp\u003eTo avoid calling this method on an invalid string and having a  {@code NumberFormatException} be thrown, the regularexpression below can be used to screen the input string: \u003ccode\u003e \u003cpre\u003e final String Digits     \u003d \"(\\\\p{Digit}+)\"; final String HexDigits  \u003d \"(\\\\p{XDigit}+)\"; // an exponent is \u0027e\u0027 or \u0027E\u0027 followed by an optionally // signed decimal integer. final String Exp        \u003d \"[eE][+-]?\"+Digits; final String fpRegex    \u003d (\"[\\\\x00-\\\\x20]*\"+  // Optional leading \"whitespace\" \"[+-]?(\" + // Optional sign character \"NaN|\" +           // \"NaN\" string \"Infinity|\" +      // \"Infinity\" string // A decimal floating-point string representing a finite positive // number without a leading sign has at most five basic pieces: // Digits . Digits ExponentPart FloatTypeSuffix // // Since this method allows integer-only strings as input // in addition to strings of floating-point literals, the // two sub-patterns below are simplifications of the grammar // productions from section 3.10.2 of // \u003ccite\u003eThe Java\u0026trade; Language Specification\u003c/cite\u003e. // Digits ._opt Digits_opt ExponentPart_opt FloatTypeSuffix_opt \"(((\"+Digits+\"(\\\\.)?(\"+Digits+\"?)(\"+Exp+\")?)|\"+ // . Digits ExponentPart_opt FloatTypeSuffix_opt \"(\\\\.(\"+Digits+\")(\"+Exp+\")?)|\"+ // Hexadecimal strings \"((\" + // 0[xX] HexDigits ._opt BinaryExponent FloatTypeSuffix_opt \"(0[xX]\" + HexDigits + \"(\\\\.)?)|\" + // 0[xX] HexDigits_opt . HexDigits BinaryExponent FloatTypeSuffix_opt \"(0[xX]\" + HexDigits + \"?(\\\\.)\" + HexDigits + \")\" + \")[pP][+-]?\" + Digits + \"))\" + \"[fFdD]?))\" + \"[\\\\x00-\\\\x20]*\");// Optional trailing \"whitespace\" if (Pattern.matches(fpRegex, myString)) Double.valueOf(myString); // Will not throw NumberFormatException else { // Perform suitable alternative action } \u003c/pre\u003e \u003c/code\u003e\n * @param s   the string to be parsed.\n * @return     a {@code Double} object holding the valuerepresented by the  {@code String} argument.\n * @throws NumberFormatException  if the string does not contain aparsable number.\n */\n","tf":{"freq":{"greater":1,"infin":4,"accept":1,"suitabl":1,"languag":2,"zero":2,"specifi":2,"avoid":1,"hex":19,"largeenough":1,"sequenc":1,"blockquot":2,"finit":1,"impli":1,"controlcharact":1,"option":4,"opt":17,"screen":1,"ignor":1,"form":1,"simplif":1,"numer":6,"charact":2,"regex":2,"hold":2,"remov":2,"describ":1,"theexact":1,"apars":1,"number":8,"regard":1,"piec":1,"without":1,"els":1,"cite":4,"digit":25,"will":3,"pointer":1,"valuerepres":1,"posit":1,"small":1,"computer":1,"structur":1,"significand":2,"link":5,"use":2,"representingthi":1,"space":1,"decim":3,"indic":2,"note":2,"direct":2,"usual":2,"addit":1,"followedbi":1,"repres":4,"asrepres":1,"ulp":2,"hexadecim":2,"represent":1,"product":1,"math":1,"differ":1,"point":11,"pattern":2,"numericalvalu":1,"string":23,"exampl":1,"influenc":1,"method":4,"part":3,"pars":1,"arithmet":1,"lead":3,"perform":1,"round":6,"type":10,"enough":1,"infinit":1,"lexic":2,"altern":1,"invalid":1,"basic":1,"equival":1,"lessthan":1,"trail":3,"exact":5,"action":1,"precis":1,"follow":1,"expon":10,"argument":2,"text":1,"liter":9,"thrown":3,"except":6,"shouldconstitut":1,"scientif":1,"preserv":1,"format":6,"underflow":1,"regularexpress":1,"sign":12,"exp":3,"input":3,"syntax":1,"contain":1,"determin":1,"overflow":1,"subclass":1,"word":1,"match":1,"rest":1,"otherwis":1,"call":1,"defin":1,"result":3,"binari":8,"sub":15,"allow":1,"trade":2,"behaviour":1,"convers":1,"interpret":1,"convert":3,"object":3,"xdigit":1,"rule":3,"valu":20,"trim":1,"five":1,"includ":1,"whitespac":4,"magnitud":2,"equal":3,"underscor":1,"conceptu":1,"suffix":7,"nearest":2,"section":2,"grammar":1,"two":2,"specif":2,"notat":1,"pre":2,"target":1,"java":3,"local":1,"integ":5,"ofa":1,"also":1,"step":1},"maxFreq":25,"totalTerms":436},"loc":3}