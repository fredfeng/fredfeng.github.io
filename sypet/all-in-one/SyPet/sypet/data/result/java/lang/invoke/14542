{"id":14542,"className":"java.lang.invoke.MethodHandleProxies","methodName":"asInterfaceInstance","signature":"\u003cjava.lang.invoke.MethodHandleProxies: T asInterfaceInstance(java.lang.Class,java.lang.invoke.MethodHandle)\u003e","javadoc":"/** \n * Produces an instance of the given single-method interface which redirects its calls to the given method handle. \u003cp\u003e A single-method interface is an interface which declares a uniquely named method. When determining the uniquely named method of a single-method interface, the public  {@code Object} methods ({@code toString},  {@code equals},  {@code hashCode}) are disregarded.  For example,  {@link java.util.Comparator} is a single-method interface,even though it re-declares the  {@code Object.equals} method.\u003cp\u003e The interface must be public.  No additional access checks are performed. \u003cp\u003e The resulting instance of the required type will respond to invocation of the type\u0027s uniquely named method by calling the given target on the incoming arguments, and returning or throwing whatever the target returns or throws.  The invocation will be as if by {@code target.invoke}. The target\u0027s type will be checked before the instance is created, as if by a call to  {@code asType}, which may result in a  {@code WrongMethodTypeException}. \u003cp\u003e The uniquely named method is allowed to be multiply declared, with distinct type descriptors.  (E.g., it can be overloaded, or can possess bridge methods.)  All such declarations are connected directly to the target method handle. Argument and return types are adjusted by  {@code asType}for each individual declaration. \u003cp\u003e The wrapper instance will implement the requested interface and its super-types, but no other single-method interfaces. This means that the instance will not unexpectedly pass an  {@code instanceof} test for any unrequested type.\u003cp style\u003d\"font-size:smaller;\"\u003e \u003cem\u003eImplementation Note:\u003c/em\u003e Therefore, each instance must implement a unique single-method interface. Implementations may not bundle together multiple single-method interfaces onto single implementation classes in the style of  {@link java.awt.AWTEventMulticaster}. \u003cp\u003e The method handle may throw an \u003cem\u003eundeclared exception\u003c/em\u003e, which means any checked exception (or other checked throwable) not declared by the requested type\u0027s single abstract method. If this happens, the throwable will be wrapped in an instance of {@link java.lang.reflect.UndeclaredThrowableException UndeclaredThrowableException}and thrown in that wrapped form. \u003cp\u003e Like  {@link java.lang.Integer#valueOf Integer.valueOf}, {@code asInterfaceInstance} is a factory method whose results are definedby their behavior. It is not guaranteed to return a new instance for every call. \u003cp\u003e Because of the possibility of  {@linkplain java.lang.reflect.Method#isBridge bridge methods}and other corner cases, the interface may also have several abstract methods with the same name but having distinct descriptors (types of returns and parameters). In this case, all the methods are bound in common to the one given target. The type check and effective  {@code asType} conversion is applied to eachmethod type descriptor, and all abstract methods are bound to the target in common. Beyond this type check, no further checks are made to determine that the abstract methods are related in any way. \u003cp\u003e Future versions of this API may accept additional types, such as abstract classes with single abstract methods. Future versions of this API may also equip wrapper instances with one or more additional public \"marker\" interfaces.\n * @param target the method handle to invoke from the wrapper\n * @param intfc the desired type of the wrapper, a single-method interface\n * @return a correctly-typed wrapper for the given target\n * @throws NullPointerException if either argument is null\n * @throws IllegalArgumentException if the {@code intfc} is not avalid argument to this method\n * @throws WrongMethodTypeException if the target cannotbe converted to the type required by the requested interface\n */\n","tf":{"freq":{"equip":1,"singl":11,"test":1,"accept":1,"multicast":1,"desir":1,"beyond":1,"distinct":2,"correct":1,"given":5,"wrapper":5,"respond":1,"tevent":1,"relat":1,"definedbi":1,"happen":1,"multipl":1,"form":1,"invok":2,"like":1,"invoc":2,"instanc":11,"will":6,"pointer":1,"linkplain":1,"common":2,"descriptor":3,"behavior":1,"link":4,"made":1,"therefor":1,"version":2,"factori":1,"possess":1,"adjust":1,"note":1,"individu":1,"direct":1,"addit":3,"may":6,"disregard":1,"corner":1,"access":1,"either":1,"unrequest":1,"string":1,"exampl":1,"method":31,"throwabl":4,"bound":2,"reflect":2,"undeclar":3,"possibl":1,"perform":1,"type":21,"must":2,"though":1,"uniqu":5,"requir":2,"request":3,"whatev":1,"everi":1,"argument":5,"eachmethod":1,"onto":1,"wrap":2,"except":8,"thrown":1,"cannotb":1,"creat":1,"hash":1,"whose":1,"font":1,"togeth":1,"size":1,"appli":1,"awt":1,"marker":1,"determin":2,"even":1,"compar":1,"util":1,"bundl":1,"incom":1,"result":3,"call":4,"intfc":2,"unexpect":1,"allow":1,"connect":1,"one":2,"convers":1,"convert":1,"way":1,"object":2,"lang":3,"smaller":1,"avalid":1,"declar":6,"style":2,"name":5,"multipli":1,"mean":2,"redirect":1,"bridg":3,"valu":2,"futur":2,"check":7,"guarante":1,"paramet":1,"produc":1,"equal":2,"overload":1,"illeg":1,"sever":1,"handl":4,"pass":1,"effect":1,"target":10,"wrong":2,"java":5,"integ":2,"also":2},"maxFreq":31,"totalTerms":302},"loc":29}