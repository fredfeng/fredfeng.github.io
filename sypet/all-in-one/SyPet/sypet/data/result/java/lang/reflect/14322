{"id":14322,"className":"java.lang.reflect.Field","methodName":"set","signature":"\u003cjava.lang.reflect.Field: void set(java.lang.Object,java.lang.Object)\u003e","javadoc":"/** \n * Sets the field represented by this  {@code Field} object on thespecified object argument to the specified new value. The new value is automatically unwrapped if the underlying field has a primitive type. \u003cp\u003eThe operation proceeds as follows: \u003cp\u003eIf the underlying field is static, the  {@code obj} argument isignored; it may be null. \u003cp\u003eOtherwise the underlying field is an instance field.  If the specified object argument is null, the method throws a {@code NullPointerException}.  If the specified object argument is not an instance of the class or interface declaring the underlying field, the method throws an  {@code IllegalArgumentException}. \u003cp\u003eIf this  {@code Field} object is enforcing Java language access control, andthe underlying field is inaccessible, the method throws an {@code IllegalAccessException}. \u003cp\u003eIf the underlying field is final, the method throws an {@code IllegalAccessException} unless {@code setAccessible(true)}has succeeded for this  {@code Field} objectand the field is non-static. Setting a final field in this way is meaningful only during deserialization or reconstruction of instances of classes with blank final fields, before they are made available for access by other parts of a program. Use in any other context may have unpredictable effects, including cases in which other parts of a program continue to use the original value of this field. \u003cp\u003eIf the underlying field is of a primitive type, an unwrapping conversion is attempted to convert the new value to a value of a primitive type.  If this attempt fails, the method throws an {@code IllegalArgumentException}. \u003cp\u003eIf, after possible unwrapping, the new value cannot be converted to the type of the underlying field by an identity or widening conversion, the method throws an {@code IllegalArgumentException}. \u003cp\u003eIf the underlying field is static, the class that declared the field is initialized if it has not already been initialized. \u003cp\u003eThe field is set to the possibly unwrapped and widened new value. \u003cp\u003eIf the field is hidden in the type of  {@code obj}, the field\u0027s value is set according to the preceding rules.\n * @param obj the object whose field should be modified\n * @param value the new value for the field of {@code obj}being modified\n * @exception IllegalAccessException    if this {@code Field} objectis enforcing Java language access control and the underlying field is either inaccessible or final.\n * @exception IllegalArgumentException  if the specified object is not aninstance of the class or interface declaring the underlying field (or a subclass or implementor thereof), or if an unwrapping conversion fails.\n * @exception NullPointerException      if the specified object is nulland the field is an instance field.\n * @exception ExceptionInInitializerError if the initialization provokedby this method fails.\n */\n","tf":{"freq":{"inaccess":2,"objecti":1,"unwrap":5,"nulland":1,"possibl":2,"languag":2,"type":5,"aninst":1,"specifi":5,"fail":3,"oper":1,"proceed":1,"thespecifi":1,"implementor":1,"follow":1,"isignor":1,"argument":8,"control":2,"except":14,"succeed":1,"whose":1,"enforc":2,"avail":1,"provokedbi":1,"continu":1,"instanc":4,"non":1,"thereof":1,"program":2,"subclass":1,"pointer":2,"attempt":2,"otherwis":1,"primit":3,"convers":3,"made":1,"convert":2,"way":1,"use":2,"object":8,"automat":1,"ident":1,"declar":3,"unless":1,"objectand":1,"reconstruct":1,"rule":1,"unpredict":1,"valu":10,"initi":4,"may":2,"includ":1,"blank":1,"error":1,"repres":1,"origin":1,"true":1,"accord":1,"meaning":1,"access":7,"illeg":7,"field":29,"preced":1,"either":1,"effect":1,"widen":2,"hidden":1,"modifi":2,"context":1,"alreadi":1,"method":7,"obj":4,"java":2,"part":2,"deseri":1,"andth":1},"maxFreq":29,"totalTerms":202},"loc":3}