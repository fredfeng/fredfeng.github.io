{"id":14164,"className":"java.lang.management.ThreadMXBean","methodName":"findDeadlockedThreads","signature":"\u003cjava.lang.management.ThreadMXBean: long[] findDeadlockedThreads()\u003e","javadoc":"/** \n * Finds cycles of threads that are in deadlock waiting to acquire object monitors or \u003ca href\u003d\"LockInfo.html#OwnableSynchronizer\"\u003eownable synchronizers\u003c/a\u003e. Threads are \u003cem\u003edeadlocked\u003c/em\u003e in a cycle waiting for a lock of these two types if each thread owns one lock while trying to acquire another lock already held by another thread in the cycle. \u003cp\u003e This method is designed for troubleshooting use, but not for synchronization control.  It might be an expensive operation.\n * @return an array of IDs of the threads that aredeadlocked waiting for object monitors or ownable synchronizers, if any; \u003ctt\u003enull\u003c/tt\u003e otherwise.\n * @throws java.lang.SecurityException if a security managerexists and the caller does not have ManagementPermission(\"monitor\").\n * @throws java.lang.UnsupportedOperationException if the Java virtualmachine does not support monitoriing of ownable synchronizer usage.\n * @see #isSynchronizerUsageSupported\n * @see #findMonitorDeadlockedThreads\n * @since 1.6\n */\n","tf":{"freq":{"caller":1,"otherwis":1,"acquir":2,"might":1,"unsupport":1,"monitori":1,"one":1,"cycl":3,"use":1,"object":2,"wait":3,"anoth":2,"type":1,"lang":2,"info":1,"id":1,"oper":2,"thread":7,"permiss":1,"href":1,"find":3,"deadlock":4,"held":1,"control":1,"except":2,"support":2,"monitor":4,"virtualmachin":1,"ownabl":4,"manag":1,"lock":4,"managerexist":1,"two":1,"secur":2,"expens":1,"troubleshoot":1,"java":3,"html":1,"alreadi":1,"method":1,"usag":2,"aredeadlock":1,"design":1,"array":1},"maxFreq":7,"totalTerms":79},"loc":0}