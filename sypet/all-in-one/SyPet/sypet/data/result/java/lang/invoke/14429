{"id":14429,"className":"java.lang.invoke.MethodHandle","methodName":"asType","signature":"\u003cjava.lang.invoke.MethodHandle: java.lang.invoke.MethodHandle asType(java.lang.invoke.MethodType)\u003e","javadoc":"/** \n * Produces an adapter method handle which adapts the type of the current method handle to a new type. The resulting method handle is guaranteed to report a type which is equal to the desired new type. \u003cp\u003e If the original type and new type are equal, returns  {@code this}. \u003cp\u003e The new method handle, when invoked, will perform the following steps: \u003cul\u003e \u003cli\u003eConvert the incoming argument list to match the original method handle\u0027s argument list. \u003cli\u003eInvoke the original method handle on the converted argument list. \u003cli\u003eConvert any result returned by the original method handle to the return type of new method handle. \u003c/ul\u003e \u003cp\u003e This method provides the crucial behavioral difference between {@link #invokeExact invokeExact} and plain, inexact {@link #invoke invoke}. The two methods perform the same steps when the caller\u0027s type descriptor exactly m atches the callee\u0027s, but when the types differ, plain  {@link #invoke invoke}also calls  {@code asType} (or some internal equivalent) in orderto match up the caller\u0027s and callee\u0027s types. \u003cp\u003e If the current method is a variable arity method handle argument list conversion may involve the conversion and collection of several arguments into an array, as {@linkplain #asVarargsCollector described elsewhere}. In every other case, all conversions are applied \u003cem\u003epairwise\u003c/em\u003e, which means that each argument or return value is converted to exactly one argument or return value (or no return value). The applied conversions are defined by consulting the the corresponding component types of the old and new method handle types. \u003cp\u003e Let \u003cem\u003eT0\u003c/em\u003e and \u003cem\u003eT1\u003c/em\u003e be corresponding new and old parameter types, or old and new return types.  Specifically, for some valid index  {@code i}, let \u003cem\u003eT0\u003c/em\u003e {@code \u003dnewType.parameterType(i)} and \u003cem\u003eT1\u003c/em\u003e{@code \u003dthis.type().parameterType(i)}. Or else, going the other way for return values, let \u003cem\u003eT0\u003c/em\u003e {@code \u003dthis.type().returnType()} and \u003cem\u003eT1\u003c/em\u003e{@code \u003dnewType.returnType()}. If the types are the same, the new method handle makes no change to the corresponding argument or return value (if any). Otherwise, one of the following conversions is applied if possible: \u003cul\u003e \u003cli\u003eIf \u003cem\u003eT0\u003c/em\u003e and \u003cem\u003eT1\u003c/em\u003e are references, then a cast to \u003cem\u003eT1\u003c/em\u003e is applied. (The types do not need to be related in any particular way. This is because a dynamic value of null can convert to any reference type.) \u003cli\u003eIf \u003cem\u003eT0\u003c/em\u003e and \u003cem\u003eT1\u003c/em\u003e are primitives, then a Java method invocation conversion (JLS 5.3) is applied, if one exists. (Specifically, \u003cem\u003eT0\u003c/em\u003e must convert to \u003cem\u003eT1\u003c/em\u003e by a widening primitive conversion.) \u003cli\u003eIf \u003cem\u003eT0\u003c/em\u003e is a primitive and \u003cem\u003eT1\u003c/em\u003e a reference, a Java casting conversion (JLS 5.5) is applied if one exists. (Specifically, the value is boxed from \u003cem\u003eT0\u003c/em\u003e to its wrapper class, which is then widened as needed to \u003cem\u003eT1\u003c/em\u003e.) \u003cli\u003eIf \u003cem\u003eT0\u003c/em\u003e is a reference and \u003cem\u003eT1\u003c/em\u003e a primitive, an unboxing conversion will be applied at runtime, possibly followed by a Java method invocation conversion (JLS 5.3) on the primitive value.  (These are the primitive widening conversions.) \u003cem\u003eT0\u003c/em\u003e must be a wrapper class or a supertype of one. (In the case where \u003cem\u003eT0\u003c/em\u003e is Object, these are the conversions allowed by  {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}.) The unboxing conversion must have a possibility of success, which means that if \u003cem\u003eT0\u003c/em\u003e is not itself a wrapper class, there must exist at least one wrapper class \u003cem\u003eTW\u003c/em\u003e which is a subtype of \u003cem\u003eT0\u003c/em\u003e and whose unboxed primitive value can be widened to \u003cem\u003eT1\u003c/em\u003e. \u003cli\u003eIf the return type \u003cem\u003eT1\u003c/em\u003e is marked as void, any returned value is discarded \u003cli\u003eIf the return type \u003cem\u003eT0\u003c/em\u003e is void and \u003cem\u003eT1\u003c/em\u003e a reference, a null value is introduced. \u003cli\u003eIf the return type \u003cem\u003eT0\u003c/em\u003e is void and \u003cem\u003eT1\u003c/em\u003e a primitive, a zero value is introduced. \u003c/ul\u003e (\u003cem\u003eNote:\u003c/em\u003e Both \u003cem\u003eT0\u003c/em\u003e and \u003cem\u003eT1\u003c/em\u003e may be regarded as static types, because neither corresponds specifically to the \u003cem\u003edynamic type\u003c/em\u003e of any actual argument or return value.) \u003cp\u003e The method handle conversion cannot be made if any one of the required pairwise conversions cannot be made. \u003cp\u003e At runtime, the conversions applied to reference arguments or return values may require additional runtime checks which can fail. An unboxing operation may fail because the original reference is null, causing a  {@link java.lang.NullPointerException NullPointerException}. An unboxing operation or a reference cast may also fail on a reference to an object of the wrong type, causing a  {@link java.lang.ClassCastException ClassCastException}. Although an unboxing operation may accept several kinds of wrappers, if none are available, a  {@code ClassCastException} will be thrown.\n * @param newType the expected type of the new method handle\n * @return a method handle which delegates to {@code this} after performingany necessary argument conversions, and arranges for any necessary return value conversions\n * @throws NullPointerException if {@code newType} is a null reference\n * @throws WrongMethodTypeException if the conversion cannot be made\n * @see MethodHandles#explicitCastArguments\n */\n","tf":{"freq":{"need":2,"accept":1,"variabl":1,"particular":1,"subtyp":1,"zero":1,"desir":1,"expect":1,"although":1,"inexact":1,"fail":3,"wrapper":5,"oper":3,"refer":10,"report":1,"relat":1,"invok":10,"runtim":3,"describ":1,"avail":1,"regard":1,"involv":1,"provid":1,"els":1,"invoc":2,"explicit":1,"will":3,"pointer":3,"calle":2,"array":1,"go":1,"caller":2,"linkplain":1,"primit":8,"descriptor":1,"behavior":1,"correspond":4,"link":6,"made":3,"pairwis":2,"discard":1,"kind":1,"deleg":1,"current":2,"note":1,"addit":1,"may":6,"differ":2,"compon":1,"intern":1,"method":23,"unbox":6,"reflect":2,"old":3,"vararg":1,"least":1,"possibl":3,"perform":2,"type":37,"necessari":2,"must":4,"requir":2,"equival":1,"exact":4,"none":1,"everi":1,"dynam":2,"follow":3,"argument":12,"thrown":1,"except":7,"index":1,"whose":1,"mark":1,"appli":8,"cast":7,"match":2,"make":1,"collect":1,"incom":1,"otherwis":1,"call":1,"result":2,"defin":1,"valid":1,"allow":1,"one":7,"performingani":1,"convers":19,"convert":6,"way":2,"adapt":2,"object":2,"lang":4,"introduc":2,"elsewher":1,"collector":1,"mean":2,"valu":15,"plain":2,"exist":3,"consult":1,"ariti":1,"check":1,"crucial":1,"supertyp":1,"guarante":1,"origin":5,"paramet":3,"equal":2,"produc":1,"list":4,"arrang":1,"sever":2,"handl":15,"neither":1,"two":1,"specif":4,"caus":2,"orderto":1,"widen":4,"actual":1,"wrong":2,"java":7,"box":1,"chang":1,"success":1,"also":2,"atch":1,"step":2},"maxFreq":37,"totalTerms":398},"loc":6}