{"id":13236,"className":"java.lang.Float","methodName":"intBitsToFloat","signature":"\u003cjava.lang.Float: float intBitsToFloat(int)\u003e","javadoc":"/** \n * Returns the  {@code float} value corresponding to a givenbit representation. The argument is considered to be a representation of a floating-point value according to the IEEE 754 floating-point \"single format\" bit layout. \u003cp\u003eIf the argument is  {@code 0x7f800000}, the result is positive infinity. \u003cp\u003eIf the argument is  {@code 0xff800000}, the result is negative infinity. \u003cp\u003eIf the argument is any value in the range {@code 0x7f800001} through {@code 0x7fffffff} or inthe range  {@code 0xff800001} through{@code 0xffffffff}, the result is a NaN.  No IEEE 754 floating-point operation provided by Java can distinguish between two NaN values of the same type with different bit patterns.  Distinct values of NaN are only distinguishable by use of the  {@code Float.floatToRawIntBits} method.\u003cp\u003eIn all other cases, let \u003ci\u003es\u003c/i\u003e, \u003ci\u003ee\u003c/i\u003e, and \u003ci\u003em\u003c/i\u003e be three values that can be computed from the argument: \u003cblockquote\u003e\u003cpre\u003e int s \u003d ((bits \u0026gt;\u0026gt; 31) \u003d\u003d 0) ? 1 : -1; int e \u003d ((bits \u0026gt;\u0026gt; 23) \u0026 0xff); int m \u003d (e \u003d\u003d 0) ? (bits \u0026 0x7fffff) \u0026lt;\u0026lt; 1 : (bits \u0026 0x7fffff) | 0x800000; \u003c/pre\u003e\u003c/blockquote\u003e Then the floating-point result equals the value of the mathematical expression \u003ci\u003es\u003c/i\u003e\u0026middot;\u003ci\u003em\u003c/i\u003e\u0026middot;2\u003csup\u003e\u003ci\u003ee\u003c/i\u003e-150\u003c/sup\u003e. \u003cp\u003eNote that this method may not be able to return a {@code float} NaN with exactly same bit pattern as the{@code int} argument.  IEEE 754 distinguishes between twokinds of NaNs, quiet NaNs and \u003ci\u003esignaling NaNs\u003c/i\u003e.  The differences between the two kinds of NaN are generally not visible in Java.  Arithmetic operations on signaling NaNs turn them into quiet NaNs with a different, but often similar, bit pattern.  However, on some processors merely copying a signaling NaN also performs that conversion.  In particular, copying a signaling NaN to return it to the calling method may perform this conversion.  So  {@code intBitsToFloat} maynot be able to return a  {@code float} with a signaling NaNbit pattern.  Consequently, for some  {@code int} values,{@code floatToRawIntBits(intBitsToFloat(start))} may\u003ci\u003enot\u003c/i\u003e equal  {@code start}.  Moreover, which particular bit patterns represent signaling NaNs is platform dependent; although all NaN bit patterns, quiet or signaling, must be in the NaN range identified above.\n * @param bits   an integer.\n * @return  the {@code float} floating-point value with the same bitpattern.\n */\n","tf":{"freq":{"singl":1,"infin":2,"consequ":1,"arithmet":1,"particular":2,"perform":2,"abl":2,"type":1,"must":1,"copi":2,"distinct":1,"although":1,"oper":2,"moreov":1,"rang":3,"blockquot":2,"exact":1,"three":1,"processor":1,"howev":1,"argument":6,"platform":1,"turn":1,"twokind":1,"bitpattern":1,"middot":2,"quiet":3,"format":1,"provid":1,"bit":16,"start":2,"often":1,"distinguish":3,"comput":1,"negat":1,"mere":1,"posit":1,"raw":2,"call":1,"result":4,"visibl":1,"correspond":1,"convers":2,"xff":3,"use":1,"identifi":1,"signal":7,"express":1,"sup":2,"kind":1,"consid":1,"xffffffff":1,"givenbit":1,"fffffff":1,"inth":1,"layout":1,"valu":9,"note":1,"similar":1,"may":3,"repres":1,"depend":1,"mathemat":1,"equal":2,"accord":1,"general":1,"represent":2,"point":5,"two":2,"differ":3,"pattern":6,"maynot":1,"pre":2,"nbit":1,"java":2,"method":3,"fffff":2,"integ":1,"also":1},"maxFreq":16,"totalTerms":157},"loc":0}