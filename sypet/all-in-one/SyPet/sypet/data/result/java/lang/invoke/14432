{"id":14432,"className":"java.lang.invoke.MethodHandle","methodName":"asVarargsCollector","signature":"\u003cjava.lang.invoke.MethodHandle: java.lang.invoke.MethodHandle asVarargsCollector(java.lang.Class)\u003e","javadoc":"/** \n * Makes a \u003cem\u003evariable arity\u003c/em\u003e adapter which is able to accept any number of trailing positional arguments and collect them into an array argument. \u003cp\u003e The type and behavior of the adapter will be the same as the type and behavior of the target, except that certain {@code invoke} and {@code asType} requests can lead totrailing positional arguments being collected into target\u0027s trailing parameter. Also, the last parameter type of the adapter will be {@code arrayType}, even if the target has a different last parameter type. \u003cp\u003e This transformation may return  {@code this} if the method handle isalready of variable arity and its trailing parameter type is identical to  {@code arrayType}. \u003cp\u003e When called with  {@link #invokeExact invokeExact}, the adapter invokes the target with no argument changes. (\u003cem\u003eNote:\u003c/em\u003e This behavior is different from a {@linkplain #asCollector fixed arity collector}, since it accepts a whole array of indeterminate length, rather than a fixed number of arguments.) \u003cp\u003e When called with plain, inexact  {@link #invoke invoke}, if the caller type is the same as the adapter, the adapter invokes the target as with {@code invokeExact}. (This is the normal behavior for  {@code invoke} when types match.)\u003cp\u003e Otherwise, if the caller and adapter arity are the same, and the trailing parameter type of the caller is a reference type identical to or assignable to the trailing parameter type of the adapter, the arguments and return values are converted pairwise, as if by  {@link #asType asType} on a fixed aritymethod handle. \u003cp\u003e Otherwise, the arities differ, or the adapter\u0027s trailing parameter type is not assignable from the corresponding caller type. In this case, the adapter replaces all trailing arguments from the original trailing argument position onward, by a new array of type  {@code arrayType}, whose elements comprise (in order) the replaced arguments. \u003cp\u003e The caller type must provides as least enough arguments, and of the correct type, to satisfy the target\u0027s requirement for positional arguments before the trailing array argument. Thus, the caller must supply, at a minimum,  {@code N-1} arguments,where  {@code N} is the arity of the target.Also, there must exist conversions from the incoming arguments to the target\u0027s arguments. As with other uses of plain  {@code invoke}, if these basic requirements are not fulfilled, a  {@code WrongMethodTypeException}may be thrown. \u003cp\u003e In all cases, what the target eventually returns is returned unchanged by the adapter. \u003cp\u003e In the final case, it is exactly as if the target method handle were temporarily adapted with a  {@linkplain #asCollector fixed arity collector}to the arity required by the caller type. (As with  {@code asCollector}, if the array length is zero, a shared constant may be used instead of a new array. If the implied call to  {@code asCollector} would throwan  {@code IllegalArgumentException} or {@code WrongMethodTypeException}, the call to the variable arity adapter must throw {@code WrongMethodTypeException}.) \u003cp\u003e The behavior of  {@link #asType asType} is also specialized forvariable arity adapters, to maintain the invariant that plain, inexact  {@code invoke} is always equivalent to an {@code asType}call to adjust the target type, followed by  {@code invokeExact}. Therefore, a variable arity adapter responds to an  {@code asType} request by building a fixed arity collector,if and only if the adapter and requested type differ either in arity or trailing argument type. The resulting fixed arity collector has its type further adjusted (if necessary) to the requested type by pairwise conversion, as if by another application of  {@code asType}. \u003cp\u003e When a method handle is obtained by executing an  {@code ldc} instructionof a  {@code CONSTANT_MethodHandle} constant, and the target method is markedas a variable arity method (with the modifier bit  {@code 0x0080}), the method handle will accept multiple arities, as if the method handle constant were created by means of a call to  {@code asVarargsCollector}. \u003cp\u003e In order to create a collecting adapter which collects a predetermined number of arguments, and whose type reflects this predetermined number, use  {@link #asCollector asCollector} instead.\u003cp\u003e No method handle transformations produce new method handles with variable arity, unless they are documented as doing so. Therefore, besides  {@code asVarargsCollector}, all methods in  {@code MethodHandle} and {@code MethodHandles}will return a method handle with fixed arity, except in the cases where they are specified to return their original operand (e.g.,  {@code asType} of the method handle\u0027s own type).\u003cp\u003e Calling  {@code asVarargsCollector} on a method handle which is alreadyof variable arity will produce a method handle with the same type and behavior. It may (or may not) return the original variable arity method handle. \u003cp\u003e Here is an example, of a list-making variable arity method handle: \u003cblockquote\u003e\u003cpre\u003e MethodHandle deepToString \u003d publicLookup() .findStatic(Arrays.class, \"deepToString\", methodType(String.class, Object[].class)); MethodHandle ts1 \u003d deepToString.asVarargsCollector(Object[].class); assertEquals(\"[won]\",   (String) ts1.invokeExact(    new Object[]{\"won\"})); assertEquals(\"[won]\",   (String) ts1.invoke(         new Object[]{\"won\"})); assertEquals(\"[won]\",   (String) ts1.invoke(                      \"won\" )); assertEquals(\"[[won]]\", (String) ts1.invoke((Object) new Object[]{\"won\"})); // findStatic of Arrays.asList(...) produces a variable arity method handle: MethodHandle asList \u003d publicLookup() .findStatic(Arrays.class, \"asList\", methodType(List.class, Object[].class)); assertEquals(methodType(List.class, Object[].class), asList.type()); assert(asList.isVarargsCollector()); assertEquals(\"[]\", asList.invoke().toString()); assertEquals(\"[1]\", asList.invoke(1).toString()); assertEquals(\"[two, too]\", asList.invoke(\"two\", \"too\").toString()); String[] argv \u003d { \"three\", \"thee\", \"tee\" }; assertEquals(\"[three, thee, tee]\", asList.invoke(argv).toString()); assertEquals(\"[three, thee, tee]\", asList.invoke((Object[])argv).toString()); List ls \u003d (List) asList.invoke((Object)argv); assertEquals(1, ls.size()); assertEquals(\"[three, thee, tee]\", Arrays.toString((Object[])ls.get(0))); \u003c/pre\u003e\u003c/blockquote\u003e \u003cp style\u003d\"font-size:smaller;\"\u003e \u003cem\u003eDiscussion:\u003c/em\u003e These rules are designed as a dynamically-typed variation of the Java rules for variable arity methods. In both cases, callers to a variable arity method or method handle can either pass zero or more positional arguments, or else pass pre-collected arrays of any length.  Users should be aware of the special role of the final argument, and of the effect of a type match on that final argument, which determines whether or not a single trailing argument is interpreted as a whole array or a single element of an array to be collected. Note that the dynamic type of the trailing argument has no effect on this decision, only a comparison between the symbolic type descriptor of the call site and the type descriptor of the method handle.)\n * @param arrayType often {@code Object[]}, the type of the array argument which will collect the arguments\n * @return a new method handle which can collect any number of trailing argumentsinto an array, before calling the original method handle\n * @throws NullPointerException if {@code arrayType} is a null reference\n * @throws IllegalArgumentException if {@code arrayType} is not an array typeor  {@code arrayType} is not assignable to this method handle\u0027s trailing parameter type\n * @see #asCollector\n * @see #isVarargsCollector\n * @see #asFixedArity\n */\n","tf":{"freq":{"assign":3,"singl":2,"accept":3,"maintain":1,"variabl":12,"abl":1,"zero":2,"lookup":2,"whether":1,"specifi":1,"inexact":2,"correct":1,"refer":2,"blockquot":2,"respond":1,"impli":1,"role":1,"deep":3,"throwan":1,"element":2,"unchang":1,"predetermin":2,"multipl":1,"alway":1,"invok":22,"temporarili":1,"number":5,"typeor":1,"provid":1,"els":1,"bit":1,"obtain":1,"discuss":1,"will":6,"pointer":1,"posit":5,"thee":4,"array":23,"caller":8,"linkplain":2,"markeda":1,"eventu":1,"descriptor":2,"minimum":1,"decis":1,"isalreadi":1,"behavior":6,"correspond":1,"link":5,"argumentsinto":1,"pairwis":2,"use":3,"anoth":1,"therefor":2,"build":1,"applic":1,"aritymethod":1,"transform":2,"document":1,"unless":1,"adjust":2,"length":3,"rather":1,"note":2,"site":1,"forvari":1,"may":5,"totrail":1,"differ":4,"either":2,"string":15,"satisfi":1,"exampl":1,"method":36,"design":1,"reflect":1,"last":2,"vararg":7,"instructionof":1,"least":1,"normal":1,"tee":4,"lead":1,"besid":1,"type":54,"enough":1,"necessari":1,"must":4,"compris":1,"requir":3,"variat":1,"equival":1,"basic":1,"exact":6,"trail":14,"request":4,"three":4,"dynam":2,"follow":1,"argument":26,"except":8,"thrown":1,"symbol":1,"creat":2,"onward":1,"whose":2,"font":1,"alreadyof":1,"ldc":1,"comparison":1,"invari":1,"size":2,"often":1,"whole":2,"determin":1,"argv":4,"even":1,"match":2,"execut":1,"make":2,"collect":8,"incom":1,"otherwis":2,"result":1,"call":9,"interpret":1,"convers":2,"convert":1,"object":12,"adapt":17,"fulfil":1,"smaller":1,"collector":18,"share":1,"style":1,"ident":2,"order":2,"fix":8,"rule":2,"mean":1,"indetermin":1,"valu":1,"plain":3,"exist":1,"find":3,"ariti":25,"constant":3,"thus":1,"paramet":8,"origin":4,"equal":12,"list":16,"produc":3,"suppli":1,"operand":1,"illeg":2,"pass":2,"handl":26,"two":2,"effect":2,"pre":3,"replac":2,"awar":1,"modifi":1,"target":12,"instead":2,"java":1,"wrong":3,"special":2,"chang":1,"certain":1,"user":1,"also":3},"maxFreq":54,"totalTerms":663},"loc":7}