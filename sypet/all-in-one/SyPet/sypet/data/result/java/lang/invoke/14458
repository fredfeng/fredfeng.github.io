{"id":14458,"className":"java.lang.invoke.MethodHandles$Lookup","methodName":"unreflectSpecial","signature":"\u003cjava.lang.invoke.MethodHandles$Lookup: java.lang.invoke.MethodHandle unreflectSpecial(java.lang.reflect.Method,java.lang.Class)\u003e","javadoc":"/** \n * Produces a method handle for a reflected method. It will bypass checks for overriding methods on the receiver, as if by a  {@code invokespecial} instruction from within the {@code specialCaller}. The type of the method handle will be that of the method, with the special caller type prepended (and \u003cem\u003enot\u003c/em\u003e the receiver of the method). If the method\u0027s  {@code accessible} flag is not set,access checking is performed immediately on behalf of the lookup class, as if  {@code invokespecial} instruction were being linked.\u003cp\u003e The returned method handle will have {@linkplain MethodHandle#asVarargsCollector variable arity} if and only ifthe method\u0027s variable arity modifier bit ( {@code 0x0080}) is set.\n * @param m the reflected method\n * @param specialCaller the class nominally calling the method\n * @return a method handle which can invoke the reflected method\n * @throws IllegalAccessException if access checking failsor if the method\u0027s variable arity modifier bit is set and  {@code asVarargsCollector} fails\n * @throws NullPointerException if any argument is null\n */\n","tf":{"freq":{"caller":3,"behalf":1,"call":1,"linkplain":1,"vararg":2,"variabl":3,"link":1,"perform":1,"type":2,"lookup":1,"collector":2,"fail":1,"instruct":2,"unreflect":1,"immedi":1,"nomin":1,"argument":1,"ariti":3,"except":2,"ifth":1,"check":3,"invok":1,"prepend":1,"receiv":2,"produc":1,"access":4,"illeg":1,"handl":5,"bit":2,"failsor":1,"flag":1,"modifi":2,"bypass":1,"will":3,"pointer":1,"method":15,"special":4,"invokespeci":2,"within":1,"reflect":3},"maxFreq":15,"totalTerms":85},"loc":9}