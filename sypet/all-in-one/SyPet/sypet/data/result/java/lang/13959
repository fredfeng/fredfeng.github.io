{"id":13959,"className":"java.lang.ClassValue","methodName":"remove","signature":"\u003cjava.lang.ClassValue: void remove(java.lang.Class)\u003e","javadoc":"/** \n * Removes the associated value for the given class. If this value is subsequently  {@linkplain #get read} for the same class,its value will be reinitialized by invoking its  {@link #computeValue computeValue} method.This may result in an additional invocation of the {@code computeValue} method for the given class.\u003cp\u003e In order to explain the interaction between  {@code get} and {@code remove} calls,we must model the state transitions of a class value to take into account the alternation between uninitialized and initialized states. To do this, number these states sequentially from zero, and note that uninitialized (or removed) states are numbered with even numbers, while initialized (or re-initialized) states have odd numbers. \u003cp\u003e When a thread  {@code T} removes a class value in state {@code 2N}, nothing happens, since the class value is already uninitialized. Otherwise, the state is advanced atomically to  {@code 2N+1}. \u003cp\u003e When a thread  {@code T} queries a class value in state {@code 2N}, the thread first attempts to initialize the class value to state  {@code 2N+1}by invoking  {@code computeValue} and installing the resulting value.\u003cp\u003e When  {@code T} attempts to install the newly computed value,if the state is still at  {@code 2N}, the class value will be initialized with the computed value, advancing it to state  {@code 2N+1}. \u003cp\u003e Otherwise, whether the new state is even or odd, {@code T} will discard the newly computed valueand retry the  {@code get} operation.\u003cp\u003e Discarding and retrying is an important proviso, since otherwise  {@code T} could potentially installa disastrously stale value.  For example: \u003cul\u003e \u003cli\u003e {@code T} calls {@code CV.get(C)} and sees state {@code 2N}\u003cli\u003e {@code T} quickly computes a time-dependent value {@code V0} and gets ready to install it\u003cli\u003e {@code T} is hit by an unlucky paging or scheduling event, and goes to sleep for a long time\u003cli\u003e...meanwhile,  {@code T2} also calls {@code CV.get(C)} and sees state {@code 2N}\u003cli\u003e {@code T2} quickly computes a similar time-dependent value {@code V1} and installs it on {@code CV.get(C)}\u003cli\u003e {@code T2} (or a third thread) then calls {@code CV.remove(C)}, undoing  {@code T2}\u0027s work \u003cli\u003e the previous actions of  {@code T2} are repeated several times\u003cli\u003e also, the relevant computed values change over time:  {@code V1},  {@code V2}, ... \u003cli\u003e...meanwhile,  {@code T} wakes up and attempts to install {@code V0}; \u003cem\u003ethis must fail\u003c/em\u003e \u003c/ul\u003e We can assume in the above scenario that  {@code CV.computeValue} uses locks to properlyobserve the time-dependent states as it computes  {@code V1}, etc. This does not remove the threat of a stale value, since there is a window of time between the return of  {@code computeValue} in {@code T} and the installationof the the new value.  No user synchronization is possible during this time.\n * @param type the type whose class value must be removed\n * @throws NullPointerException if the argument is null\n */\n","tf":{"freq":{"threat":1,"etc":1,"zero":1,"whether":1,"time":8,"given":2,"fail":1,"oper":1,"page":1,"event":1,"thread":4,"happen":1,"disastr":1,"invok":2,"remov":8,"properlyobserv":1,"number":4,"sleep":1,"third":1,"invoc":1,"newli":2,"queri":1,"scenario":1,"advanc":2,"will":3,"pointer":1,"explain":1,"readi":1,"valueand":1,"linkplain":1,"goe":1,"link":1,"use":1,"discard":2,"retri":2,"associ":1,"noth":1,"initi":5,"note":1,"similar":1,"addit":1,"may":1,"assum":1,"previous":1,"reiniti":1,"potenti":1,"uniniti":3,"exampl":1,"account":1,"alreadi":1,"method":2,"interact":1,"atom":1,"undo":1,"relev":1,"proviso":1,"possibl":1,"type":2,"transit":1,"must":3,"altern":1,"hit":1,"action":1,"sequenti":1,"argument":1,"work":1,"installationof":1,"except":1,"whose":1,"installa":1,"window":1,"comput":13,"even":2,"odd":2,"stale":2,"meanwhil":2,"attempt":3,"otherwis":3,"result":2,"call":4,"model":1,"state":15,"quick":2,"schedul":1,"repeat":1,"order":1,"wake":1,"read":1,"valu":25,"subsequ":1,"depend":3,"instal":5,"lock":1,"still":1,"sever":1,"take":1,"chang":1,"first":1,"also":2,"user":1,"unlucki":1},"maxFreq":25,"totalTerms":209},"loc":8}