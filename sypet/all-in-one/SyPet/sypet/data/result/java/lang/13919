{"id":13919,"className":"java.lang.Thread","methodName":"destroy","signature":"\u003cjava.lang.Thread: void destroy()\u003e","javadoc":"/** \n * Throws  {@link NoSuchMethodError}.\n * @deprecated This method was originally designed to destroy thisthread without any cleanup. Any monitors it held would have remained locked. However, the method was never implemented. If if were to be implemented, it would be deadlock-prone in much the manner of  {@link #suspend}. If the target thread held a lock protecting a critical system resource when it was destroyed, no thread could ever access this resource again. If another thread ever attempted to lock this resource, deadlock would result. Such deadlocks typically manifest themselves as \"frozen\" processes. For more information, see \u003ca href\u003d\" {@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html\"\u003e Why are Thread.stop, Thread.suspend and Thread.resume Deprecated?\u003c/a\u003e.\n * @throws NoSuchMethodError always\n */\n","tf":{"freq":{"attempt":1,"suspend":2,"stop":1,"primit":1,"result":1,"cleanup":1,"deprec":3,"root":1,"concurr":1,"link":2,"manifest":1,"typic":1,"anoth":1,"frozen":1,"resum":1,"technot":1,"destroy":3,"resourc":3,"thread":7,"howev":1,"href":1,"deadlock":3,"held":2,"monitor":1,"thisthread":1,"error":2,"alway":1,"origin":1,"lock":3,"access":1,"without":1,"much":1,"prone":1,"guid":1,"process":1,"inform":1,"system":1,"never":1,"remain":1,"target":1,"html":1,"method":4,"manner":1,"ever":2,"design":1,"critic":1},"maxFreq":7,"totalTerms":70},"loc":3}