{"id":14013,"className":"java.lang.Double","methodName":"longBitsToDouble","signature":"\u003cjava.lang.Double: double longBitsToDouble(long)\u003e","javadoc":"/** \n * Returns the  {@code double} value corresponding to a givenbit representation. The argument is considered to be a representation of a floating-point value according to the IEEE 754 floating-point \"double format\" bit layout. \u003cp\u003eIf the argument is  {@code 0x7ff0000000000000L}, the result is positive infinity. \u003cp\u003eIf the argument is  {@code 0xfff0000000000000L}, the result is negative infinity. \u003cp\u003eIf the argument is any value in the range {@code 0x7ff0000000000001L} through{@code 0x7fffffffffffffffL} or in the range{@code 0xfff0000000000001L} through{@code 0xffffffffffffffffL}, the result is a NaN.  No IEEE 754 floating-point operation provided by Java can distinguish between two NaN values of the same type with different bit patterns.  Distinct values of NaN are only distinguishable by use of the  {@code Double.doubleToRawLongBits} method.\u003cp\u003eIn all other cases, let \u003ci\u003es\u003c/i\u003e, \u003ci\u003ee\u003c/i\u003e, and \u003ci\u003em\u003c/i\u003e be three values that can be computed from the argument: \u003cblockquote\u003e\u003cpre\u003e int s \u003d ((bits \u0026gt;\u0026gt; 63) \u003d\u003d 0) ? 1 : -1; int e \u003d (int)((bits \u0026gt;\u0026gt; 52) \u0026 0x7ffL); long m \u003d (e \u003d\u003d 0) ? (bits \u0026 0xfffffffffffffL) \u0026lt;\u0026lt; 1 : (bits \u0026 0xfffffffffffffL) | 0x10000000000000L; \u003c/pre\u003e\u003c/blockquote\u003e Then the floating-point result equals the value of the mathematical expression \u003ci\u003es\u003c/i\u003e\u0026middot;\u003ci\u003em\u003c/i\u003e\u0026middot;2\u003csup\u003e\u003ci\u003ee\u003c/i\u003e-1075\u003c/sup\u003e. \u003cp\u003eNote that this method may not be able to return a {@code double} NaN with exactly same bit pattern as the{@code long} argument.  IEEE 754 distinguishes between twokinds of NaNs, quiet NaNs and \u003ci\u003esignaling NaNs\u003c/i\u003e.  The differences between the two kinds of NaN are generally not visible in Java.  Arithmetic operations on signaling NaNs turn them into quiet NaNs with a different, but often similar, bit pattern.  However, on some processors merely copying a signaling NaN also performs that conversion.  In particular, copying a signaling NaN to return it to the calling method may perform this conversion.  So  {@code longBitsToDouble}may not be able to return a  {@code double} with asignaling NaN bit pattern.  Consequently, for some {@code long} values,{@code doubleToRawLongBits(longBitsToDouble(start))} may\u003ci\u003enot\u003c/i\u003e equal  {@code start}.  Moreover, which particular bit patterns represent signaling NaNs is platform dependent; although all NaN bit patterns, quiet or signaling, must be in the NaN range identified above.\n * @param bits   any {@code long} integer.\n * @return  the {@code double} floating-point value with the samebit pattern.\n */\n","tf":{"freq":{"xfffffffffffff":2,"infin":2,"consequ":1,"arithmet":1,"particular":2,"perform":2,"samebit":1,"abl":2,"type":1,"must":1,"copi":2,"distinct":1,"although":1,"oper":2,"moreov":1,"rang":3,"blockquot":2,"xffffffffffffffff":1,"exact":1,"three":1,"processor":1,"howev":1,"argument":6,"platform":1,"turn":1,"xfff":2,"twokind":1,"middot":2,"format":1,"quiet":3,"provid":1,"bit":17,"start":2,"often":1,"distinguish":3,"comput":1,"negat":1,"mere":1,"posit":1,"raw":2,"call":1,"result":4,"fffffffffffffff":1,"visibl":1,"correspond":1,"convers":2,"use":1,"identifi":1,"signal":6,"express":1,"sup":2,"kind":1,"consid":1,"givenbit":1,"layout":1,"valu":9,"note":1,"similar":1,"asign":1,"may":4,"repres":1,"depend":1,"mathemat":1,"equal":2,"accord":1,"general":1,"represent":2,"two":2,"point":5,"differ":3,"pattern":7,"pre":2,"java":2,"method":3,"integ":1,"also":1},"maxFreq":17,"totalTerms":155},"loc":0}