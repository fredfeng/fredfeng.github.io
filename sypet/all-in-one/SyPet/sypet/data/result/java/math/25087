{"id":25087,"className":"java.math.BigDecimal","methodName":"pow","signature":"\u003cjava.math.BigDecimal: java.math.BigDecimal pow(int,java.math.MathContext)\u003e","javadoc":"/** \n * Returns a  {@code BigDecimal} whose value is\u003ctt\u003e(this\u003csup\u003en\u003c/sup\u003e)\u003c/tt\u003e.  The current implementation uses the core algorithm defined in ANSI standard X3.274-1996 with rounding according to the context settings.  In general, the returned numerical value is within two ulps of the exact numerical value for the chosen precision.  Note that future releases may use a different algorithm with a decreased allowable error bound and increased allowable exponent range. \u003cp\u003eThe X3.274-1996 algorithm is: \u003cul\u003e \u003cli\u003e An  {@code ArithmeticException} exception is thrown if\u003cul\u003e \u003cli\u003e {@code abs(n) \u003e 999999999}\u003cli\u003e {@code mc.precision \u003d\u003d 0} and {@code n \u003c 0}\u003cli\u003e {@code mc.precision \u003e 0} and {@code n} has more than{@code mc.precision} decimal digits\u003c/ul\u003e \u003cli\u003e if  {@code n} is zero, {@link #ONE} is returned even if{@code this} is zero, otherwise\u003cul\u003e \u003cli\u003e if  {@code n} is positive, the result is calculated viathe repeated squaring technique into a single accumulator. The individual multiplications with the accumulator use the same math context settings as in  {@code mc} except for aprecision increased to  {@code mc.precision + elength + 1}where  {@code elength} is the number of decimal digits in{@code n}. \u003cli\u003e if  {@code n} is negative, the result is calculated as if{@code n} were positive; this value is then divided into oneusing the working precision specified above. \u003cli\u003e The final value from either the positive or negative case is then rounded to the destination precision. \u003c/ul\u003e \u003c/ul\u003e\n * @param n power to raise this {@code BigDecimal} to.\n * @param mc the context to use.\n * @return \u003ctt\u003ethis\u003csup\u003en\u003c/sup\u003e\u003c/tt\u003e using the ANSI standard X3.274-1996algorithm\n * @throws ArithmeticException if the result is inexact but therounding mode is  {@code UNNECESSARY}, or  {@code n} is outof range.\n * @since  1.5\n */\n","tf":{"freq":{"squar":1,"elength":2,"pow":1,"decreas":1,"singl":1,"arithmet":2,"round":2,"zero":2,"specifi":1,"inexact":1,"rang":2,"exact":1,"precis":7,"power":1,"work":1,"expon":1,"except":4,"thrown":1,"multipl":1,"numer":2,"whose":1,"calcul":2,"number":1,"viath":1,"accumul":2,"digit":2,"outof":1,"negat":2,"even":1,"big":2,"posit":3,"increas":2,"otherwis":1,"defin":1,"result":3,"allow":2,"link":1,"use":5,"repeat":1,"chosen":1,"decim":4,"sup":4,"mode":1,"algorithm":4,"rais":1,"oneus":1,"releas":1,"theround":1,"current":1,"valu":5,"note":1,"individu":1,"may":1,"futur":1,"standard":2,"error":1,"ulp":1,"divid":1,"accord":1,"aprecis":1,"general":1,"techniqu":1,"math":1,"two":1,"differ":1,"either":1,"context":3,"core":1,"within":1,"ab":1,"bound":1,"destin":1},"maxFreq":7,"totalTerms":118},"loc":40}