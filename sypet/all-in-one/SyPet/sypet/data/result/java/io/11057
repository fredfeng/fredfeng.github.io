{"id":11057,"className":"java.io.ObjectInputStream","methodName":"readUnshared","signature":"\u003cjava.io.ObjectInputStream: java.lang.Object readUnshared()\u003e","javadoc":"/** \n * Reads an \"unshared\" object from the ObjectInputStream.  This method is identical to readObject, except that it prevents subsequent calls to readObject and readUnshared from returning additional references to the deserialized instance obtained via this call.  Specifically: \u003cul\u003e \u003cli\u003eIf readUnshared is called to deserialize a back-reference (the stream representation of an object which has been written previously to the stream), an ObjectStreamException will be thrown. \u003cli\u003eIf readUnshared returns successfully, then any subsequent attempts to deserialize back-references to the stream handle deserialized by readUnshared will cause an ObjectStreamException to be thrown. \u003c/ul\u003e Deserializing an object via readUnshared invalidates the stream handle associated with the returned object.  Note that this in itself does not always guarantee that the reference returned by readUnshared is unique; the deserialized object may define a readResolve method which returns an object visible to other parties, or readUnshared may return a Class object or enum constant obtainable elsewhere in the stream or through external means. If the deserialized object defines a readResolve method and the invocation of that method returns an array, then readUnshared returns a shallow clone of that array; this guarantees that the returned array object is unique and cannot be obtained a second time from an invocation of readObject or readUnshared on the ObjectInputStream, even if the underlying data stream has been manipulated. \u003cp\u003eObjectInputStream subclasses which override this method can only be constructed in security contexts possessing the \"enableSubclassImplementation\" SerializablePermission; any attempt to instantiate such a subclass without this permission will cause a SecurityException to be thrown.\n * @return  reference to deserialized object\n * @throws ClassNotFoundException if class of an object to deserializecannot be found\n * @throws StreamCorruptedException if control information in the streamis inconsistent\n * @throws ObjectStreamException if object to deserialize has alreadyappeared in stream\n * @throws OptionalDataException if primitive data is next in stream\n * @throws IOException if an I/O error occurs during deserialization\n * @since   1.4\n */\n","tf":{"freq":{"manipul":1,"via":2,"second":1,"instanti":1,"corrupt":1,"time":1,"uniqu":2,"invalid":1,"refer":5,"permiss":2,"option":1,"alreadyappear":1,"streami":1,"control":1,"clone":1,"thrown":3,"except":9,"shallow":1,"enabl":1,"alway":1,"resolv":2,"prevent":1,"without":1,"invoc":2,"instanc":1,"inform":1,"obtain":3,"input":3,"subclass":3,"will":3,"even":1,"parti":1,"array":3,"attempt":2,"primit":1,"inconsist":1,"call":3,"defin":2,"stream":15,"visibl":1,"next":1,"serializ":1,"data":3,"object":21,"deserializecannot":1,"elsewher":1,"ident":1,"associ":1,"extern":1,"written":1,"possess":1,"read":16,"mean":1,"subsequ":2,"note":1,"addit":1,"may":2,"constant":1,"error":1,"previous":1,"guarante":2,"back":2,"represent":1,"handl":2,"specif":1,"secur":2,"caus":2,"context":1,"method":5,"construct":1,"deseri":10,"success":1,"unshar":11,"occur":1,"found":2},"maxFreq":21,"totalTerms":190},"loc":21}