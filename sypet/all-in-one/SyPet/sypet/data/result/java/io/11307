{"id":11307,"className":"java.io.InputStream","methodName":"mark","signature":"\u003cjava.io.InputStream: void mark(int)\u003e","javadoc":"/** \n * Marks the current position in this input stream. A subsequent call to the \u003ccode\u003ereset\u003c/code\u003e method repositions this stream at the last marked position so that subsequent reads re-read the same bytes. \u003cp\u003e The \u003ccode\u003ereadlimit\u003c/code\u003e arguments tells this input stream to allow that many bytes to be read before the mark position gets invalidated. \u003cp\u003e The general contract of \u003ccode\u003emark\u003c/code\u003e is that, if the method \u003ccode\u003emarkSupported\u003c/code\u003e returns \u003ccode\u003etrue\u003c/code\u003e, the stream somehow remembers all the bytes read after the call to \u003ccode\u003emark\u003c/code\u003e and stands ready to supply those same bytes again if and whenever the method \u003ccode\u003ereset\u003c/code\u003e is called.  However, the stream is not required to remember any data at all if more than \u003ccode\u003ereadlimit\u003c/code\u003e bytes are read from the stream before \u003ccode\u003ereset\u003c/code\u003e is called. \u003cp\u003e Marking a closed stream should not have any effect on the stream. \u003cp\u003e The \u003ccode\u003emark\u003c/code\u003e method of \u003ccode\u003eInputStream\u003c/code\u003e does nothing.\n * @param readlimit   the maximum limit of bytes that can be read beforethe mark position becomes invalid.\n * @see java.io.InputStream#reset()\n */\n","tf":{"freq":{"call":4,"stream":10,"last":1,"allow":1,"somehow":1,"data":1,"close":1,"becom":1,"requir":1,"invalid":2,"current":1,"noth":1,"read":6,"reset":4,"tell":1,"howev":1,"subsequ":2,"limit":1,"reposit":1,"argument":1,"whenev":1,"mani":1,"support":1,"contract":1,"rememb":2,"true":1,"suppli":1,"mark":10,"beforeth":1,"general":1,"readlimit":3,"input":4,"effect":1,"stand":1,"maximum":1,"java":1,"method":4,"posit":4,"readi":1},"maxFreq":10,"totalTerms":82},"loc":1}