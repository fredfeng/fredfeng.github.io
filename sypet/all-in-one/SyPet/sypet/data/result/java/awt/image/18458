{"id":18458,"className":"java.awt.image.DirectColorModel","methodName":"DirectColorModel","signature":"\u003cjava.awt.image.DirectColorModel: void DirectColorModel(java.awt.color.ColorSpace,int,int,int,int,int,boolean,int)\u003e","javadoc":"/** \n * Constructs a \u003ccode\u003eDirectColorModel\u003c/code\u003e from the specified parameters.  Color components are in the specified \u003ccode\u003eColorSpace\u003c/code\u003e, which must be of type ColorSpace.TYPE_RGB and have minimum normalized component values which are all 0.0 and maximum values which are all 1.0. The masks specify which bits in an \u003ccode\u003eint\u003c/code\u003e pixel representation contain the red, green and blue color samples and the alpha sample, if present.  If \u003ccode\u003eamask\u003c/code\u003e is 0, pixel values do not contain alpha information and all pixels are treated as opaque, which means that alpha\u0026nbsp;\u003d\u0026nbsp;1.0.  All of the bits in each mask must be contiguous and fit in the specified number of least significant bits of an \u003ccode\u003eint\u003c/code\u003e pixel representation.  If there is alpha, the \u003ccode\u003eboolean\u003c/code\u003e \u003ccode\u003eisAlphaPremultiplied\u003c/code\u003e specifies how to interpret color and alpha samples in pixel values.  If the \u003ccode\u003eboolean\u003c/code\u003e is \u003ccode\u003etrue\u003c/code\u003e, color samples are assumed to have been multiplied by the alpha sample.  The transparency value is Transparency.OPAQUE, if no alpha is present, or Transparency.TRANSLUCENT otherwise.  The transfer type is the type of primitive array used to represent pixel values and must be one of DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT, or DataBuffer.TYPE_INT.\n * @param space the specified \u003ccode\u003eColorSpace\u003c/code\u003e\n * @param bits the number of bits in the pixel values; for example,the sum of the number of bits in the masks.\n * @param rmask specifies a mask indicating which bits in aninteger pixel contain the red component\n * @param gmask specifies a mask indicating which bits in aninteger pixel contain the green component\n * @param bmask specifies a mask indicating which bits in aninteger pixel contain the blue component\n * @param amask specifies a mask indicating which bits in aninteger pixel contain the alpha component\n * @param isAlphaPremultiplied \u003ccode\u003etrue\u003c/code\u003e if color samples arepremultiplied by the alpha sample; \u003ccode\u003efalse\u003c/code\u003e otherwise\n * @param transferType the type of array used to represent pixel values\n * @throws IllegalArgumentException if \u003ccode\u003espace\u003c/code\u003e is not aTYPE_RGB space or if the min/max normalized component values are not 0.0/1.0.\n */\n","tf":{"freq":{"fals":1,"least":1,"rmask":1,"normal":2,"amask":2,"mask":7,"type":5,"must":3,"specifi":10,"buffer":3,"premultipli":2,"nbsp":2,"argument":1,"except":1,"transfer":2,"signific":1,"number":3,"bit":10,"present":2,"inform":1,"maximum":1,"contain":6,"treat":1,"array":2,"otherwis":2,"primit":1,"model":2,"gmask":1,"pixel":12,"minimum":1,"one":1,"data":3,"interpret":1,"sum":1,"use":2,"space":6,"bmask":1,"opaqu":1,"fit":1,"transpar":3,"indic":4,"alpha":11,"mean":1,"multipli":1,"valu":9,"min":1,"direct":2,"max":1,"assum":1,"arepremultipli":1,"repres":2,"green":2,"paramet":1,"true":2,"contigu":1,"illeg":1,"represent":2,"red":2,"compon":7,"aninteg":4,"blue":2,"color":10,"exampl":1,"construct":1,"sampl":7},"maxFreq":12,"totalTerms":186},"loc":29}