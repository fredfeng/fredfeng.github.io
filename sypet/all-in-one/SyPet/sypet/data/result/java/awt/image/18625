{"id":18625,"className":"java.awt.image.ComponentSampleModel","methodName":"getDataElements","signature":"\u003cjava.awt.image.ComponentSampleModel: java.lang.Object getDataElements(int,int,java.lang.Object,java.awt.image.DataBuffer)\u003e","javadoc":"/** \n * Returns data for a single pixel in a primitive array of type \u003ccode\u003eTransferType\u003c/code\u003e.  For a \u003ccode\u003eComponentSampleModel\u003c/code\u003e, this is the same as the data type, and samples are returned one per array element.  Generally, \u003ccode\u003eobj\u003c/code\u003e should be passed in as \u003ccode\u003enull\u003c/code\u003e, so that the \u003ccode\u003eObject\u003c/code\u003e is created automatically and is the right primitive data type. \u003cp\u003e The following code illustrates transferring data for one pixel from \u003ccode\u003eDataBuffer\u003c/code\u003e \u003ccode\u003edb1\u003c/code\u003e, whose storage layout is described by \u003ccode\u003eComponentSampleModel\u003c/code\u003e \u003ccode\u003ecsm1\u003c/code\u003e, to \u003ccode\u003eDataBuffer\u003c/code\u003e \u003ccode\u003edb2\u003c/code\u003e, whose storage layout is described by \u003ccode\u003eComponentSampleModel\u003c/code\u003e \u003ccode\u003ecsm2\u003c/code\u003e. The transfer is usually more efficient than using \u003ccode\u003egetPixel\u003c/code\u003e and \u003ccode\u003esetPixel\u003c/code\u003e. \u003cpre\u003e ComponentSampleModel csm1, csm2; DataBufferInt db1, db2; csm2.setDataElements(x, y, csm1.getDataElements(x, y, null, db1), db2); \u003c/pre\u003e Using \u003ccode\u003egetDataElements\u003c/code\u003e and \u003ccode\u003esetDataElements\u003c/code\u003e to transfer between two \u003ccode\u003eDataBuffer/SampleModel\u003c/code\u003e pairs is legitimate if the \u003ccode\u003eSampleModel\u003c/code\u003e objects have the same number of bands, corresponding bands have the same number of bits per sample, and the \u003ccode\u003eTransferType\u003c/code\u003es are the same. \u003cp\u003e If \u003ccode\u003eobj\u003c/code\u003e is not \u003ccode\u003enull\u003c/code\u003e, it should be a primitive array of type \u003ccode\u003eTransferType\u003c/code\u003e. Otherwise, a \u003ccode\u003eClassCastException\u003c/code\u003e is thrown.  An \u003ccode\u003eArrayIndexOutOfBoundsException\u003c/code\u003e might be thrown if the coordinates are not in bounds, or if \u003ccode\u003eobj\u003c/code\u003e is not \u003ccode\u003enull\u003c/code\u003e and is not large enough to hold the pixel data.\n * @param x         the X coordinate of the pixel location\n * @param y         the Y coordinate of the pixel location\n * @param obj       if non-\u003ccode\u003enull\u003c/code\u003e, a primitive arrayin which to return the pixel data\n * @param data      the \u003ccode\u003eDataBuffer\u003c/code\u003e containing the image data\n * @return the data of the specified pixel\n * @see #setDataElements(int,int,Object,DataBuffer)\n * @throws NullPointerException if data is null.\n * @throws ArrayIndexOutOfBoundsException if the coordinates arenot in bounds, or if obj is too small to hold the ouput.\n */\n","tf":{"freq":{"singl":1,"enough":1,"type":7,"specifi":1,"buffer":6,"band":2,"effici":1,"right":1,"follow":1,"coordin":4,"element":7,"transfer":6,"except":4,"thrown":2,"index":2,"whose":2,"creat":1,"hold":2,"describ":2,"number":2,"imag":1,"non":1,"bit":1,"ouput":1,"cast":1,"contain":1,"pointer":1,"small":1,"array":5,"otherwis":1,"primit":4,"might":1,"model":6,"legitim":1,"pixel":9,"pair":1,"correspond":1,"one":2,"data":22,"use":2,"object":3,"automat":1,"arrayin":1,"layout":2,"usual":1,"locat":2,"storag":2,"general":1,"pass":1,"two":1,"per":2,"compon":4,"pre":2,"larg":1,"csm":6,"obj":5,"arenot":1,"illustr":1,"sampl":8,"bound":4},"maxFreq":22,"totalTerms":167},"loc":101}