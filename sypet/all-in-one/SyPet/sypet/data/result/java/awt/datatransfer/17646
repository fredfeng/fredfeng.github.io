{"id":17646,"className":"java.awt.datatransfer.DataFlavor","methodName":"selectBestTextFlavor","signature":"\u003cjava.awt.datatransfer.DataFlavor: java.awt.datatransfer.DataFlavor selectBestTextFlavor(java.awt.datatransfer.DataFlavor[])\u003e","javadoc":"/** \n * Selects the best text \u003ccode\u003eDataFlavor\u003c/code\u003e from an array of \u003ccode\u003e DataFlavor\u003c/code\u003es. Only \u003ccode\u003eDataFlavor.stringFlavor\u003c/code\u003e, and equivalent flavors, and flavors that have a primary MIME type of \"text\", are considered for selection. \u003cp\u003e Flavors are first sorted by their MIME types in the following order: \u003cul\u003e \u003cli\u003e\"text/sgml\" \u003cli\u003e\"text/xml\" \u003cli\u003e\"text/html\" \u003cli\u003e\"text/rtf\" \u003cli\u003e\"text/enriched\" \u003cli\u003e\"text/richtext\" \u003cli\u003e\"text/uri-list\" \u003cli\u003e\"text/tab-separated-values\" \u003cli\u003e\"text/t140\" \u003cli\u003e\"text/rfc822-headers\" \u003cli\u003e\"text/parityfec\" \u003cli\u003e\"text/directory\" \u003cli\u003e\"text/css\" \u003cli\u003e\"text/calendar\" \u003cli\u003e\"application/x-java-serialized-object\" \u003cli\u003e\"text/plain\" \u003cli\u003e\"text/\u0026lt;other\u0026gt;\" \u003c/ul\u003e \u003cp\u003eFor example, \"text/sgml\" will be selected over \"text/html\", and \u003ccode\u003eDataFlavor.stringFlavor\u003c/code\u003e will be chosen over \u003ccode\u003eDataFlavor.plainTextFlavor\u003c/code\u003e. \u003cp\u003e If two or more flavors share the best MIME type in the array, then that MIME type will be checked to see if it supports the charset parameter. \u003cp\u003e The following MIME types support, or are treated as though they support, the charset parameter: \u003cul\u003e \u003cli\u003e\"text/sgml\" \u003cli\u003e\"text/xml\" \u003cli\u003e\"text/html\" \u003cli\u003e\"text/enriched\" \u003cli\u003e\"text/richtext\" \u003cli\u003e\"text/uri-list\" \u003cli\u003e\"text/directory\" \u003cli\u003e\"text/css\" \u003cli\u003e\"text/calendar\" \u003cli\u003e\"application/x-java-serialized-object\" \u003cli\u003e\"text/plain\" \u003c/ul\u003e The following MIME types do not support, or are treated as though they do not support, the charset parameter: \u003cul\u003e \u003cli\u003e\"text/rtf\" \u003cli\u003e\"text/tab-separated-values\" \u003cli\u003e\"text/t140\" \u003cli\u003e\"text/rfc822-headers\" \u003cli\u003e\"text/parityfec\" \u003c/ul\u003e For \"text/\u0026lt;other\u0026gt;\" MIME types, the first time the JRE needs to determine whether the MIME type supports the charset parameter, it will check whether the parameter is explicitly listed in an arbitrarily chosen \u003ccode\u003eDataFlavor\u003c/code\u003e which uses that MIME type. If so, the JRE will assume from that point on that the MIME type supports the charset parameter and will not check again. If the parameter is not explicitly listed, the JRE will assume from that point on that the MIME type does not support the charset parameter and will not check again. Because this check is performed on an arbitrarily chosen \u003ccode\u003eDataFlavor\u003c/code\u003e, developers must ensure that all \u003ccode\u003eDataFlavor\u003c/code\u003es with a \"text/\u0026lt;other\u0026gt;\" MIME type specify the charset parameter if it is supported by that MIME type. Developers should never rely on the JRE to substitute the platform\u0027s default charset for a \"text/\u0026lt;other\u0026gt;\" DataFlavor. Failure to adhere to this restriction will lead to undefined behavior. \u003cp\u003e If the best MIME type in the array does not support the charset parameter, the flavors which share that MIME type will then be sorted by their representation classes in the following order: \u003ccode\u003ejava.io.InputStream\u003c/code\u003e, \u003ccode\u003ejava.nio.ByteBuffer\u003c/code\u003e, \u003ccode\u003e[B\u003c/code\u003e, \u0026lt;all others\u0026gt;. \u003cp\u003e If two or more flavors share the best representation class, or if no flavor has one of the three specified representations, then one of those flavors will be chosen non-deterministically. \u003cp\u003e If the best MIME type in the array does support the charset parameter, the flavors which share that MIME type will then be sorted by their representation classes in the following order: \u003ccode\u003ejava.io.Reader\u003c/code\u003e, \u003ccode\u003ejava.lang.String\u003c/code\u003e, \u003ccode\u003ejava.nio.CharBuffer\u003c/code\u003e, \u003ccode\u003e[C\u003c/code\u003e, \u0026lt;all others\u0026gt;. \u003cp\u003e If two or more flavors share the best representation class, and that representation is one of the four explicitly listed, then one of those flavors will be chosen non-deterministically. If, however, no flavor has one of the four specified representations, the flavors will then be sorted by their charsets. Unicode charsets, such as \"UTF-16\", \"UTF-8\", \"UTF-16BE\", \"UTF-16LE\", and their aliases, are considered best. After them, the platform default charset and its aliases are selected. \"US-ASCII\" and its aliases are worst. All other charsets are chosen in alphabetical order, but only charsets supported by this implementation of the Java platform will be considered. \u003cp\u003e If two or more flavors share the best charset, the flavors will then again be sorted by their representation classes in the following order: \u003ccode\u003ejava.io.InputStream\u003c/code\u003e, \u003ccode\u003ejava.nio.ByteBuffer\u003c/code\u003e, \u003ccode\u003e[B\u003c/code\u003e, \u0026lt;all others\u0026gt;. \u003cp\u003e If two or more flavors share the best representation class, or if no flavor has one of the three specified representations, then one of those flavors will be chosen non-deterministically.\n * @param availableFlavors an array of available \u003ccode\u003eDataFlavor\u003c/code\u003es\n * @return the best (highest fidelity) flavor according to the rulesspecified above, or \u003ccode\u003enull\u003c/code\u003e, if \u003ccode\u003eavailableFlavors\u003c/code\u003e is \u003ccode\u003enull\u003c/code\u003e, has zero length, or contains no text flavors\n * @since 1.3\n */\n","tf":{"freq":{"need":1,"tab":2,"zero":1,"whether":2,"substitut":1,"specifi":4,"time":1,"determinist":3,"undefin":1,"platform":3,"support":12,"charset":16,"avail":3,"header":2,"non":3,"explicit":3,"will":17,"alphabet":1,"css":2,"array":5,"stream":2,"sort":5,"directori":2,"behavior":1,"data":10,"use":1,"applic":2,"rfc":2,"consid":3,"ensur":1,"fidel":1,"length":1,"best":11,"sgml":3,"primari":1,"assum":2,"failur":1,"represent":10,"point":2,"string":3,"exampl":1,"unicod":1,"parityfec":2,"lead":1,"perform":1,"type":17,"though":2,"must":1,"reli":1,"buffer":3,"equival":1,"richtext":2,"arbitrarili":2,"three":2,"howev":1,"follow":6,"text":41,"select":5,"flavor":36,"xml":2,"rtf":2,"uri":2,"restrict":1,"rulesspecifi":1,"input":2,"reader":1,"separ":2,"contain":1,"determin":1,"treat":2,"adher":1,"highest":1,"one":7,"chosen":7,"object":2,"lang":1,"share":7,"order":5,"valu":2,"develop":2,"four":2,"plain":3,"calendar":2,"check":5,"alias":3,"worst":1,"paramet":11,"enrich":2,"list":5,"accord":1,"two":5,"never":1,"java":10,"html":3,"nio":3,"serial":2,"first":2},"maxFreq":41,"totalTerms":386},"loc":19}