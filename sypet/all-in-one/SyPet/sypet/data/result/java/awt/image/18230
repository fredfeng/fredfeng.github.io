{"id":18230,"className":"java.awt.image.WritableRaster","methodName":"setRect","signature":"\u003cjava.awt.image.WritableRaster: void setRect(java.awt.image.Raster)\u003e","javadoc":"/** \n * Copies pixels from Raster srcRaster to this WritableRaster.  Each pixel in srcRaster is copied to the same x,y address in this raster, unless the address falls outside the bounds of this raster.  srcRaster must have the same number of bands as this WritableRaster.  The copy is a simple copy of source samples to the corresponding destination samples. \u003cp\u003e If all samples of both source and destination Rasters are of integral type and less than or equal to 32 bits in size, then calling this method is equivalent to executing the following code for all \u003ccode\u003ex,y\u003c/code\u003e addresses valid in both Rasters. \u003cpre\u003e Raster srcRaster; WritableRaster dstRaster; for (int b \u003d 0; b \u003c srcRaster.getNumBands(); b++) { dstRaster.setSample(x, y, b, srcRaster.getSample(x, y, b)); } \u003c/pre\u003e Thus, when copying an integral type source to an integral type destination, if the source sample size is greater than the destination sample size for a particular band, the high order bits of the source sample are truncated.  If the source sample size is less than the destination size for a particular band, the high order bits of the destination are zero-extended or sign-extended depending on whether srcRaster\u0027s SampleModel treats the sample as a signed or unsigned quantity. \u003cp\u003e When copying a float or double source to an integral type destination, each source sample is cast to the destination type.  When copying an integral type source to a float or double destination, the source is first converted to a 32-bit int (if necessary), using the above rules for integral types, and then the int is cast to float or double. \u003cp\u003e\n * @param srcRaster  The  Raster from which to copy pixels.\n * @throws NullPointerException if srcRaster is null.\n */\n","tf":{"freq":{"integr":6,"greater":1,"simpl":1,"particular":2,"dst":2,"type":7,"zero":1,"necessari":1,"copi":8,"must":1,"whether":1,"band":4,"equival":1,"follow":1,"except":1,"number":1,"writabl":3,"rect":1,"size":5,"sign":2,"bit":4,"cast":2,"outsid":1,"unsign":1,"pointer":1,"sourc":10,"execut":1,"treat":1,"call":1,"valid":1,"model":1,"pixel":3,"correspond":1,"use":1,"convert":1,"truncat":1,"unless":1,"order":2,"rule":1,"src":9,"less":2,"quantiti":1,"thus":1,"depend":1,"equal":1,"raster":21,"num":1,"address":3,"pre":2,"fall":1,"method":1,"high":2,"first":1,"sampl":12,"bound":1,"destin":9},"maxFreq":21,"totalTerms":154},"loc":3}