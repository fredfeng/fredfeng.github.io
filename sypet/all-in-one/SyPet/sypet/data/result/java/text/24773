{"id":24773,"className":"java.text.Format","methodName":"formatToCharacterIterator","signature":"\u003cjava.text.Format: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)\u003e","javadoc":"/** \n * Formats an Object producing an \u003ccode\u003eAttributedCharacterIterator\u003c/code\u003e. You can use the returned \u003ccode\u003eAttributedCharacterIterator\u003c/code\u003e to build the resulting String, as well as to determine information about the resulting String. \u003cp\u003e Each attribute key of the AttributedCharacterIterator will be of type \u003ccode\u003eField\u003c/code\u003e. It is up to each \u003ccode\u003eFormat\u003c/code\u003e implementation to define what the legal values are for each attribute in the \u003ccode\u003eAttributedCharacterIterator\u003c/code\u003e, but typically the attribute key is also used as the attribute value. \u003cp\u003eThe default implementation creates an \u003ccode\u003eAttributedCharacterIterator\u003c/code\u003e with no attributes. Subclasses that support fields should override this and create an \u003ccode\u003eAttributedCharacterIterator\u003c/code\u003e with meaningful attributes.\n * @exception NullPointerException if obj is null.\n * @exception IllegalArgumentException when the Format cannot format thegiven object.\n * @param obj The object to format\n * @return AttributedCharacterIterator describing the formatted value.\n * @since 1.4\n */\n","tf":{"freq":{"legal":1,"result":2,"defin":1,"typic":1,"use":2,"well":1,"object":3,"build":1,"type":1,"attribut":13,"valu":3,"thegiven":1,"key":2,"argument":1,"except":4,"support":1,"charact":8,"creat":2,"describ":1,"produc":1,"meaning":1,"format":7,"illeg":1,"field":2,"inform":1,"determin":1,"string":2,"will":1,"subclass":1,"pointer":1,"obj":2,"iter":8,"also":1},"maxFreq":13,"totalTerms":79},"loc":3}