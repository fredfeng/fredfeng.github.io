{"id":24669,"className":"java.text.DateFormat","methodName":"parse","signature":"\u003cjava.text.DateFormat: java.util.Date parse(java.lang.String,java.text.ParsePosition)\u003e","javadoc":"/** \n * Parse a date/time string according to the given parse position.  For example, a time text  {@code \"07/10/96 4:5 PM, PDT\"} will be parsed into a {@code Date}that is equivalent to  {@code Date(837039900000L)}. \u003cp\u003e By default, parsing is lenient: If the input is not in the form used by this object\u0027s format method but can still be parsed as a date, then the parse succeeds.  Clients may insist on strict adherence to the format by calling  {@link #setLenient(boolean) setLenient(false)}. \u003cp\u003eThis parsing operation uses the  {@link #calendar} to producea  {@code Date}. As a result, the  {@code calendar}\u0027s date-time fields and the  {@code TimeZone} value may have beenoverwritten, depending on subclass implementations. Any  {@code TimeZone} value that has previously been set by a call to{@link #setTimeZone(java.util.TimeZone) setTimeZone} may needto be restored for further operations.\n * @param source  The date/time string to be parsed\n * @param pos   On input, the position at which to start parsing; onoutput, the position at which parsing terminated, or the start position if the parse failed.\n * @return      A {@code Date}, or  {@code null} if the input could not be parsed\n */\n","tf":{"freq":{"fals":1,"client":1,"insist":1,"lenient":3,"pos":1,"time":9,"fail":1,"given":1,"equival":1,"oper":2,"onoutput":1,"text":1,"succeed":1,"form":1,"format":2,"beenoverwritten":1,"input":3,"needto":1,"start":2,"will":1,"subclass":1,"restor":1,"sourc":1,"strict":1,"posit":4,"util":1,"call":2,"result":1,"adher":1,"link":3,"use":2,"object":1,"date":8,"valu":2,"calendar":2,"may":3,"previous":1,"depend":1,"still":1,"producea":1,"accord":1,"field":1,"termin":1,"string":2,"exampl":1,"method":1,"java":1,"pars":13,"zone":5},"maxFreq":13,"totalTerms":99},"loc":0}