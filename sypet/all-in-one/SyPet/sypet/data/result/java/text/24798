{"id":24798,"className":"java.text.MessageFormat","methodName":"parse","signature":"\u003cjava.text.MessageFormat: java.lang.Object[] parse(java.lang.String,java.text.ParsePosition)\u003e","javadoc":"/** \n * Parses the string. \u003cp\u003eCaveats: The parse may fail in a number of circumstances. For example: \u003cul\u003e \u003cli\u003eIf one of the arguments does not occur in the pattern. \u003cli\u003eIf the format of an argument loses information, such as with a choice format where a large number formats to \"many\". \u003cli\u003eDoes not yet handle recursion (where the substituted strings contain {n} references.) \u003cli\u003eWill not always find a match (or the correct match) if some part of the parse is ambiguous. For example, if the pattern \"{1},{2}\" is used with the string arguments {\"a,b\", \"c\"}, it will format as \"a,b,c\". When the result is parsed, it will return {\"a\", \"b,c\"}. \u003cli\u003eIf a single argument is parsed more than once in the string, then the later parse wins. \u003c/ul\u003e When the parse fails, use ParsePosition.getErrorIndex() to find out where in the string the parsing failed.  The returned error index is the starting offset of the sub-patterns that the string is comparing with.  For example, if the parsing string \"AAA {0} BBB\" is comparing against the pattern \"AAD {0} BBB\", the error index is 0. When an error occurs, the call to this method will return null. If the source is null, return an empty array.\n */\n","tf":{"freq":{"call":1,"result":1,"sub":1,"singl":1,"one":1,"use":2,"caveat":1,"ambigu":1,"substitut":1,"correct":1,"fail":3,"refer":1,"offset":1,"find":2,"argument":4,"mani":1,"index":3,"may":1,"error":4,"later":1,"alway":1,"choic":1,"circumst":1,"number":2,"win":1,"format":4,"empti":1,"handl":1,"lose":1,"inform":1,"pattern":4,"start":1,"larg":1,"string":7,"contain":1,"will":4,"exampl":3,"sourc":1,"method":1,"match":2,"part":1,"compar":2,"posit":1,"pars":11,"recurs":1,"array":1,"occur":2,"yet":1},"maxFreq":11,"totalTerms":91},"loc":75}