{"id":27538,"className":"org.ietf.jgss.GSSManager","methodName":"addProviderAtEnd","signature":"\u003corg.ietf.jgss.GSSManager: void addProviderAtEnd(java.security.Provider,org.ietf.jgss.Oid)\u003e","javadoc":"/** \n * This method is used to indicate to the GSSManager that the application would like a particular provider to be used if no other provider can be found that supports the given mechanism. When a value of null is used instead of an Oid for the mechanism, the GSSManager must use the indicated provider for any mechanism.\u003cp\u003e Calling this method repeatedly preserves the older settings but raises them above newer ones in preference thus forming an ordered list of providers and Oid pairs that grows at the bottom. Thus the older provider settings will be utilized first before this one is.\u003cp\u003e If there are any previously existing preferences that conflict with the preference being set here, then the GSSManager should ignore this request.\u003cp\u003e If the GSSManager implementation does not support an SPI with a pluggable provider architecture it should throw a GSSException with the status code GSSException.UNAVAILABLE to indicate that the operation is unavailable.\u003cp\u003e Suppose an application desired that when a mechanism of Oid m1 is needed the system default providers always be checked first, and only when they do not support m1 should a provider A be checked. It would then make the call:\u003cp\u003e \u003cpre\u003e GSSManager mgr \u003d GSSManager.getInstance(); mgr.addProviderAtEnd(A, m1); \u003c/pre\u003e Now, if it also desired that for all mechanisms the provider B be checked after all configured providers have been checked, it would then call:\u003cp\u003e \u003cpre\u003e mgr.addProviderAtEnd(B, null); \u003c/pre\u003e Effectively the list of preferences now becomes {..., (A, m1), (B, null)}.\u003cp\u003e Suppose at a later time the following call is made to the same GSSManager instance:\u003cp\u003e \u003cpre\u003e mgr.addProviderAtEnd(B, m2) \u003c/pre\u003e then the previous setting with the pair (B, null) subsumes this and therefore this request should be ignored. The same would happen if a request is made for the already existing pairs of (A, m1) or (B, null).\u003cp\u003e Please note, however, that the following call:\u003cp\u003e \u003cpre\u003e mgr.addProviderAtEnd(A, null) \u003c/pre\u003e is not subsumed by the previous setting of (A, m1) and the list will effectively become {..., (A, m1), (B, null), (A, null)}\n * @param p the provider instance that should be used whenever supportis needed for mech.\n * @param mech the mechanism for which the provider is being set\n * @throws GSSException containing the followingmajor error codes: {@link GSSException#UNAVAILABLE GSSException.UNAVAILABLE}, {@link GSSException#FAILURE GSSException.FAILURE}\n */\n","tf":{"freq":{"need":2,"subsum":2,"pluggabl":1,"particular":1,"sexcept":7,"desir":2,"smanag":7,"must":1,"time":1,"becom":2,"given":1,"oper":1,"request":3,"unavail":1,"howev":1,"happen":1,"follow":2,"ignor":2,"support":3,"form":1,"status":1,"alway":1,"preserv":1,"like":1,"provid":17,"mgr":5,"instanc":3,"configur":1,"system":1,"now":2,"contain":1,"bottom":1,"will":2,"conflict":1,"prefer":4,"make":1,"util":1,"call":5,"pair":3,"link":2,"one":2,"made":2,"use":5,"therefor":1,"repeat":1,"add":5,"applic":2,"pleas":1,"rais":1,"indic":3,"order":1,"older":2,"oid":3,"followingmajor":1,"valu":1,"exist":2,"note":1,"end":5,"whenev":1,"mech":2,"error":1,"check":4,"previous":3,"thus":2,"later":1,"suppos":2,"list":3,"effect":2,"architectur":1,"pre":8,"newer":1,"mechan":6,"grow":1,"instead":1,"supporti":1,"alreadi":1,"method":2,"also":1,"first":2,"found":1},"maxFreq":17,"totalTerms":182},"loc":0}