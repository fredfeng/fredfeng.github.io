{"id":27583,"className":"org.ietf.jgss.GSSContext","methodName":"verifyMIC","signature":"\u003corg.ietf.jgss.GSSContext: void verifyMIC(java.io.InputStream,java.io.InputStream,org.ietf.jgss.MessageProp)\u003e","javadoc":"/** \n * Uses streams to verify the cryptographic MIC, contained in the token parameter, over the supplied message.  This method is equivalent to the byte array based  {@link #verifyMIC(byte[],int,int,byte[],int,int,MessageProp) verifyMIC} method.The MessageProp object is instantiated by the application and is used by the underlying mechanism to return information to the caller such as the QOP indicating the strength of protection that was applied to the message and other supplementary message state information.\u003cp\u003e Since some application-level protocols may wish to use tokens emitted by getMIC to provide \"secure framing\", implementations should support the calculation and verification of MICs over zero-length messages.\u003cp\u003e The format of the input token that this method reads is defined in the specification for the underlying mechanism that will be used. This method will attempt to read one of these tokens per invocation. If the mechanism token contains a definitive start and end this method may block on the \u003ccode\u003eInputStream\u003c/code\u003e if only part of the token is available. If the start and end of the token are not definitive then the method will attempt to treat all available bytes as part of the token.\u003cp\u003e Other than the possible blocking behavior described above, this method is equivalent to the byte array based  {@link #verifyMIC(byte[],int,int,byte[],int,int,MessageProp) verifyMIC} method.\u003cp\u003e\n * @param tokStream an InputStream containing the token generated by thepeer\u0027s getMIC method.\n * @param msgStream an InputStream containing the application message toverify the cryptographic MIC over. All of the data that is available in msgStream is used.\n * @param msgProp upon return from the method, this object will containthe applied QOP and supplementary information stating if the token was a duplicate, old, out of sequence or arriving after a gap.\n * @throws GSSException containing the followingmajor error codes: {@link GSSException#DEFECTIVE_TOKEN GSSException.DEFECTIVE_TOKEN}{@link GSSException#BAD_MIC GSSException.BAD_MIC}{@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED}{@link GSSException#FAILURE GSSException.FAILURE}\n */\n","tf":{"freq":{"supplementari":2,"verif":1,"old":1,"wish":1,"instanti":1,"possibl":1,"sexcept":9,"zero":1,"level":1,"equival":2,"sequenc":1,"cryptograph":2,"verifi":6,"support":1,"calcul":1,"describ":1,"avail":3,"format":1,"msg":3,"provid":1,"invoc":1,"thepeer":1,"inform":3,"appli":2,"input":4,"frame":1,"start":2,"definit":2,"contain":5,"duplic":1,"will":4,"arriv":1,"toverifi":1,"gap":1,"upon":1,"treat":1,"array":2,"caller":1,"attempt":2,"defin":1,"stream":7,"behavior":1,"link":6,"one":1,"data":1,"state":2,"block":2,"use":5,"object":2,"applic":3,"indic":1,"token":10,"containth":1,"followingmajor":1,"length":1,"read":2,"tok":1,"end":2,"emit":1,"protocol":1,"may":2,"error":1,"strength":1,"messag":8,"prop":4,"paramet":1,"suppli":1,"specif":1,"secur":1,"per":1,"mechan":3,"generat":1,"base":2,"method":10,"part":2},"maxFreq":10,"totalTerms":167},"loc":0}