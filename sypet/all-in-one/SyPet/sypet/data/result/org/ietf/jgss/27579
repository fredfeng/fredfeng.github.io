{"id":27579,"className":"org.ietf.jgss.GSSContext","methodName":"unwrap","signature":"\u003corg.ietf.jgss.GSSContext: void unwrap(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)\u003e","javadoc":"/** \n * Uses streams to process tokens generated by the \u003ccode\u003ewrap\u003c/code\u003e method on the other side of the context. The method will return the message supplied by the peer application to its wrap call, while at the same time verifying the embedded MIC for that message.\u003cp\u003e The MessageProp object is instantiated by the application and is used by the underlying mechanism to return information to the caller such as the QOP, whether confidentiality was applied to the message, and other supplementary message state information.\u003cp\u003e Since some application-level protocols may wish to use tokens emitted by wrap to provide \"secure framing\", implementations should support the wrapping and unwrapping of zero-length messages.\u003cp\u003e The format of the input token that this method reads is defined in the specification for the underlying mechanism that will be used. This method will attempt to read one of these tokens per invocation. If the mechanism token contains a definitive start and end this method may block on the \u003ccode\u003eInputStream\u003c/code\u003e if only part of the token is available. If the start and end of the token are not definitive then the method will attempt to treat all available bytes as part of the token.\u003cp\u003e Other than the possible blocking behavior described above, this method is equivalent to the byte array based  {@link #unwrap(byte[],int,int,MessageProp) unwrap} method.\u003cp\u003e\n * @param inStream an InputStream that contains the wrap token generatedby the peer.\n * @param outStream an OutputStream to write the application messageto.\n * @param msgProp upon return from the method, this object will containthe applied QOP, the privacy state of the message, and supplementary information stating if the token was a duplicate, old, out of sequence or arriving after a gap.\n * @throws GSSException containing the followingmajor error codes: {@link GSSException#DEFECTIVE_TOKEN GSSException.DEFECTIVE_TOKEN}, {@link GSSException#BAD_MIC GSSException.BAD_MIC}, {@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED}, {@link GSSException#FAILURE GSSException.FAILURE}\n */\n","tf":{"freq":{"supplementari":2,"old":1,"unwrap":4,"wish":1,"instanti":1,"possibl":1,"sexcept":9,"zero":1,"whether":1,"generatedbi":1,"time":1,"level":1,"equival":1,"sequenc":1,"verifi":1,"wrap":5,"support":1,"describ":1,"avail":2,"format":1,"msg":1,"provid":1,"invoc":1,"embed":1,"inform":3,"appli":2,"input":3,"frame":1,"start":2,"definit":2,"contain":3,"duplic":1,"will":5,"arriv":1,"output":1,"gap":1,"upon":1,"array":1,"treat":1,"caller":1,"attempt":2,"call":1,"defin":1,"stream":6,"behavior":1,"link":5,"one":1,"state":3,"block":2,"use":4,"object":2,"applic":4,"token":10,"side":1,"privaci":1,"containth":1,"followingmajor":1,"write":1,"length":1,"read":2,"messageto":1,"end":2,"peer":2,"emit":1,"confidenti":1,"protocol":1,"may":2,"error":1,"messag":8,"prop":3,"suppli":1,"process":1,"specif":1,"secur":1,"per":1,"mechan":3,"generat":1,"base":1,"context":1,"method":9,"part":2},"maxFreq":10,"totalTerms":164},"loc":0}