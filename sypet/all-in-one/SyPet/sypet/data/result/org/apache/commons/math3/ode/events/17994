{"id":17994,"className":"org.apache.commons.math3.ode.events.EventHandler","methodName":"g","signature":"\u003corg.apache.commons.math3.ode.events.EventHandler: double g(double,double[])\u003e","javadoc":"/** \n * Compute the value of the switching function. \u003cp\u003eThe discrete events are generated when the sign of this switching function changes. The integrator will take care to change the stepsize in such a way these events occur exactly at step boundaries. The switching function must be continuous in its roots neighborhood (but not necessarily smooth), as the integrator will need to find its roots to locate precisely the events.\u003c/p\u003e \u003cp\u003eAlso note that the integrator expect that once an event has occurred, the sign of the switching function at the start of the next step (i.e. just after the event) is the opposite of the sign just before the event. This consistency between the steps \u003cstring\u003emust\u003c/strong\u003e be preserved, otherwise  {@link org.apache.commons.math3.exception.NoBracketingException exceptions} related to root not being bracketed will occur.\u003c/p\u003e\u003cp\u003eThis need for consistency is sometimes tricky to achieve. A typical example is using an event to model a ball bouncing on the floor. The first idea to represent this would be to have  {@code g(t) \u003d h(t)} where h is theheight above the floor at time  {@code t}. When  {@code g(t)} reaches 0, theball is on the floor, so it should bounce and the typical way to do this is to reverse its vertical velocity. However, this would mean that before the event  {@code g(t)} was decreasing from positive values to 0, and after theevent  {@code g(t)} would be increasing from 0 to positive values again.Consistency is broken here! The solution here is to have  {@code g(t) \u003d sign* h(t)}, where sign is a variable with initial value set to  {@code +1}. Each time  {@link #eventOccurred(double,double[],boolean) eventOccurred} is called,{@code sign} is reset to {@code -sign}. This allows the  {@code g(t)}function to remain continuous (and even smooth) even across events, despite {@code h(t)} is not. Basically, the event is used to \u003cem\u003efold\u003c/em\u003e {@code h(t)}at bounce points, and  {@code sign} is used to \u003cem\u003eunfold\u003c/em\u003e it back, so thesolvers sees a  {@code g(t)} function which behaves smoothly even across events.\u003c/p\u003e\n * @param t current value of the independent \u003ci\u003etime\u003c/i\u003e variable\n * @param y array containing the current value of the state vector\n * @return value of the g switching function\n */\n","tf":{"freq":{"need":2,"decreas":1,"behav":1,"variabl":2,"expect":1,"time":3,"event":13,"relat":1,"reset":1,"tricki":1,"veloc":1,"apach":1,"neighborhood":1,"thebal":1,"floor":3,"start":1,"unfold":1,"will":3,"posit":2,"array":1,"increas":1,"solut":1,"discret":1,"idea":1,"smooth":3,"common":1,"link":2,"next":1,"typic":2,"use":3,"org":1,"across":2,"revers":1,"stepsiz":1,"current":2,"sometim":1,"initi":1,"note":1,"just":2,"ball":1,"repres":1,"back":1,"despit":1,"math":1,"broken":1,"point":1,"remain":1,"string":1,"exampl":1,"necessarili":1,"bounc":3,"integr":3,"root":3,"bracket":2,"must":2,"function":7,"independ":1,"thesolv":1,"basic":1,"exact":1,"precis":1,"care":1,"howev":1,"except":3,"vertic":1,"consist":3,"preserv":1,"continu":2,"sign":8,"strong":1,"theevent":1,"contain":1,"comput":1,"even":3,"boundari":1,"otherwis":1,"call":1,"model":1,"allow":1,"state":1,"way":2,"opposit":1,"reach":1,"vector":1,"mean":1,"valu":7,"find":1,"locat":1,"fold":1,"achiev":1,"take":1,"generat":1,"theheight":1,"chang":2,"also":1,"first":1,"step":3,"occur":5},"maxFreq":13,"totalTerms":170},"loc":0}