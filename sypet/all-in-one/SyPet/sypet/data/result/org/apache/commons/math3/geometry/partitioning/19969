{"id":19969,"className":"org.apache.commons.math3.geometry.partitioning.BSPTree","methodName":"merge","signature":"\u003corg.apache.commons.math3.geometry.partitioning.BSPTree: org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e merge(org.apache.commons.math3.geometry.partitioning.BSPTree,org.apache.commons.math3.geometry.partitioning.BSPTree$LeafMerger)\u003e","javadoc":"/** \n * Merge a BSP tree with the instance. \u003cp\u003eAll trees are modified (parts of them are reused in the new tree), it is the responsibility of the caller to ensure a copy has been done before if any of the former tree should be preserved, \u003cem\u003eno\u003c/em\u003e such copy is done here!\u003c/p\u003e \u003cp\u003eThe algorithm used here is directly derived from the one described in the Naylor, Amanatides and Thibault paper (section III, Binary Partitioning of a BSP Tree).\u003c/p\u003e\n * @param tree other tree to merge with the instance (will be\u003cem\u003eunusable\u003c/em\u003e after the operation, as well as the instance itself)\n * @param leafMerger object implementing the final merging phase(this is where the semantic of the operation occurs, generally depending on the attribute of the leaf node)\n * @return a new tree, result of \u003ccode\u003einstance \u0026lt;op\u0026gt;tree\u003c/code\u003e, this value can be ignored if parentTree is not null since all connections have already been established\n */\n","tf":{"freq":{"caller":1,"result":1,"binari":1,"connect":1,"naylor":1,"deriv":1,"paper":1,"partit":1,"one":1,"use":1,"former":1,"object":1,"leaf":2,"well":1,"reus":1,"copi":2,"ensur":1,"algorithm":1,"attribut":1,"tree":10,"oper":2,"semant":1,"valu":1,"direct":1,"amanatid":1,"ignor":1,"thibault":1,"respons":1,"depend":1,"done":2,"establish":1,"preserv":1,"parent":1,"merger":1,"describ":1,"general":1,"section":1,"instanc":4,"node":1,"unus":1,"will":1,"modifi":1,"alreadi":1,"part":1,"phase":1,"merg":4,"occur":1},"maxFreq":10,"totalTerms":66},"loc":3}