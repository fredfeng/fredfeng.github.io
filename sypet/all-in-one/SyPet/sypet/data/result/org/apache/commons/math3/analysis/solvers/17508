{"id":17508,"className":"org.apache.commons.math3.analysis.solvers.UnivariateSolverUtils","methodName":"bracket","signature":"\u003corg.apache.commons.math3.analysis.solvers.UnivariateSolverUtils: double[] bracket(org.apache.commons.math3.analysis.UnivariateFunction,double,double,double,double,double,int)\u003e","javadoc":"/** \n * This method attempts to find two values a and b satisfying \u003cul\u003e \u003cli\u003e  {@code lowerBound \u003c\u003d a \u003c initial \u003c b \u003c\u003d upperBound} \u003c/li\u003e\u003cli\u003e  {@code f(a) * f(b) \u003c\u003d 0} \u003c/li\u003e\u003c/ul\u003e If  {@code f} is continuous on {@code [a,b]}, this means that  {@code a}and  {@code b} bracket a root of {@code f}. \u003cp\u003e The algorithm checks the sign of \\( f(l_k) \\) and \\( f(u_k) \\) for increasing values of k, where \\( l_k \u003d max(lower, initial - \\delta_k) \\), \\( u_k \u003d min(upper, initial + \\delta_k) \\), using recurrence \\( \\delta_{k+1} \u003d r \\delta_k + q, \\delta_0 \u003d 0\\) and starting search with \\( k\u003d1 \\). The algorithm stops when one of the following happens: \u003cul\u003e \u003cli\u003e at least one positive and one negative value have been found --  success!\u003c/li\u003e \u003cli\u003e both endpoints have reached their respective limits -- NoBracketingException \u003c/li\u003e \u003cli\u003e  {@code maximumIterations} iterations elapse -- NoBracketingException \u003c/li\u003e\u003c/ul\u003e\u003c/p\u003e\u003cp\u003e If different signs are found at first iteration ( {@code k\u003d1}), then the returned interval will be \\( [a, b] \u003d [l_1, u_1] \\). If different signs are found at a later iteration ({code k\u003e1}, then the returned interval will be either \\( [a, b] \u003d [l_{k+1}, l_{k}] \\) or \\( [a, b] \u003d [u_{k}, u_{k+1}] \\). A root solver called with these parameters will therefore start with the smallest bracketing interval known at this step. \u003c/p\u003e \u003cp\u003e Interval expansion rate is tuned by changing the recurrence parameters  {@code r} and{@code q}. When the multiplicative factor  {@code r} is set to 1, the sequence is asimple arithmetic sequence with linear increase. When the multiplicative factor  {@code r}is larger than 1, the sequence has an asymptotically exponential rate. Note than the additive parameter  {@code q} should never be set to zero, otherwise the interval woulddegenerate to the single initial point for all values of  {@code k}. \u003c/p\u003e \u003cp\u003e As a rule of thumb, when the location of the root is expected to be approximately known within some error margin,  {@code r} should be set to 1 and {@code q} should be set to theorder of magnitude of the error margin. When the location of the root is really a wild guess, then  {@code r} should be set to a value larger than 1 (typically 2 to double the intervallength at each iteration) and  {@code q} should be set according to half the initialsearch interval length. \u003c/p\u003e \u003cp\u003e As an example, if we consider the trivial function  {@code f(x) \u003d 1 - x} and use{@code initial \u003d 4},  {@code r \u003d 1},  {@code q \u003d 2}, the algorithm will compute {@code f(4-2) \u003d f(2) \u003d -1} and {@code f(4+2) \u003d f(6) \u003d -5} for {@code k \u003d 1}, then {@code f(4-4) \u003d f(0) \u003d +1} and {@code f(4+4) \u003d f(8) \u003d -7} for {@code k \u003d 2}. Then it will return the interval  {@code [0, 2]} as the smallest one known to be bracketing the root.As shown by this example, the initial value (here  {@code 4}) may lie outside of the returned bracketing interval. \u003c/p\u003e\n * @param function function to check\n * @param initial Initial midpoint of interval being expanded tobracket a root.\n * @param lowerBound Lower bound (a is never lower than this value).\n * @param upperBound Upper bound (b never is greater than thisvalue).\n * @param q additive offset used to compute bounds sequence (must be strictly positive)\n * @param r multiplicative factor used to compute bounds sequence\n * @param maximumIterations Maximum number of iterations to perform\n * @return a two element array holding the bracketing values.\n * @exception NoBracketingException if function cannot be bracketed in the search interval\n */\n","tf":{"freq":{"greater":1,"lower":5,"singl":1,"zero":1,"expect":1,"elaps":1,"search":2,"sequenc":5,"exponenti":1,"margin":2,"happen":1,"limit":1,"element":1,"wild":1,"thisvalu":1,"multipl":3,"hold":1,"tobracket":1,"delta":5,"shown":1,"number":1,"woulddegener":1,"endpoint":1,"start":2,"will":5,"asimpl":1,"strict":1,"posit":2,"array":1,"increas":2,"realli":1,"theorder":1,"trivial":1,"typic":1,"use":4,"therefor":1,"consid":1,"algorithm":3,"length":1,"initi":8,"note":1,"min":1,"addit":2,"may":1,"linear":1,"max":1,"later":1,"smallest":2,"larger":2,"factor":3,"interv":10,"differ":2,"point":1,"either":1,"guess":1,"satisfi":1,"exampl":2,"method":1,"within":1,"iter":7,"respect":1,"bound":8,"root":6,"least":1,"arithmet":1,"half":1,"perform":1,"approxim":1,"bracket":10,"must":1,"asymptot":1,"function":4,"expand":1,"follow":1,"except":4,"expans":1,"tune":1,"continu":1,"sign":3,"solver":1,"initialsearch":1,"outsid":1,"maximum":3,"comput":3,"negat":1,"known":3,"recurr":2,"thumb":1,"attempt":1,"otherwis":1,"stop":1,"call":1,"one":4,"reach":1,"upper":4,"midpoint":1,"rate":2,"rule":1,"mean":1,"valu":8,"offset":1,"find":1,"locat":2,"check":2,"error":2,"paramet":3,"magnitud":1,"intervallength":1,"accord":1,"two":2,"never":3,"chang":1,"first":1,"success":1,"lie":1,"step":1,"found":3},"maxFreq":10,"totalTerms":234},"loc":60}