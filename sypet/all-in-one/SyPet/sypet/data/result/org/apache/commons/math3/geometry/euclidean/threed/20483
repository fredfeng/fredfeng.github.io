{"id":20483,"className":"org.apache.commons.math3.geometry.euclidean.threed.Rotation","methodName":"Rotation","signature":"\u003corg.apache.commons.math3.geometry.euclidean.threed.Rotation: void Rotation(double,double,double,double,boolean)\u003e","javadoc":"/** \n * Build a rotation from the quaternion coordinates. \u003cp\u003eA rotation can be built from a \u003cem\u003enormalized\u003c/em\u003e quaternion, i.e. a quaternion for which q\u003csub\u003e0\u003c/sub\u003e\u003csup\u003e2\u003c/sup\u003e + q\u003csub\u003e1\u003c/sub\u003e\u003csup\u003e2\u003c/sup\u003e + q\u003csub\u003e2\u003c/sub\u003e\u003csup\u003e2\u003c/sup\u003e + q\u003csub\u003e3\u003c/sub\u003e\u003csup\u003e2\u003c/sup\u003e \u003d 1. If the quaternion is not normalized, the constructor can normalize it in a preprocessing step.\u003c/p\u003e \u003cp\u003eNote that some conventions put the scalar part of the quaternion as the 4\u003csup\u003eth\u003c/sup\u003e component and the vector part as the first three components. This is \u003cem\u003enot\u003c/em\u003e our convention. We put the scalar part as the first component.\u003c/p\u003e\n * @param q0 scalar part of the quaternion\n * @param q1 first coordinate of the vectorial part of the quaternion\n * @param q2 second coordinate of the vectorial part of the quaternion\n * @param q3 third coordinate of the vectorial part of the quaternion\n * @param needsNormalization if true, the coordinates are considerednot to be normalized, a normalization preprocessing step is performed before using them\n */\n","tf":{"freq":{"need":1,"sub":8,"put":2,"convent":2,"second":1,"normal":6,"use":1,"perform":1,"sup":10,"build":1,"vector":1,"three":1,"built":1,"note":1,"constructor":1,"coordin":5,"scalar":3,"vectori":3,"quaternion":9,"rotat":3,"true":1,"third":1,"considerednot":1,"compon":3,"preprocess":2,"part":7,"first":3,"step":2},"maxFreq":10,"totalTerms":81},"loc":17}