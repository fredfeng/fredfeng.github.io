{"id":21900,"className":"org.apache.commons.math3.linear.SymmLQ","methodName":"solveInPlace","signature":"\u003corg.apache.commons.math3.linear.SymmLQ: org.apache.commons.math3.linear.RealVector solveInPlace(org.apache.commons.math3.linear.RealLinearOperator,org.apache.commons.math3.linear.RealLinearOperator,org.apache.commons.math3.linear.RealVector,org.apache.commons.math3.linear.RealVector,boolean,double)\u003e","javadoc":"/** \n * Returns an estimate of the solution to the linear system (A - shift \u0026middot; I) \u0026middot; x \u003d b. The solution is computed in-place. \u003cp\u003e If the solution x is expected to contain a large multiple of  {@code b}(as in Rayleigh-quotient iteration), then better precision may be achieved with  {@code goodb} set to {@code true}; this however requires an extra call to the preconditioner. \u003c/p\u003e \u003cp\u003e {@code shift} should be zero if the system A \u0026middot; x \u003d b is to besolved. Otherwise, it could be an approximation to an eigenvalue of A, such as the Rayleigh quotient b\u003csup\u003eT\u003c/sup\u003e \u0026middot; A \u0026middot; b / (b\u003csup\u003eT\u003c/sup\u003e \u0026middot; b) corresponding to the vector b. If b is sufficiently like an eigenvector corresponding to an eigenvalue near shift, then the computed x may have very large components. When normalized, x may be closer to an eigenvector than b. \u003c/p\u003e\n * @param a the linear operator A of the system\n * @param m the preconditioner, M (can be {@code null})\n * @param b the right-hand side vector\n * @param x the vector to be updated with the solution; {@code x} shouldnot be considered as an initial guess (\u003ca href\u003d\"#initguess\"\u003emore\u003c/a\u003e)\n * @param goodb usually {@code false}, except if  {@code x} is expected tocontain a large multiple of  {@code b}\n * @param shift the amount to be subtracted to all diagonal elements of A\n * @return a reference to {@code x} (shallow copy).\n * @throws NullArgumentException if one of the parameters is {@code null}\n * @throws NonSquareOperatorException if {@code a} or {@code m} is not square\n * @throws DimensionMismatchException if {@code m},  {@code b} or {@code x}have dimensions inconsistent with  {@code a}.\n * @throws MaxCountExceededException at exhaustion of the iteration count,unless a custom {@link org.apache.commons.math3.util.Incrementor.MaxCountExceededCallback callback}has been set at construction of the  {@link IterationManager}\n * @throws NonSelfAdjointOperatorException if {@link #getCheck()} is{@code true}, and  {@code a} or {@code m} is not self-adjoint\n * @throws NonPositiveDefiniteOperatorException if {@code m} is not positivedefinite\n * @throws IllConditionedOperatorException if {@code a} is ill-conditioned\n */\n","tf":{"freq":{"fals":1,"squar":2,"quotient":2,"count":3,"normal":1,"incrementor":1,"approxim":1,"zero":1,"copi":1,"amount":1,"initguess":1,"expect":2,"estim":1,"requir":1,"rayleigh":2,"refer":1,"oper":5,"precis":1,"eigenvector":2,"tocontain":1,"howev":1,"place":2,"href":1,"right":1,"custom":1,"shouldnot":1,"argument":1,"element":1,"except":8,"multipl":2,"shallow":1,"extra":1,"middot":6,"apach":1,"like":1,"solv":1,"non":3,"system":3,"precondition":2,"near":1,"updat":1,"better":1,"definit":1,"contain":1,"comput":2,"suffici":1,"posit":1,"util":1,"solut":4,"otherwis":1,"inconsist":1,"call":1,"common":1,"correspond":2,"link":3,"one":1,"self":2,"org":1,"diagon":1,"sup":4,"closer":1,"consid":1,"hand":1,"unless":1,"side":1,"besolv":1,"vector":3,"goodb":2,"initi":1,"condit":2,"usual":1,"may":3,"linear":2,"max":2,"ill":2,"check":1,"manag":1,"exceed":2,"paramet":1,"eigenvalu":2,"true":2,"positivedefinit":1,"dimens":2,"achiev":1,"math":1,"subtract":1,"compon":1,"guess":1,"larg":3,"callback":2,"exhaust":1,"construct":1,"mismatch":1,"iter":3,"shift":4,"adjoint":2},"maxFreq":8,"totalTerms":159},"loc":54}