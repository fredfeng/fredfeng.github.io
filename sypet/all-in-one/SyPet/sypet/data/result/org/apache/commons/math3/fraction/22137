{"id":22137,"className":"org.apache.commons.math3.fraction.BigFraction","methodName":"BigFraction","signature":"\u003corg.apache.commons.math3.fraction.BigFraction: void BigFraction(double)\u003e","javadoc":"/** \n * Create a fraction given the double value. \u003cp\u003e This constructor behaves \u003cem\u003edifferently\u003c/em\u003e from {@link #BigFraction(double,double,int)}. It converts the double value exactly, considering its internal bits representation. This works for all values except NaN and infinities and does not requires any loop or convergence threshold. \u003c/p\u003e \u003cp\u003e Since this conversion is exact and since double numbers are sometimes approximated, the fraction created may seem strange in some cases. For example, calling \u003ccode\u003enew BigFraction(1.0 / 3.0)\u003c/code\u003e does \u003cem\u003enot\u003c/em\u003e create the fraction 1/3, but the fraction 6004799503160661 / 18014398509481984 because the double number passed to the constructor is not exactly 1/3 (this number cannot be stored exactly in IEEE754). \u003c/p\u003e\n * @see #BigFraction(double,double,int)\n * @param value the double value to convert to a fraction.\n * @exception MathIllegalArgumentException if value is NaN or infinite\n */\n","tf":{"freq":{"call":1,"store":1,"behav":1,"infin":1,"link":1,"strang":1,"convers":1,"convert":2,"approxim":1,"consid":1,"infinit":1,"requir":1,"given":1,"exact":4,"loop":1,"sometim":1,"valu":6,"converg":1,"constructor":2,"argument":1,"work":1,"may":1,"fraction":9,"except":3,"creat":3,"number":3,"illeg":1,"seem":1,"pass":1,"represent":1,"threshold":1,"math":1,"differ":1,"bit":1,"exampl":1,"intern":1,"big":4},"maxFreq":9,"totalTerms":64},"loc":35}