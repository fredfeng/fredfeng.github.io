{"id":16702,"className":"org.apache.commons.math3.optimization.direct.MultivariateFunctionPenaltyAdapter","methodName":"MultivariateFunctionPenaltyAdapter","signature":"\u003corg.apache.commons.math3.optimization.direct.MultivariateFunctionPenaltyAdapter: void MultivariateFunctionPenaltyAdapter(org.apache.commons.math3.analysis.MultivariateFunction,double[],double[],double,double[])\u003e","javadoc":"/** \n * Simple constructor. \u003cp\u003e When the optimizer provided points are out of range, the value of the penalty function will be used instead of the value of the underlying function. In order for this penalty to be effective in rejecting this point during the optimization process, the penalty function value should be defined with care. This value is computed as: \u003cpre\u003e penalty(point) \u003d offset + \u0026sum;\u003csub\u003ei\u003c/sub\u003e[scale[i] * \u0026radic;|point[i]-boundary[i]|] \u003c/pre\u003e where indices i correspond to all the components that violates their boundaries. \u003c/p\u003e \u003cp\u003e So when attempting a function minimization, offset should be larger than the maximum expected value of the underlying function and scale components should all be positive. When attempting a function maximization, offset should be lesser than the minimum expected value of the underlying function and scale components should all be negative. minimization, and lesser than the minimum expected value of the underlying function when attempting maximization. \u003c/p\u003e \u003cp\u003e These choices for the penalty function have two properties. First, all out of range points will return a function value that is worse than the value returned by any in range point. Second, the penalty is worse for large boundaries violation than for small violations, so the optimizer has an hint about the direction in which it should search for acceptable points. \u003c/p\u003e\n * @param bounded bounded function\n * @param lower lower bounds for each element of the input parameters array(some elements may be set to  {@code Double.NEGATIVE_INFINITY} forunbounded values)\n * @param upper upper bounds for each element of the input parameters array(some elements may be set to  {@code Double.POSITIVE_INFINITY} forunbounded values)\n * @param offset base offset of the penalty function\n * @param scale scale of the penalty function\n * @exception DimensionMismatchException if lower bounds, upper bounds andscales are not consistent, either according to dimension or to bounadary values\n */\n","tf":{"freq":{"lower":3,"simpl":1,"second":1,"accept":1,"bounadari":1,"forunbound":2,"violat":3,"lesser":2,"function":14,"expect":3,"maxim":2,"search":1,"rang":3,"care":1,"element":4,"except":2,"consist":1,"wors":2,"provid":1,"input":2,"multivari":1,"maximum":1,"will":2,"comput":1,"negat":1,"properti":1,"small":1,"boundari":3,"posit":1,"array":2,"attempt":3,"defin":1,"scale":5,"sub":2,"andscal":1,"reject":1,"minimum":2,"correspond":1,"sum":1,"use":1,"adapt":1,"minim":2,"upper":3,"order":1,"indic":1,"valu":12,"offset":5,"constructor":1,"direct":1,"may":2,"penalti":9,"optim":3,"larger":1,"paramet":2,"choic":1,"hint":1,"accord":1,"dimens":2,"radic":1,"process":1,"point":7,"two":1,"either":1,"effect":1,"compon":3,"larg":1,"pre":2,"base":1,"instead":1,"mismatch":1,"first":1,"bound":6},"maxFreq":14,"totalTerms":159},"loc":26}