{"id":10071,"className":"org.w3c.dom.Text","methodName":"splitText","signature":"\u003corg.w3c.dom.Text: org.w3c.dom.Text splitText(int)\u003e","javadoc":"/** \n * Breaks this node into two nodes at the specified \u003ccode\u003eoffset\u003c/code\u003e, keeping both in the tree as siblings. After being split, this node will contain all the content up to the \u003ccode\u003eoffset\u003c/code\u003e point. A new node of the same type, which contains all the content at and after the \u003ccode\u003eoffset\u003c/code\u003e point, is returned. If the original node had a parent node, the new node is inserted as the next sibling of the original node. When the \u003ccode\u003eoffset\u003c/code\u003e is equal to the length of this node, the new node has no data.\n * @param offset The 16-bit unit offset at which to split, starting from\u003ccode\u003e0\u003c/code\u003e.\n * @return The new node, of the same type as this node.\n * @exception DOMException INDEX_SIZE_ERR: Raised if the specified offset is negative or greater than the number of 16-bit units in \u003ccode\u003edata\u003c/code\u003e. \u003cbr\u003eNO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.\n */\n","tf":{"freq":{"greater":1,"mexcept":1,"next":1,"data":2,"type":2,"specifi":2,"rais":2,"readon":1,"tree":1,"length":1,"offset":7,"except":1,"text":1,"sibl":2,"origin":2,"parent":1,"number":1,"equal":1,"content":2,"two":1,"point":2,"bit":2,"unit":2,"node":13,"start":1,"contain":2,"will":1,"negat":1,"split":3,"insert":1,"keep":1},"maxFreq":13,"totalTerms":62},"loc":0}