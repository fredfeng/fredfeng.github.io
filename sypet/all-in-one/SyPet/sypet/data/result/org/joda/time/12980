{"id":12980,"className":"org.joda.time.LocalDate","methodName":"fromCalendarFields","signature":"\u003corg.joda.time.LocalDate: org.joda.time.LocalDate fromCalendarFields(java.util.Calendar)\u003e","javadoc":"/** \n * Constructs a LocalDate from a \u003ccode\u003ejava.util.Calendar\u003c/code\u003e using exactly the same field values. \u003cp\u003e Each field is queried from the Calendar and assigned to the LocalDate. This is useful if you have been using the Calendar as a local date, ignoring the zone. \u003cp\u003e One advantage of this method is that this method is unaffected if the version of the time zone data differs between the JDK and Joda-Time. That is because the local field values are transferred, calculated using the JDK time zone data and without using the Joda-Time time zone data. \u003cp\u003e This factory method ignores the type of the calendar and always creates a LocalDate with ISO chronology. It is expected that you will only pass in instances of \u003ccode\u003eGregorianCalendar\u003c/code\u003e however this is not validated.\n * @param calendar  the Calendar to extract fields from, not null\n * @return the created local date, not null\n * @throws IllegalArgumentException if the calendar is null\n * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n */\n","tf":{"freq":{"valid":1,"assign":1,"one":1,"data":3,"use":5,"type":1,"date":6,"version":1,"expect":1,"time":5,"invalid":1,"chronolog":2,"factori":1,"exact":1,"valu":2,"joda":2,"howev":1,"calendar":9,"argument":2,"except":2,"ignor":2,"transfer":1,"creat":2,"alway":1,"calcul":1,"advantag":1,"unaffect":1,"illeg":2,"without":1,"extract":1,"instanc":1,"pass":1,"field":5,"queri":1,"differ":1,"will":1,"java":1,"method":3,"local":6,"construct":1,"gregorian":1,"util":1,"zone":4},"maxFreq":9,"totalTerms":88},"loc":12}