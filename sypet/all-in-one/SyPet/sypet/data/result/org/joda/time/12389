{"id":12389,"className":"org.joda.time.LocalDateTime","methodName":"toDate","signature":"\u003corg.joda.time.LocalDateTime: java.util.Date toDate(java.util.TimeZone)\u003e","javadoc":"/** \n * Get the date time as a \u003ccode\u003ejava.util.Date\u003c/code\u003e using the specified time zone. \u003cp\u003e The \u003ccode\u003eDate\u003c/code\u003e object created has exactly the same fields as this date-time, except when the time would be invalid due to a daylight savings gap. In that case, the time will be set to the earliest valid time after the gap. \u003cp\u003e In the case of a daylight savings overlap, the earlier instant is selected. \u003cp\u003e Converting to a JDK Date is full of complications as the JDK Date constructor doesn\u0027t behave as you might expect around DST transitions. This method works by taking a first guess and then adjusting. This also handles the situation where the JDK time zone data differs from the Joda-Time time zone data. \u003cp\u003e Unlike  {@link #toDate()}, this implementation does not rely on Java\u0027s synchronized time zone initialization logic, and should demonstrate better concurrent performance characteristics.\n * @return a Date initialised with this date-time, never null\n * @since 2.3\n */\n","tf":{"freq":{"save":2,"behav":1,"perform":1,"transit":1,"situat":1,"specifi":1,"reli":1,"expect":1,"time":11,"earliest":1,"invalid":1,"exact":1,"instant":1,"work":1,"except":1,"overlap":1,"creat":1,"select":1,"logic":1,"earlier":1,"better":1,"will":1,"due":1,"demonstr":1,"util":1,"gap":2,"characterist":1,"valid":1,"might":1,"concurr":1,"link":1,"data":2,"use":1,"convert":1,"object":1,"date":10,"full":1,"adjust":1,"unlik":1,"joda":1,"initi":1,"constructor":1,"initialis":1,"around":1,"handl":1,"field":1,"differ":1,"never":1,"take":1,"guess":1,"java":2,"method":1,"complic":1,"first":1,"also":1,"daylight":2,"zone":4},"maxFreq":11,"totalTerms":84},"loc":9}