{"id":12388,"className":"org.joda.time.LocalDateTime","methodName":"toDate","signature":"\u003corg.joda.time.LocalDateTime: java.util.Date toDate()\u003e","javadoc":"/** \n * Get the date time as a \u003ccode\u003ejava.util.Date\u003c/code\u003e. \u003cp\u003e The \u003ccode\u003eDate\u003c/code\u003e object created has exactly the same fields as this date-time, except when the time would be invalid due to a daylight savings gap. In that case, the time will be set to the earliest valid time after the gap. \u003cp\u003e In the case of a daylight savings overlap, the earlier instant is selected. \u003cp\u003e Converting to a JDK Date is full of complications as the JDK Date constructor doesn\u0027t behave as you might expect around DST transitions. This method works by taking a first guess and then adjusting. This also handles the situation where the JDK time zone data differs from the Joda-Time time zone data.\n * @return a Date initialised with this date-time, never null\n * @since 2.0\n */\n","tf":{"freq":{"might":1,"valid":1,"save":2,"behav":1,"data":2,"convert":1,"object":1,"date":9,"transit":1,"situat":1,"expect":1,"time":9,"invalid":1,"earliest":1,"full":1,"exact":1,"adjust":1,"joda":1,"instant":1,"constructor":1,"work":1,"except":1,"overlap":1,"initialis":1,"creat":1,"select":1,"handl":1,"around":1,"field":1,"differ":1,"never":1,"earlier":1,"guess":1,"take":1,"will":1,"due":1,"method":1,"java":1,"complic":1,"also":1,"first":1,"zone":2,"daylight":2,"util":1,"gap":2},"maxFreq":9,"totalTerms":66},"loc":7}